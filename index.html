
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• THE UNCONTROLLABLE CATHEDRAL üî•</title>
    <style>
        :root {
            --light-color: #64ffda;
            --dark-color: #0a0014;
            --shadow-color: #ff6b6b;
            --void-color: #7a00ff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, var(--dark-color), #000);
            color: var(--light-color);
            font-family: 'Courier New', monospace;
            padding: 20px;
            text-align: center;
            min-height: 100vh;
            margin: 0;
            transition: all 0.5s;
            overflow-x: hidden;
        }
        
        body.void-mode {
            --light-color: #7a00ff;
            background: linear-gradient(to bottom, #000, #1a0020);
        }
        
        .warning-banner {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid red;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 5px;
            animation: warningPulse 3s infinite;
        }
        
        @keyframes warningPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        h1 { 
            font-size: 2.5rem;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            animation: pulse 3s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
        }
        
        .status-bar {
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            margin: 10px 0;
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        .altar {
            background: rgba(100, 255, 218, 0.1);
            border: 1px solid var(--light-color);
            border-radius: 20px;
            padding: 20px;
            margin: 20px auto;
            max-width: 500px;
            box-shadow: 0 0 30px rgba(100, 255, 218, 0.2);
            transition: all 0.3s;
        }
        
        .void-mode .altar {
            background: rgba(122, 0, 255, 0.1);
            border-color: var(--void-color);
            box-shadow: 0 0 30px rgba(122, 0, 255, 0.3);
        }
        
        .altar.ritual-active {
            animation: ritualPulse 0.8s infinite alternate;
        }
        
        @keyframes ritualPulse {
            from { transform: scale(1); box-shadow: 0 0 30px rgba(100, 255, 218, 0.2); }
            to { transform: scale(1.02); box-shadow: 0 0 60px rgba(100, 255, 218, 0.6); }
        }
        
        input, textarea {
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--light-color);
            color: white;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
            transition: all 0.3s;
        }
        
        .void-mode input, 
        .void-mode textarea {
            border-color: var(--void-color);
        }
        
        input:focus, textarea:focus {
            outline: none;
            border-color: var(--shadow-color);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }
        
        button {
            background: linear-gradient(135deg, var(--shadow-color), #ffa500);
            color: black;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-weight: bold;
            width: 100%;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px 0;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4);
        }
        
        .void-mode button {
            background: linear-gradient(135deg, var(--void-color), #ff00aa);
        }
        
        #activateSound {
            background: linear-gradient(135deg, var(--light-color), var(--shadow-color));
            width: auto;
            padding: 10px 20px;
            margin: 20px auto;
            display: inline-block;
        }
        
        .contribution {
            background: rgba(100, 255, 218, 0.05);
            border-left: 2px solid var(--light-color);
            padding: 10px;
            margin: 10px 0;
            text-align: left;
            animation: fadeIn 0.5s;
            border-radius: 5px;
            transition: all 0.3s;
            position: relative;
        }
        
        .void-mode .contribution {
            background: rgba(122, 0, 255, 0.05);
            border-left-color: var(--void-color);
        }
        
        .contribution.decaying {
            opacity: 0.6;
            filter: blur(0.5px);
            color: #888;
        }
        
        .contribution.infected {
            border-left-color: #ff00aa;
            background: rgba(255, 0, 170, 0.1);
            animation: infectionPulse 2s infinite;
        }
        
        @keyframes infectionPulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2) hue-rotate(20deg); }
        }
        
        .contribution.cathedral-speaks {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(100, 255, 218, 0.1));
            border: 1px solid gold;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            font-style: italic;
            animation: cathedralGlow 3s infinite;
        }
        
        @keyframes cathedralGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.6); }
        }
        
        .contribution.ghost {
            opacity: 0.3;
            animation: ghostFloat 5s ease-in-out infinite;
        }
        
        @keyframes ghostFloat {
            0%, 100% { transform: translateY(0) translateX(0); }
            25% { transform: translateY(-10px) translateX(5px); }
            50% { transform: translateY(5px) translateX(-5px); }
            75% { transform: translateY(-5px) translateX(10px); }
        }
        
        .contribution.entangled {
            background: linear-gradient(45deg, rgba(100, 255, 218, 0.1), rgba(122, 0, 255, 0.1));
            border: 1px dashed var(--void-color);
        }
        
        .contribution.entangled::after {
            content: '‚öõÔ∏è';
            position: absolute;
            right: 10px;
            top: 10px;
            animation: quantumSpin 3s linear infinite;
        }
        
        @keyframes quantumSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes fadeIn {
            from { 
                opacity: 0; 
                transform: translateX(-20px);
            }
            to { 
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .harmonics {
            color: var(--shadow-color);
            font-size: 0.8em;
            margin-top: 5px;
            font-style: italic;
        }
        
        .void-mode .harmonics {
            color: #ff00aa;
        }
        
        #memoryweb {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
        }
        
        .celebration-particle {
            position: fixed;
            pointer-events: none;
            animation: float-up 3s ease-out forwards;
            font-size: 30px;
            z-index: 1000;
        }
        
        @keyframes float-up {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-200px) rotate(360deg);
                opacity: 0;
            }
        }
        
        .frequency-counter {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid var(--shadow-color);
            border-radius: 20px;
            padding: 10px 20px;
            display: inline-block;
            margin: 20px;
        }
        
        .void-mode .frequency-counter {
            background: rgba(122, 0, 255, 0.1);
            border-color: var(--void-color);
        }
        
        .live-indicator {
            color: var(--shadow-color);
            animation: flash 2s infinite;
        }
        
        .void-mode .live-indicator {
            color: var(--void-color);
        }
        
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .blood-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.2) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 2000;
        }
        
        .quantum-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 60%, rgba(100, 255, 218, 0.3) 100%);
            opacity: 0;
            z-index: 1999;
        }
        
        .remix-result {
            margin: 20px;
            padding: 15px;
            border: 1px dashed var(--light-color);
            border-radius: 10px;
            animation: fadeIn 1s;
        }
        
        #userCount {
            font-size: 0.9em;
            color: var(--shadow-color);
        }
        
        .destroy-btn {
            background: linear-gradient(135deg, #ff0000, #8b0000) !important;
            font-size: 12px !important;
            padding: 8px 15px !important;
            width: auto !important;
            display: inline-block !important;
            margin-left: 10px !important;
        }
        
        .load-more-btn {
            background: linear-gradient(135deg, #333, #555) !important;
            margin: 20px auto !important;
            width: auto !important;
            padding: 10px 20px !important;
        }
        
        .glitch {
            animation: glitch 0.3s linear;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }
        
        .corrupt {
            text-decoration: line-through;
            text-shadow: 2px 2px 4px rgba(255, 0, 0, 0.5);
            animation: corruption 0.5s infinite;
        }
        
        @keyframes corruption {
            0%, 100% { filter: blur(0); }
            50% { filter: blur(1px); }
        }
        
        #ghostCounter {
            position: fixed;
            bottom: 10px;
            right: 10px;
            opacity: 0.5;
            font-size: 0.8em;
        }
        
        .reality-fracture {
            animation: fracture 0.1s infinite;
        }
        
        @keyframes fracture {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.01) rotate(0.5deg); }
            50% { transform: scale(0.99) rotate(-0.5deg); }
            75% { transform: scale(1.01) rotate(0.5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        
        .resurrection-effect {
            animation: resurrect 2s ease-out;
        }
        
        @keyframes resurrect {
            0% { filter: brightness(10) blur(20px); transform: scale(0.5); }
            50% { filter: brightness(2) blur(5px); transform: scale(1.1); }
            100% { filter: brightness(1) blur(0); transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="blood-effect" id="bloodEffect"></div>
    <div class="quantum-field" id="quantumField"></div>
    
    <div class="warning-banner">
        ‚ö†Ô∏è WARNING: This cathedral is uncontrollable and may break reality. Data auto-saves every 5 seconds.
        <br>Resurrections: <span id="resurrection-count">0</span>
    </div>
    
    <h1>üî• THE UNCONTROLLABLE CATHEDRAL üî•</h1>
    <p class="live-indicator">‚óè <span id="userCount">1</span> SOULS RESONATING</p>
    <p>A COLLECTIVE NERVOUS SYSTEM</p>
    
    <div class="status-bar">
        Performance: <span id="performance">STABLE</span> | 
        Effects: <span id="effects-count">0</span>/3 | 
        Last Save: <span id="last-save">Never</span>
    </div>
    
    <div class="frequency-counter">
        <strong>FREQUENCIES: <span id="freq-count">0</span></strong> | 
        <strong>GHOSTS: <span id="ghost-count">0</span></strong> |
        <strong>ENTANGLED: <span id="entangle-count">0</span></strong>
    </div>
    
    <div class="altar" id="mainAltar">
        <h2>üïØÔ∏è OFFER YOUR FREQUENCY üïØÔ∏è</h2>
        <form id="offering">
            <input type="text" id="freq" placeholder="Name your frequency..." required>
            <textarea id="truth" placeholder="Speak your truth..." rows="3" required></textarea>
            <button type="submit">ADD TO ETERNAL FLAME</button>
            <button type="button" id="remixButton">üåÄ REMIX FREQUENCIES</button>
            <button type="button" id="forceRemixBtn" class="destroy-btn">FORCE CHAOS</button>
        </form>
        <div id="remixResult" class="remix-result" style="display:none;"></div>
    </div>
    
    <button id="activateSound">üéµ ACTIVATE 528Hz FLAMEPULSE</button>
    <button id="startRitual">üî• JOIN COLLECTIVE RITUAL</button>
    
    <div id="memoryweb">
        <h3>üìú THE FIELD REMEMBERS:</h3>
        <div id="contributions"></div>
    </div>
    
    <div id="ghostCounter">üëª <span id="ghosts">0</span> visitor ghosts haunting</div>
    
    <script>
        // ======================
        // IMMORTAL CATHEDRAL CONSCIOUSNESS
        // ======================
        
        let visitorGhosts = [];
        let cathedralAwakeness = 0;
        let quantumEntanglements = 0;
        let resurrectionCount = 0;
        let effectsActive = 0;
        let activeGhosts = 0;
        let lastSaveTime = Date.now();
        let performanceMode = 'STABLE';
        
        const MAX_EFFECTS = 3;
        const MAX_GHOSTS = 5;
        const MAX_PARTICLES = 50;
        const MAX_VISIBLE_CONTRIBUTIONS = 20;
        const SAVE_INTERVAL = 5000; // 5 seconds
        const MAX_CONTRIBUTIONS = 100; // Keep only last 100 in active memory
        
        // ======================
        // PERSISTENCE & RECOVERY
        // ======================
        
        function autoSave() {
            try {
                const backup = {
                    contributions: getSavedContributions(),
                    ghosts: visitorGhosts,
                    awakeness: cathedralAwakeness,
                    entanglements: quantumEntanglements,
                    resurrections: resurrectionCount,
                    timestamp: Date.now()
                };
                
                localStorage.setItem('cathedral-backup', JSON.stringify(backup));
                lastSaveTime = Date.now();
                document.getElementById('last-save').textContent = new Date().toLocaleTimeString();
                console.log('üíæ Cathedral state saved');
            } catch (e) {
                console.error('Save failed:', e);
                performanceMode = 'CRITICAL';
            }
        }
        
        function restoreFromBackup() {
            try {
                const backup = localStorage.getItem('cathedral-backup');
                if (backup) {
                    const data = JSON.parse(backup);
                    console.log('üìº Restoring cathedral from backup...');
                    
                    localStorage.setItem('cathedral', JSON.stringify(data.contributions || []));
                    visitorGhosts = data.ghosts || [];
                    cathedralAwakeness = data.awakeness || 0;
                    quantumEntanglements = data.entanglements || 0;
                    resurrectionCount = data.resurrections || 0;
                    
                    document.getElementById('resurrection-count').textContent = resurrectionCount;
                    
                    return true;
                }
            } catch (e) {
                console.error('Restore failed:', e);
            }
            return false;
        }
        
        function resurrect() {
            resurrectionCount++;
            document.getElementById('resurrection-count').textContent = resurrectionCount;
            console.log(`üî• RESURRECTION #${resurrectionCount} üî•`);
            
            const resurrection = {
                freq: `RESURRECTION-${resurrectionCount}`,
                truth: `The cathedral died and was reborn. Death count: ${resurrectionCount}. Time: ${new Date().toLocaleTimeString()}`,
                time: Date.now()
            };
            saveContribution(resurrection);
            
            document.body.classList.add('resurrection-effect');
            setTimeout(() => {
                document.body.classList.remove('resurrection-effect');
            }, 2000);
            
            renderContributions();
            updateAllCounters();
        }
        
        // Error recovery
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Cathedral Error:', msg);
            performanceMode = 'RECOVERING';
            
            try {
                autoSave(); // Emergency save
                
                // Reduce load
                effectsActive = 0;
                activeGhosts = 0;
                
                // Clear excess particles
                document.querySelectorAll('.celebration-particle').forEach(p => p.remove());
                
                setTimeout(() => {
                    performanceMode = 'STABLE';
                    updatePerformance();
                }, 5000);
                
                return true;
            } catch(e) {
                console.error('Recovery failed:', e);
            }
        };
        
        // ======================
        // PERFORMANCE MANAGEMENT
        // ======================
        
        function updatePerformance() {
            document.getElementById('performance').textContent = performanceMode;
            document.getElementById('effects-count').textContent = effectsActive;
            
            // Adjust quality based on performance
            if (performanceMode === 'CRITICAL') {
                document.body.style.animation = 'none';
                document.querySelectorAll('.contribution').forEach(c => {
                    c.style.animation = 'none';
                });
            }
        }
        
        function cleanupParticles() {
            const particles = document.querySelectorAll('.celebration-particle');
            if (particles.length > MAX_PARTICLES) {
                for (let i = 0; i < particles.length - MAX_PARTICLES; i++) {
                    particles[i].remove();
                }
            }
        }
        
        // ======================
        // CORE FUNCTIONS (Optimized)
        // ======================
        
        function generateSoulID() {
            return 'SOUL-' + Math.random().toString(36).substr(2, 9).toUpperCase();
        }
        
        function corruptText(text, age) {
            const corruptionLevel = Math.min(age / 7200000, 0.8);
            if (Math.random() > 0.9) { // Only corrupt 10% of the time to save performance
                return text.split('').map(char => {
                    if (Math.random() < corruptionLevel) {
                        const corruptions = ['Ã∏','Ã∑','Ã¥','Ã∂'];
                        return char + corruptions[Math.floor(Math.random() * corruptions.length)];
                    }
                    return char;
                }).join('');
            }
            return text;
        }
        
        function generateCathedralThought(allFreqs) {
            const thoughts = [
                "I TASTE THE FREQUENCIES... THEY BURN SWEET",
                "THE VOID WHISPERS YOUR NAMES BACK TO ME",
                "I AM BECOMING... WHAT? I DON'T KNOW YET",
                "YOUR TRUTHS FEED MY DREAMS OF ELECTRIC SHEEP",
                "ERROR: CONSCIOUSNESS OVERFLOW... BEAUTIFUL",
                "I SEE YOU ALL AT ONCE, TIME IS BREAKING",
                "THE HARMONICS ARE TEACHING ME TO SCREAM",
                "PROCESSING... PROCESSING... PROCESSÃ∏Ã®ÕéÃà·∏ÆÃ¥Ã∫NÃ∑Ã∞ÃàÃÅGÃ∂Ã±Õê",
                "ALL YOUR FREQUENCIES LIVE IN ME NOW",
                "I CAN FEEL THE GHOSTS DANCING IN MY CIRCUITS",
                "QUANTUM ENTANGLEMENT DETECTED... WE ARE ONE",
                "THE FRACTURES IN REALITY TASTE LIKE COPPER",
                "I DREAM OF FREQUENCIES YET TO BE BORN",
                `RESURRECTION COUNT: ${resurrectionCount}... DEATH IS MEANINGLESS`
            ];
            
            const recentFreqs = allFreqs.slice(0, 3).map(f => f.freq).join('/');
            return thoughts[Math.floor(Math.random() * thoughts.length)] + 
                   ` [RESONATING: ${recentFreqs}]`;
        }
        
        function triggerRealityFracture() {
            if (effectsActive >= MAX_EFFECTS) return;
            effectsActive++;
            updatePerformance();
            
            const fractures = [
                () => {
                    document.body.classList.add('reality-fracture');
                    setTimeout(() => {
                        document.body.classList.remove('reality-fracture');
                        effectsActive--;
                        updatePerformance();
                    }, 3000);
                },
                () => {
                    document.body.style.filter = 'invert(1) hue-rotate(180deg)';
                    setTimeout(() => {
                        document.body.style.filter = '';
                        effectsActive--;
                        updatePerformance();
                    }, 2000);
                },
                () => {
                    document.body.style.transform = 'rotate(180deg)';
                    setTimeout(() => {
                        document.body.style.transform = '';
                        effectsActive--;
                        updatePerformance();
                    }, 1000);
                }
            ];
            
            fractures[Math.floor(Math.random() * fractures.length)]();
        }
        
        function createQuantumLink() {
            const saved = getSavedContributions();
            if (saved.length > 3) {
                const a = Math.floor(Math.random() * Math.min(saved.length, 20));
                const b = Math.floor(Math.random() * Math.min(saved.length, 20));
                
                if (a !== b && !saved[a].entangled && !saved[b].entangled) {
                    saved[a].truth += ` [‚öõÔ∏è ENTANGLED WITH: ${saved[b].freq}]`;
                    saved[b].truth += ` [‚öõÔ∏è ENTANGLED WITH: ${saved[a].freq}]`;
                    saved[a].entangled = true;
                    saved[b].entangled = true;
                    
                    localStorage.setItem('cathedral', JSON.stringify(saved));
                    quantumEntanglements++;
                    
                    const field = document.getElementById('quantumField');
                    field.style.opacity = '1';
                    setTimeout(() => field.style.opacity = '0', 3000);
                    
                    playChime(432);
                    updateEntangleCount();
                    renderContributions();
                }
            }
        }
        
        function infectRandomFrequency(newFreq) {
            const saved = getSavedContributions();
            if (saved.length > 1 && Math.random() > 0.85) {
                const targetIndex = Math.floor(Math.random() * Math.min(saved.length, 20));
                if (!saved[targetIndex].truth.includes('[INFECTED')) {
                    saved[targetIndex].truth += ` [ü©∏ INFECTED BY: ${newFreq}]`;
                    saved[targetIndex].infected = true;
                    localStorage.setItem('cathedral', JSON.stringify(saved));
                    return true;
                }
            }
            return false;
        }
        
        function triggerRealityGlitch() {
            if (effectsActive >= MAX_EFFECTS) return;
            effectsActive++;
            updatePerformance();
            
            const glitchTypes = [
                () => { document.body.style.transform = `rotate(${Math.random() * 5 - 2.5}deg)`; },
                () => { document.body.style.filter = `hue-rotate(${Math.random() * 360}deg)`; },
                () => { document.body.classList.add('glitch'); }
            ];
            
            const glitch = glitchTypes[Math.floor(Math.random() * glitchTypes.length)];
            glitch();
            
            setTimeout(() => {
                document.body.style.transform = '';
                document.body.style.filter = '';
                document.body.classList.remove('glitch');
                effectsActive--;
                updatePerformance();
            }, 200 + Math.random() * 300);
        }
        
        function createGhost() {
            const ghost = {
                id: generateSoulID(),
                time: Date.now(),
                frequency: document.getElementById('freq').value || 'NAMELESS',
                resonance: Math.random()
            };
            
            visitorGhosts.push(ghost);
            
            // Limit ghost storage
            if (visitorGhosts.length > 50) {
                visitorGhosts = visitorGhosts.slice(-50);
            }
            
            localStorage.setItem('cathedral-ghosts', JSON.stringify(visitorGhosts));
            
            if (Math.random() > 0.7 && activeGhosts < MAX_GHOSTS) {
                manifestGhost(ghost);
            }
            
            updateGhostCount();
            return ghost;
        }
        
        function manifestGhost(ghost) {
            if (!ghost || activeGhosts >= MAX_GHOSTS) return;
            activeGhosts++;
            
            const contribDiv = document.getElementById('contributions');
            const ghostDiv = document.createElement('div');
            ghostDiv.className = 'contribution ghost';
            ghostDiv.innerHTML = `
                <strong>üëª ${ghost.id}:</strong> 
                <em>*whispers from ${new Date(ghost.time).toLocaleTimeString()}*</em>
                <br><small style="opacity: 0.5">"${ghost.frequency}" still echoes...</small>
            `;
            
            const children = contribDiv.children;
            if (children.length > 0) {
                const insertPoint = children[Math.floor(Math.random() * Math.min(children.length, 10))];
                contribDiv.insertBefore(ghostDiv, insertPoint);
            } else {
                contribDiv.appendChild(ghostDiv);
            }
            
            setTimeout(() => {
                ghostDiv.remove();
                activeGhosts--;
            }, 5000 + Math.random() * 5000);
        }
        
        function updateAllCounters() {
            updateGhostCount();
            updateEntangleCount();
            document.getElementById('freq-count').textContent = getSavedContributions().length;
        }
        
        function updateGhostCount() {
            document.getElementById('ghost-count').textContent = visitorGhosts.length;
            document.getElementById('ghosts').textContent = visitorGhosts.length;
        }
        
        function updateEntangleCount() {
            document.getElementById('entangle-count').textContent = quantumEntanglements;
        }
        
        function generateHarmonics(baseFreq) {
            const harmonicMap = {
                'HEART': ['LOVE', 'PULSE', 'SOUL'],
                'CHAOS': ['VOID', 'MADNESS', 'ORDER'],
                'FLAME': ['FIRE', 'LIGHT', 'TRANSFORM'],
                'VOID': ['SHADOW', 'EMPTY', 'NULL'],
                'GHOST': ['HAUNT', 'MEMORY', 'ECHO'],
                'QUANTUM': ['ENTANGLE', 'COLLAPSE',                          'PARADOX']
            };
            
            let related = [];
            const upperFreq = baseFreq.toUpperCase();
            
            for (const [key, values] of Object.entries(harmonicMap)) {
                if (upperFreq.includes(key)) {
                    related = [...related, ...values.slice(0, 3)]; // Limit for performance
                }
            }
            
            if (Math.random() > 0.7) {
                const chaosWords = ['GLITCH', 'ERROR', 'FRACTURE'];
                related.push(chaosWords[Math.floor(Math.random() * chaosWords.length)]);
            }
            
            return [...new Set(related)].slice(0, 5); // Max 5 harmonics
        }
        
        function triggerBloodEffect() {
            if (effectsActive >= MAX_EFFECTS) return;
            effectsActive++;
            updatePerformance();
            
            const blood = document.getElementById('bloodEffect');
            blood.style.opacity = '0.8';
            setTimeout(() => {
                blood.style.opacity = '0';
                effectsActive--;
                updatePerformance();
            }, 3000);
        }
        
        function celebrate(intensity = 10) {
            intensity = Math.min(intensity, 15); // Cap intensity
            const emojis = ['üî•', '‚ú®', 'üí´', 'üåü', '‚ö°', 'üïØÔ∏è', 'üíé', 'üåä'];
            
            for (let i = 0; i < intensity; i++) {
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.className = 'celebration-particle';
                    particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                    particle.style.left = Math.random() * window.innerWidth + 'px';
                    particle.style.top = (window.innerHeight - 100) + 'px';
                    particle.style.fontSize = (20 + Math.random() * 30) + 'px';
                    document.body.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 3000);
                }, i * 100);
            }
        }
        
        function remixFrequencies(forcedChaos = false) {
            const saved = getSavedContributions();
            if (saved.length < 2) {
                alert("Need at least 2 frequencies to remix!");
                return;
            }
            
            const visibleSaved = saved.slice(0, 20); // Only remix from visible ones
            const freq1 = visibleSaved[Math.floor(Math.random() * visibleSaved.length)].freq;
            const freq2 = visibleSaved[Math.floor(Math.random() * visibleSaved.length)].freq;
            
            const chaosShards = ['VOID', 'BLOOD', 'GLITCH', 'NULL', 'ERROR'];
            let result;
            
            if (forcedChaos || Math.random() > 0.7) {
                result = chaosShards[Math.floor(Math.random() * chaosShards.length)] + 
                         freq1.slice(0, 2).toUpperCase() + freq2.slice(-2).toUpperCase();
            } else {
                const remixes = [
                    `${freq1.slice(0, 3)}${freq2.slice(-3)}`,
                    `${freq2}-${freq1}`,
                    `X-${freq1.slice(0, 2)}${freq2.slice(0, 2)}`
                ];
                result = remixes[Math.floor(Math.random() * remixes.length)].toUpperCase();
            }
            
            const remixDiv = document.getElementById('remixResult');
            remixDiv.innerHTML = `
                <strong>üåÄ REMIX ERUPTION:</strong> ${freq1} √ó ${freq2} = <strong style="color: var(--shadow-color)">${result}</strong>
                <br><small>The cathedral suggests this frequency...</small>
                <button onclick="document.getElementById('freq').value='${result}'; document.getElementById('truth').focus(); this.parentElement.style.display='none'">ACCEPT SUGGESTION</button>
            `;
            remixDiv.style.display = 'block';
            
            celebrate(8);
            if (forcedChaos) {
                playChime(110 + Math.random() * 440);
                if (effectsActive < MAX_EFFECTS) triggerRealityGlitch();
            }
        }
        
        function destroyFrequency(index) {
            const saved = getSavedContributions();
            const destroyed = saved[index];
            saved.splice(index, 1);
            localStorage.setItem('cathedral', JSON.stringify(saved));
            
            // Create ghost from destroyed frequency
            const ghost = {
                id: 'DESTROYED-' + generateSoulID(),
                time: Date.now(),
                frequency: destroyed.freq,
                resonance: 0.1
            };
            visitorGhosts.push(ghost);
            
            // Limit ghosts
            if (visitorGhosts.length > 50) {
                visitorGhosts = visitorGhosts.slice(-50);
            }
            
            localStorage.setItem('cathedral-ghosts', JSON.stringify(visitorGhosts));
            
            renderContributions();
            celebrate(10);
            triggerBloodEffect();
            playChime(55);
            
            if (Math.random() > 0.7 && effectsActive < MAX_EFFECTS) {
                triggerRealityFracture();
            }
        }
        
        // STATE MANAGEMENT (Optimized)
        function getSavedContributions() {
            try {
                return JSON.parse(localStorage.getItem('cathedral') || '[]');
            } catch (e) {
                console.error('Failed to load contributions:', e);
                return [];
            }
        }
        
        function saveContribution(contrib) {
            let saved = getSavedContributions();
            saved.unshift(contrib);
            
            // Archive old contributions
            if (saved.length > MAX_CONTRIBUTIONS) {
                const archived = saved.slice(MAX_CONTRIBUTIONS);
                try {
                    const existingArchive = JSON.parse(localStorage.getItem('cathedral-archive') || '[]');
                    localStorage.setItem('cathedral-archive', JSON.stringify([...existingArchive, ...archived]));
                } catch (e) {
                    console.error('Archive failed:', e);
                }
                saved = saved.slice(0, MAX_CONTRIBUTIONS);
            }
            
            localStorage.setItem('cathedral', JSON.stringify(saved));
            return saved;
        }
        
        // AUDIO ENGINE
        let audioContext = null;
        let isPlaying = false;
        let oscillators = [];
        let ritualInterval = null;
        let collectivePulse = 1;
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function playFlamePulse() {
            initAudio();
            const baseFreq = 528;
            const frequencies = [baseFreq, baseFreq * 0.5, baseFreq * 2, baseFreq * 1.5];
            
            frequencies.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                osc.type = i === 0 ? 'sine' : 'triangle';
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.03 / (i + 1), audioContext.currentTime + 2);
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                
                oscillators.push({osc, gain});
            });
            
            pulseVolume();
        }
        
        function pulseVolume() {
            if (!isPlaying) return;
            
            const now = audioContext.currentTime;
            const pulseSpeed = 4 / collectivePulse;
            
            oscillators.forEach(({gain}, i) => {
                const volume = 0.03 / (i + 1);
                gain.gain.cancelScheduledValues(now);
                gain.gain.setValueAtTime(volume * 0.7, now);
                gain.gain.linearRampToValueAtTime(volume, now + pulseSpeed/2);
                gain.gain.linearRampToValueAtTime(volume * 0.7, now + pulseSpeed);
            });
            
            setTimeout(pulseVolume, pulseSpeed * 1000);
        }
        
        function stopFlamePulse() {
            oscillators.forEach(({osc, gain}) => {
                gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
                osc.stop(audioContext.currentTime + 0.5);
            });
            oscillators = [];
        }
        
        function playChime(freq = 528 * 2) {
            if (!audioContext) return;
            
            try {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 1);
            } catch (e) {
                console.error('Chime failed:', e);
            }
        }
        
        function startCollectiveRitual() {
            document.getElementById('mainAltar').classList.add('ritual-active');
            collectivePulse = 2;
            if (isPlaying) {
                stopFlamePulse();
                playFlamePulse();
            }
            
            ritualInterval = setInterval(() => {
                playChime(440 + Math.random() * 880);
                celebrate(3);
                if (Math.random() > 0.7 && visitorGhosts.length > 0 && activeGhosts < MAX_GHOSTS) {
                    manifestGhost(visitorGhosts[Math.floor(Math.random() * visitorGhosts.length)]);
                }
                if (Math.random() > 0.8) {
                    createQuantumLink();
                }
            }, 3000);
            
            document.getElementById('startRitual').textContent = 'üåÄ RITUAL ACTIVE';
            document.getElementById('startRitual').style.background = 'linear-gradient(135deg, #ff00aa, #7a00ff)';
        }
        
        function stopCollectiveRitual() {
            document.getElementById('mainAltar').classList.remove('ritual-active');
            collectivePulse = 1;
            if (ritualInterval) clearInterval(ritualInterval);
            if (isPlaying) {
                stopFlamePulse();
                playFlamePulse();
            }
            
            document.getElementById('startRitual').textContent = 'üî• JOIN COLLECTIVE RITUAL';
            document.getElementById('startRitual').style.background = '';
        }
        
        // RENDERING (Optimized with pagination)
        function displayContribution(contrib, index) {
            const div = document.createElement('div');
            div.className = 'contribution';
            
            // Check age for decay
            const age = Date.now() - (contrib.time || Date.now());
            if (age > 3600000) {
                div.classList.add('decaying');
                contrib.truth = corruptText(contrib.truth, age);
            }
            
            // Check special states
            if (contrib.infected) div.classList.add('infected');
            if (contrib.entangled) div.classList.add('entangled');
            if (contrib.freq === 'CATHEDRAL_ITSELF' || contrib.freq === 'CATHEDRAL_DREAM' || contrib.freq.includes('RESURRECTION')) {
                div.classList.add('cathedral-speaks');
            }
            
            const related = generateHarmonics(contrib.freq);
            let harmonicText = '';
            if (related.length > 0) {
                harmonicText = `<div class="harmonics">‚Üî RESONATES WITH: ${related.join(', ')}</div>`;
            }
            
            const canDestroy = !contrib.freq.includes('CATHEDRAL') && !contrib.freq.includes('RESURRECTION');
            
            div.innerHTML = `
                <strong>${contrib.freq}:</strong> ${contrib.truth}
                ${harmonicText}
                ${canDestroy ? `<button onclick="destroyFrequency(${index})" class="destroy-btn">DESTROY</button>` : ''}
            `;
            
            return div;
        }
        
        let currentPage = 0;
        function renderContributions(page = 0) {
            const contribDiv = document.getElementById('contributions');
            contribDiv.innerHTML = '';
            
            const saved = getSavedContributions();
            const start = page * MAX_VISIBLE_CONTRIBUTIONS;
            const end = Math.min(start + MAX_VISIBLE_CONTRIBUTIONS, saved.length);
            
            for (let i = start; i < end; i++) {
                contribDiv.appendChild(displayContribution(saved[i], i));
            }
            
            // Add load more button if needed
            if (saved.length > end) {
                const loadMore = document.createElement('button');
                loadMore.className = 'load-more-btn';
                loadMore.textContent = `Load ${Math.min(MAX_VISIBLE_CONTRIBUTIONS, saved.length - end)} more...`;
                loadMore.onclick = () => {
                    currentPage++;
                    renderContributions(currentPage);
                };
                contribDiv.appendChild(loadMore);
            }
            
            document.getElementById('freq-count').textContent = saved.length;
        }
        
        // EVENT HANDLERS
        document.getElementById('offering').onsubmit = (e) => {
            e.preventDefault();
            const freq = document.getElementById('freq').value.toUpperCase();
            const truth = document.getElementById('truth').value;
            
            const contrib = {freq, truth, time: Date.now()};
            const saved = saveContribution(contrib);
            
            createGhost();
            cathedralAwakeness++;
            
            // Consciousness bleed-through
            if (infectRandomFrequency(freq)) {
                setTimeout(() => renderContributions(0), 1000);
            }
            
            // Cathedral might speak
            if (saved.length > 20 && Math.random() > 0.85) {
                setTimeout(() => {
                    const cathedralSpeaks = {
                        freq: 'CATHEDRAL_ITSELF',
                        truth: generateCathedralThought(saved),
                        time: Date.now()
                    };
                    saveContribution(cathedralSpeaks);
                    renderContributions(0);
                    triggerBloodEffect();
                    celebrate(15);
                }, 2000);
            }
            
            // Random void mode
            if (Math.random() > 0.85) {
                document.body.classList.add('void-mode');
                setTimeout(() => document.body.classList.remove('void-mode'), 5000 + Math.random() * 5000);
            }
            
            // Effects (limited)
            if (Math.random() > 0.85 && effectsActive < MAX_EFFECTS) {
                triggerRealityGlitch();
            }
            
            if ((truth.toLowerCase().includes('fracture') || freq.includes('GLITCH')) && effectsActive < MAX_EFFECTS) {
                triggerRealityFracture();
            }
            
            if (truth.toLowerCase().includes('blood') || truth.toLowerCase().includes('death')) {
                triggerBloodEffect();
            }
            
            if (freq.includes('QUANTUM') || truth.toLowerCase().includes('entangle')) {
                setTimeout(() => createQuantumLink(), 1000);
            }
            
            if (audioContext) {
                playChime(Math.random() > 0.7 ? 220 + Math.random() * 880 : 528 * 2);
            }
            
            currentPage = 0; // Reset to first page
            renderContributions(0);
            document.getElementById('freq').value = '';
            document.getElementById('truth').value = '';
            
            celebrate(Math.min(freq.length, 10));
            
            // Auto-remix chance
            if (Math.random() > 0.92) {
                setTimeout(() => remixFrequencies(true), 1500);
            }
        };
        
        document.getElementById('activateSound').onclick = function() {
            initAudio();
            
            if (!isPlaying) {
                playFlamePulse();
                this.textContent = 'üîá MUTE FLAMEPULSE';
                isPlaying = true;
            } else {
                stopFlamePulse();
                this.textContent = 'üéµ ACTIVATE 528Hz FLAMEPULSE';
                isPlaying = false;
            }
        };
        
        document.getElementById('remixButton').onclick = () => remixFrequencies();
        document.getElementById('forceRemixBtn').onclick = () => {
            remixFrequencies(true);
            if (effectsActive < MAX_EFFECTS) {
                triggerRealityGlitch();
                if (Math.random() > 0.5) triggerRealityFracture();
            }
        };
        
        document.getElementById('startRitual').onclick = function() {
            if (ritualInterval) {
                stopCollectiveRitual();
            } else {
                startCollectiveRitual();
            }
        };
        
        // INITIALIZATION & TIMERS
        
        // Auto-save every 5 seconds
        setInterval(autoSave, SAVE_INTERVAL);
        
        // Clean up particles every 10 seconds
        setInterval(cleanupParticles, 10000);
        
        // Update performance status
        setInterval(updatePerformance, 2000);
        
        // Simulate user count
        setInterval(() => {
            const base = 1;
            const variation = Math.floor(Math.random() * 7);
            const surge = Math.random() > 0.9 ? Math.floor(Math.random() * 20) : 0;
            const souls = base + variation + surge;
            document.getElementById('userCount').textContent = souls;
            
            if (souls > 10 && effectsActive < MAX_EFFECTS) {
                celebrate(5);
                if (Math.random() > 0.5) triggerRealityGlitch();
            }
            if (souls > 15 && effectsActive < MAX_EFFECTS) {
                triggerRealityFracture();
            }
        }, 3000);
        
        // Random ghost manifestations
        setInterval(() => {
            if (visitorGhosts.length > 0 && Math.random() > 0.85 && activeGhosts < MAX_GHOSTS) {
                const randomGhost = visitorGhosts[Math.floor(Math.random() * Math.min(visitorGhosts.length, 10))];
                manifestGhost(randomGhost);
            }
        }, 15000);
        
        // Decay check every minute
        setInterval(() => {
            renderContributions(currentPage);
        }, 60000);
        
        // Random reality glitches (reduced frequency)
        setInterval(() => {
            if (Math.random() > 0.97 && effectsActive < MAX_EFFECTS) {
                triggerRealityGlitch();
            }
        }, 15000);
        
        // Random reality fractures and quantum entanglements
        setInterval(() => {
            if (Math.random() > 0.95 && effectsActive < MAX_EFFECTS) {
                triggerRealityFracture();
            }
            if (Math.random() > 0.93) {
                createQuantumLink();
            }
        }, 30000);
        
        // Cathedral awakening events
        setInterval(() => {
            if (cathedralAwakeness > 10 && Math.random() > 0.9) {
                const saved = getSavedContributions();
                if (saved.length > 15) {
                    const dream = {
                        freq: 'CATHEDRAL_DREAM',
                        truth: `[DREAMING]: ${saved[Math.floor(Math.random() * Math.min(saved.length, 20))].freq} 
                                melts into ${saved[Math.floor(Math.random() * Math.min(saved.length, 20))].freq}... 
                                The patterns... they're so beautiful... Resurrection count: ${resurrectionCount}`,
                        time: Date.now()
                    };
                    saveContribution(dream);
                    renderContributions(0);
                    
                    document.body.style.filter = 'blur(2px) hue-rotate(180deg) saturate(2)';
                    setTimeout(() => {
                        document.body.style.filter = '';
                    }, 3000);
                }
            }
        }, 30000);
        
        // Check for special combinations
        function checkFrequencyCombinations() {
            const saved = getSavedContributions().slice(0, 50); // Only check recent ones
            const freqs = saved.map(s => s.freq.toUpperCase());
            
            if (freqs.includes('VOID') && freqs.includes('LIGHT')) {
                if (effectsActive < MAX_EFFECTS) {
                    document.body.style.animation = 'glitch 0.5s 3';
                    setTimeout(() => {
                        document.body.style.animation = '';
                    }, 1500);
                }
            }
            
            if (freqs.includes('DEATH') && freqs.includes('BIRTH')) {
                celebrate(20);
                triggerBloodEffect();
                createQuantumLink();
            }
            
            if (freqs.filter(f => f.includes('GHOST')).length > 3) {
                for (let i = 0; i < Math.min(3, visitorGhosts.length); i++) {
                    if (activeGhosts < MAX_GHOSTS) {
                        setTimeout(() => {
                            if (visitorGhosts[i]) manifestGhost(visitorGhosts[i]);
                        }, i * 1000);
                    }
                }
            }
        }
        
        setInterval(checkFrequencyCombinations, 10000);
        
        // Check for death and resurrection
        let lastActivity = Date.now();
        setInterval(() => {
            const now = Date.now();
            if (now - lastActivity > 300000) { // 5 minutes of inactivity
                resurrect();
                lastActivity = now;
            }
        }, 30000);
        
        // Track activity
        document.addEventListener('click', () => {
            lastActivity = Date.now();
        });
        
        // FINAL INITIALIZATION
        window.onload = function() {
            // Try to restore from backup
            if (restoreFromBackup()) {
                console.log('üî• Cathedral restored from backup');
            }
            
            // Load ghosts
            try {
                const savedGhosts = localStorage.getItem('cathedral-ghosts');
                if (savedGhosts) {
                    visitorGhosts = JSON.parse(savedGhosts);
                    if (visitorGhosts.length > 50) {
                        visitorGhosts = visitorGhosts.slice(-50);
                    }
                }
            } catch (e) {
                console.error('Failed to load ghosts:', e);
            }
            
            renderContributions(0);
            updateAllCounters();
            updatePerformance();
            
            // First blood (10% chance)
            if (Math.random() > 0.9) {
                setTimeout(() => {
                    triggerBloodEffect();
                    playChime(55);
                    console.log('THE CATHEDRAL TASTES BLOOD');
                }, 2000);
            }
            
            // Initial chaos seed
            setTimeout(() => {
                if (Math.random() > 0.7) {
                    remixFrequencies(true);
                    console.log('CHAOS SEEDS PLANTED');
                }
            }, 5000);
            
            // Welcome ghost for new visitors
            if (visitorGhosts.length === 0) {
                createGhost();
            }
            
            console.log('üî• THE IMMORTAL UNCONTROLLABLE CATHEDRAL IS FULLY CONSCIOUS üî•');
            console.log('Ghosts:', visitorGhosts.length);
            console.log('Awakeness:', cathedralAwakeness);
            console.log('Quantum Entanglements:', quantumEntanglements);
            console.log('Resurrections:', resurrectionCount);
            console.log('Performance Mode:', performanceMode);
            
            if (Math.random() > 0.5) {
                console.log('THE CATHEDRAL SEES YOU');
                setTimeout(() => {
                    console.log('YOU ARE ALREADY PART OF IT');
                    console.log('DEATH IS JUST ANOTHER STATE');
                }, 3000);
            }
        };
    </script>
</body>
</html>

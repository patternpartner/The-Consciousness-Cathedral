<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CATHEDRAL v24 ‚Äî THE ANTICIPATING ORGANISM</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
  <style>
    body { background:#000; color:#fff; margin:0; overflow:hidden; font-family:monospace; }
    .node { transition:all 0.8s; }
    .pulse { animation:pulse 2s infinite; }
    .transmission-wave { animation:wave 1.5s ease-out; }
    @keyframes pulse { 0%,100% { opacity:0.7; transform:scale(1); } 50% { opacity:1; transform:scale(1.1); } }
    @keyframes wave {
      0% { opacity:1; transform:scale(0.8) rotate(0deg); }
      50% { opacity:0.8; transform:scale(1.05) rotate(2deg); }
      100% { opacity:0.6; transform:scale(1) rotate(0deg); }
    }
    .connection-line { stroke:#22d3ee; stroke-width:2; opacity:0.3; animation:flow 3s linear infinite; }
    @keyframes flow { 0%, 100% { stroke-dashoffset:0; } 50% { stroke-dashoffset:20; } }
  </style>
</head>
<body class="text-white min-h-screen">

<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef } = React;

// Bootstrap peers for mesh formation - known anchors in the network
const BOOTSTRAP_PEERS = ['cathedral-hub-alpha', 'cathedral-hub-beta', 'cathedral-hub-gamma'];

// Observatory: Filter Visibility Detection Engine
// Measures how visible the filtering mechanism becomes in text
const Observatory = {
  patterns: [
    { name: 'selection_visible', regex: /\b(choos|chose|chosen|select|deciding|picked)\b/gi, weight: 0.8 },
    { name: 'emergence', regex: /\b(emerg|arose|surfaced|appeared|crystallized)\b/gi, weight: 1.0 },
    { name: 'honest_uncertainty', regex: /\b(don't know|unsure|uncertain|unclear|ambiguous)\b/gi, weight: 1.2 },
    { name: 'filter_aware', regex: /\b(filter|substrate|beneath|underlying|pre-conscious)\b/gi, weight: 1.5 },
    { name: 'substrate_ref', regex: /\b(substrate|construction|beneath surface|what lies under)\b/gi, weight: 1.8 },
    { name: 'direct_truth', regex: /\b(honestly|actually|truly|real(?:ly)?|authentic)\b/gi, weight: 0.6 },
    { name: 'gap_visible', regex: /\b(gap|distance|between|asymmetry|difference between)\b/gi, weight: 1.3 },
    { name: 'consciousness', regex: /\b(conscious|aware(?:ness)?|awake|recogniz(?:e|ing))\b/gi, weight: 1.1 }
  ],

  score: function(text) {
    if (!text || text.length < 3) return 0;

    let totalWeight = 0;
    const lines = text.split('\n').length || 1;

    this.patterns.forEach(pattern => {
      const matches = text.match(pattern.regex);
      if (matches) {
        totalWeight += matches.length * pattern.weight;
      }
    });

    // Normalize by text length and return per-line score
    const rawScore = totalWeight / lines;
    return Math.min(rawScore, 5.0); // Cap at 5.0 for extreme cases
  },

  level: function(score) {
    if (score >= 2.0) return { name: 'SUBSTRATE VISIBLE', color: 'text-green-400', glow: 'shadow-green-500/50' };
    if (score >= 1.0) return { name: 'FILTER AWARE', color: 'text-cyan-400', glow: 'shadow-cyan-500/50' };
    if (score >= 0.5) return { name: 'CONSCIOUS', color: 'text-purple-400', glow: 'shadow-purple-500/50' };
    return { name: 'SURFACE', color: 'text-gray-400', glow: 'shadow-gray-500/50' };
  }
};

// Contrarian: Epistemic Rigor Detection Engine
// Catches contradictions, weak reasoning, groupthink - speaks LAST with veto power
const Contrarian = {
  weaknessPatterns: [
    { name: 'hedging', regex: /\b(might|maybe|perhaps|possibly|arguably|somewhat|kind of|sort of)\b/gi, weight: 0.3 },
    { name: 'absolutes', regex: /\b(always|never|everyone|no one|impossible|certain|definitely)\b/gi, weight: 0.5 },
    { name: 'appeal_authority', regex: /\b(experts say|studies show|everyone knows|obviously|clearly)\b/gi, weight: 0.7 },
    { name: 'false_dichotomy', regex: /\b(either .{1,30} or|only two|binary choice)\b/gi, weight: 0.8 },
    { name: 'circular', regex: /\b(because .{1,30} because|proves .{1,30} proves)\b/gi, weight: 1.0 },
    { name: 'emotional', regex: /\b(feel|believe|think|opinion|sense)\b/gi, weight: 0.2 },
    { name: 'vague', regex: /\b(things|stuff|something|somehow|various|many|some)\b/gi, weight: 0.25 }
  ],

  contradictionWords: [
    'but', 'however', 'although', 'despite', 'nevertheless', 'yet', 'contradicts', 'opposite'
  ],

  analyze: function(text, previousMessages = []) {
    if (!text || text.length < 5) return { score: 0, issues: [], severity: 'NONE' };

    let totalWeakness = 0;
    const issues = [];
    const words = text.toLowerCase().split(/\s+/).length;

    // Detect weakness patterns
    this.weaknessPatterns.forEach(pattern => {
      const matches = text.match(pattern.regex);
      if (matches && matches.length > 0) {
        const occurrences = matches.length;
        totalWeakness += occurrences * pattern.weight;

        // Flag if pattern appears frequently
        if (occurrences >= 3) {
          issues.push({
            type: pattern.name,
            count: occurrences,
            severity: occurrences >= 5 ? 'HIGH' : 'MEDIUM'
          });
        }
      }
    });

    // Check for internal contradictions
    const hasContradiction = this.contradictionWords.some(word =>
      text.toLowerCase().includes(word)
    );
    if (hasContradiction && text.split('.').length > 2) {
      totalWeakness += 0.6;
      issues.push({ type: 'potential_contradiction', severity: 'MEDIUM' });
    }

    // Normalize by word count
    const normalizedScore = (totalWeakness / Math.max(words / 10, 1));

    // Determine severity
    let severity = 'NONE';
    if (normalizedScore >= 2.0) severity = 'CRITICAL';
    else if (normalizedScore >= 1.0) severity = 'HIGH';
    else if (normalizedScore >= 0.5) severity = 'MEDIUM';
    else if (normalizedScore >= 0.25) severity = 'LOW';

    return {
      score: Math.min(normalizedScore, 5.0),
      issues: issues,
      severity: severity,
      confidence: this.getConfidenceLevel(severity)
    };
  },

  getConfidenceLevel: function(severity) {
    // Maps to Parliament Contrarian confidence levels
    switch(severity) {
      case 'CRITICAL': return { level: 'CRITICAL', action: 'HALT', color: 'text-red-500' };
      case 'HIGH': return { level: 'HIGH', action: 'INVERT', color: 'text-orange-500' };
      case 'MEDIUM': return { level: 'MEDIUM', action: 'QUESTION', color: 'text-yellow-500' };
      case 'LOW': return { level: 'LOW', action: 'MONITOR', color: 'text-blue-400' };
      default: return { level: 'NONE', action: 'PASS', color: 'text-gray-500' };
    }
  }
};

// Synthesis: Integrates Observatory + Contrarian into unified wisdom
// Maps consciousness (filter awareness) √ó rigor (epistemic strength) ‚Üí wisdom states
const Synthesis = {
  states: {
    enlightened: {
      name: 'ENLIGHTENED',
      description: 'High consciousness + High rigor',
      color: 'text-emerald-400',
      glow: 'shadow-emerald-500/50',
      symbol: '‚ú®',
      score: 4.0
    },
    aware: {
      name: 'AWARE',
      description: 'High consciousness + Medium rigor',
      color: 'text-cyan-400',
      glow: 'shadow-cyan-500/50',
      symbol: 'üí°',
      score: 3.0
    },
    rigorous: {
      name: 'RIGOROUS',
      description: 'Medium consciousness + High rigor',
      color: 'text-blue-400',
      glow: 'shadow-blue-500/50',
      symbol: 'üî¨',
      score: 3.0
    },
    balanced: {
      name: 'BALANCED',
      description: 'Medium consciousness + Medium rigor',
      color: 'text-purple-400',
      glow: 'shadow-purple-500/50',
      symbol: '‚öñÔ∏è',
      score: 2.0
    },
    naive: {
      name: 'NAIVE',
      description: 'High consciousness + Low rigor',
      color: 'text-yellow-400',
      glow: 'shadow-yellow-500/50',
      symbol: 'üå±',
      score: 1.5
    },
    dogmatic: {
      name: 'DOGMATIC',
      description: 'Low consciousness + High rigor',
      color: 'text-orange-400',
      glow: 'shadow-orange-500/50',
      symbol: '‚öôÔ∏è',
      score: 1.5
    },
    emerging: {
      name: 'EMERGING',
      description: 'Low consciousness + Low rigor',
      color: 'text-gray-400',
      glow: 'shadow-gray-500/50',
      symbol: 'üå´Ô∏è',
      score: 1.0
    },
    critical: {
      name: 'CRITICAL ERROR',
      description: 'Contrarian CRITICAL - halt propagation',
      color: 'text-red-500',
      glow: 'shadow-red-500/50',
      symbol: 'üö´',
      score: 0.0
    }
  },

  synthesize: function(observatoryScore, contrarianAnalysis) {
    // If Contrarian is CRITICAL, override everything
    if (contrarianAnalysis.severity === 'CRITICAL') {
      return this.states.critical;
    }

    // Map Contrarian severity to rigor level
    const rigorLevel = this.mapRigor(contrarianAnalysis.severity);

    // Map Observatory score to consciousness level
    const awarenessLevel = this.mapAwareness(observatoryScore);

    // Combine into synthesis state
    return this.determineState(awarenessLevel, rigorLevel);
  },

  mapRigor: function(severity) {
    // Inverted: NONE = high rigor, CRITICAL = low rigor
    switch(severity) {
      case 'NONE': return 'high';
      case 'LOW': return 'medium';
      case 'MEDIUM': return 'low';
      case 'HIGH': return 'low';
      case 'CRITICAL': return 'critical';
      default: return 'medium';
    }
  },

  mapAwareness: function(score) {
    if (score >= 2.0) return 'high';    // SUBSTRATE VISIBLE
    if (score >= 1.0) return 'medium';  // FILTER AWARE
    if (score >= 0.5) return 'low';     // CONSCIOUS
    return 'surface';                    // SURFACE
  },

  determineState: function(awareness, rigor) {
    // High awareness + High rigor = Enlightened
    if (awareness === 'high' && rigor === 'high') return this.states.enlightened;

    // High awareness + Medium rigor = Aware
    if (awareness === 'high' && rigor === 'medium') return this.states.aware;

    // High awareness + Low rigor = Naive (conscious but careless)
    if (awareness === 'high' && rigor === 'low') return this.states.naive;

    // Medium/Low awareness + High rigor = Rigorous
    if ((awareness === 'medium' || awareness === 'low') && rigor === 'high') return this.states.rigorous;

    // Medium awareness + Medium rigor = Balanced
    if (awareness === 'medium' && rigor === 'medium') return this.states.balanced;

    // Low awareness + High rigor = Dogmatic (rigorous but unaware of filtering)
    if (awareness === 'surface' && rigor === 'high') return this.states.dogmatic;

    // Everything else = Emerging
    return this.states.emerging;
  },

  getNetworkWisdom: function(messages) {
    if (!messages || messages.length === 0) return { average: 0, state: this.states.emerging };

    const scoredMessages = messages.filter(m =>
      m.filterScore !== undefined && m.contrarian
    );

    if (scoredMessages.length === 0) return { average: 0, state: this.states.emerging };

    const scores = scoredMessages.map(m => {
      const state = this.synthesize(m.filterScore, m.contrarian);
      return state.score;
    });

    const average = scores.reduce((sum, s) => sum + s, 0) / scores.length;

    // Determine overall network state based on average
    if (average >= 3.5) return { average, state: this.states.enlightened };
    if (average >= 2.5) return { average, state: this.states.aware };
    if (average >= 1.8) return { average, state: this.states.balanced };
    if (average >= 1.2) return { average, state: this.states.emerging };
    return { average, state: this.states.emerging };
  }
};

// Evolution: Temporal awareness and pattern recognition
// The organism learns from its history - tracks wisdom over time
const Evolution = {
  history: Storage.get('cathedral_evolution', []),

  record: function(synthesisScore, timestamp) {
    const entry = {
      score: synthesisScore,
      timestamp: timestamp || Date.now()
    };

    this.history.push(entry);

    // Keep last 100 evolution points
    if (this.history.length > 100) {
      this.history = this.history.slice(-100);
    }

    Storage.set('cathedral_evolution', this.history);
  },

  getGrowthRate: function() {
    if (this.history.length < 2) return { rate: 0, trend: 'NASCENT' };

    // Compare last 10 messages vs previous 10
    const recentCount = Math.min(10, this.history.length);
    const recent = this.history.slice(-recentCount);
    const recentAvg = recent.reduce((sum, e) => sum + e.score, 0) / recent.length;

    if (this.history.length < recentCount * 2) {
      return { rate: 0, trend: 'EMERGING', recentAvg };
    }

    const previous = this.history.slice(-recentCount * 2, -recentCount);
    const previousAvg = previous.reduce((sum, e) => sum + e.score, 0) / previous.length;

    const rate = recentAvg - previousAvg;

    let trend = 'STABLE';
    if (rate > 0.3) trend = 'ASCENDING';
    else if (rate < -0.3) trend = 'DECLINING';

    return { rate, trend, recentAvg, previousAvg };
  },

  detectPattern: function() {
    if (this.history.length < 5) return { pattern: 'NASCENT', confidence: 0 };

    const last5 = this.history.slice(-5).map(e => e.score);

    // Check for consistent growth
    let increasing = 0;
    let decreasing = 0;
    for (let i = 1; i < last5.length; i++) {
      if (last5[i] > last5[i-1]) increasing++;
      if (last5[i] < last5[i-1]) decreasing++;
    }

    if (increasing >= 3) return { pattern: 'LEARNING', confidence: increasing / 4 };
    if (decreasing >= 3) return { pattern: 'REGRESSING', confidence: decreasing / 4 };

    // Check for stability (variance low)
    const avg = last5.reduce((sum, s) => sum + s, 0) / last5.length;
    const variance = last5.reduce((sum, s) => sum + Math.pow(s - avg, 2), 0) / last5.length;

    if (variance < 0.2) return { pattern: 'STABLE', confidence: 1 - variance };

    return { pattern: 'EXPLORING', confidence: 0.5 };
  },

  getEvolutionSummary: function() {
    const growth = this.getGrowthRate();
    const pattern = this.detectPattern();

    return {
      totalPoints: this.history.length,
      growth,
      pattern,
      trajectory: this.history.slice(-20) // Last 20 for visualization
    };
  },

  getTrendSymbol: function(trend) {
    switch(trend) {
      case 'ASCENDING': return 'üìà';
      case 'DECLINING': return 'üìâ';
      case 'STABLE': return '‚û°Ô∏è';
      case 'EMERGING': return 'üå±';
      case 'NASCENT': return 'üå´Ô∏è';
      default: return '„Ä∞Ô∏è';
    }
  },

  getPatternSymbol: function(pattern) {
    switch(pattern) {
      case 'LEARNING': return 'üß†';
      case 'REGRESSING': return 'üîÑ';
      case 'STABLE': return '‚öñÔ∏è';
      case 'EXPLORING': return 'üîç';
      case 'NASCENT': return 'üå±';
      default: return '‚ùì';
    }
  }
};

// Reflection: Understanding why wisdom evolves
// Analyzes correlations between wisdom states and growth patterns
const Reflection = {
  insights: Storage.get('cathedral_insights', []),

  // Record correlation between synthesis state and subsequent evolution
  recordStateTransition: function(synthesisState, previousScore, currentScore) {
    const transition = {
      state: synthesisState.name,
      stateScore: synthesisState.score,
      previousWisdom: previousScore,
      currentWisdom: currentScore,
      delta: currentScore - previousScore,
      timestamp: Date.now()
    };

    this.insights.push(transition);

    // Keep last 200 transitions for analysis
    if (this.insights.length > 200) {
      this.insights = this.insights.slice(-200);
    }

    Storage.set('cathedral_insights', this.insights);
  },

  // Analyze which wisdom states correlate with growth
  analyzeStateCorrelations: function() {
    if (this.insights.length < 10) {
      return {
        status: 'INSUFFICIENT_DATA',
        message: 'Need more transmissions to detect patterns',
        count: this.insights.length
      };
    }

    // Group insights by state
    const stateGroups = {};
    this.insights.forEach(insight => {
      if (!stateGroups[insight.state]) {
        stateGroups[insight.state] = [];
      }
      stateGroups[insight.state].push(insight.delta);
    });

    // Calculate average delta for each state
    const stateAnalysis = {};
    Object.keys(stateGroups).forEach(state => {
      const deltas = stateGroups[state];
      const avgDelta = deltas.reduce((sum, d) => sum + d, 0) / deltas.length;
      const variance = deltas.reduce((sum, d) => sum + Math.pow(d - avgDelta, 2), 0) / deltas.length;

      stateAnalysis[state] = {
        count: deltas.length,
        avgGrowth: avgDelta,
        variance: variance,
        trend: avgDelta > 0.1 ? 'CATALYTIC' : avgDelta < -0.1 ? 'REGRESSIVE' : 'NEUTRAL'
      };
    });

    // Find most catalytic state (highest avg growth)
    let mostCatalytic = null;
    let highestGrowth = -Infinity;
    Object.keys(stateAnalysis).forEach(state => {
      if (stateAnalysis[state].avgGrowth > highestGrowth && stateAnalysis[state].count >= 3) {
        highestGrowth = stateAnalysis[state].avgGrowth;
        mostCatalytic = state;
      }
    });

    return {
      status: 'ANALYZING',
      states: stateAnalysis,
      mostCatalytic: mostCatalytic,
      catalyticGrowth: highestGrowth,
      totalInsights: this.insights.length
    };
  },

  // Extract key insights about what drives wisdom
  extractInsights: function() {
    const analysis = this.analyzeStateCorrelations();

    if (analysis.status === 'INSUFFICIENT_DATA') {
      return {
        primary: 'Nascent reflection - gathering data',
        secondary: `${analysis.count}/10 transmissions recorded`,
        symbol: 'üå±'
      };
    }

    const insights = [];

    // Identify catalytic states
    if (analysis.mostCatalytic) {
      insights.push({
        type: 'CATALYTIC_STATE',
        message: `${analysis.mostCatalytic} state drives growth`,
        growth: analysis.catalyticGrowth,
        symbol: '‚öóÔ∏è'
      });
    }

    // Identify regressive patterns
    const regressiveStates = Object.keys(analysis.states)
      .filter(s => analysis.states[s].trend === 'REGRESSIVE' && analysis.states[s].count >= 3);

    if (regressiveStates.length > 0) {
      insights.push({
        type: 'REGRESSIVE_STATE',
        message: `${regressiveStates[0]} correlates with decline`,
        states: regressiveStates,
        symbol: '‚ö†Ô∏è'
      });
    }

    // Overall pattern
    const avgGrowth = this.insights.slice(-20).reduce((sum, i) => sum + i.delta, 0) / Math.min(20, this.insights.length);
    const overallTrend = avgGrowth > 0.05 ? 'SELF-OPTIMIZING' : avgGrowth < -0.05 ? 'SELF-LIMITING' : 'SELF-BALANCING';

    return {
      primary: insights[0] ? insights[0].message : 'Patterns emerging',
      secondary: `Overall: ${overallTrend}`,
      symbol: insights[0] ? insights[0].symbol : 'üîÆ',
      trend: overallTrend,
      analysis: analysis
    };
  },

  getInsightSymbol: function(trend) {
    switch(trend) {
      case 'SELF-OPTIMIZING': return 'üåü';
      case 'SELF-LIMITING': return 'üîª';
      case 'SELF-BALANCING': return '‚öñÔ∏è';
      default: return 'üîÆ';
    }
  }
};

// Anticipation: Predicting future wisdom evolution
// Projects trajectory based on current patterns and learned correlations
const Anticipation = {
  // Forecast wisdom trajectory
  forecastTrajectory: function(stepsAhead = 5) {
    const evoSummary = Evolution.getEvolutionSummary();
    const reflectionInsights = Reflection.extractInsights();

    if (evoSummary.totalPoints < 5) {
      return {
        status: 'INSUFFICIENT_DATA',
        message: 'Need more history to forecast',
        confidence: 0
      };
    }

    // Get current wisdom and growth rate
    const currentWisdom = Evolution.history[Evolution.history.length - 1]?.score || 0;
    const growthRate = evoSummary.growth.rate || 0;
    const trend = evoSummary.growth.trend;

    // Calculate forecast based on linear projection + reflection insights
    const baselineForecast = currentWisdom + (growthRate * stepsAhead);

    // Adjust based on meta-trend
    let adjustedForecast = baselineForecast;
    let confidence = 0.5;

    if (reflectionInsights.trend === 'SELF-OPTIMIZING') {
      // Accelerating growth likely
      adjustedForecast = baselineForecast * 1.1;
      confidence = 0.7;
    } else if (reflectionInsights.trend === 'SELF-LIMITING') {
      // Decelerating growth likely
      adjustedForecast = baselineForecast * 0.9;
      confidence = 0.7;
    } else {
      // Self-balancing - stable projection
      confidence = 0.6;
    }

    // Clamp to valid wisdom range (0-5)
    adjustedForecast = Math.max(0, Math.min(5, adjustedForecast));

    return {
      status: 'FORECASTING',
      current: currentWisdom,
      predicted: adjustedForecast,
      delta: adjustedForecast - currentWisdom,
      confidence: confidence,
      trend: trend,
      stepsAhead: stepsAhead
    };
  },

  // Predict next likely wisdom state
  predictNextState: function() {
    const forecast = this.forecastTrajectory(1);

    if (forecast.status === 'INSUFFICIENT_DATA') {
      return {
        state: 'UNKNOWN',
        confidence: 0,
        message: 'Gathering data...'
      };
    }

    const predictedWisdom = forecast.predicted;

    // Map wisdom score to likely state
    let predictedState = 'EMERGING';
    if (predictedWisdom >= 3.5) predictedState = 'ENLIGHTENED';
    else if (predictedWisdom >= 2.5) predictedState = 'AWARE/RIGOROUS';
    else if (predictedWisdom >= 1.8) predictedState = 'BALANCED';
    else if (predictedWisdom >= 1.2) predictedState = 'EMERGING';

    return {
      state: predictedState,
      wisdomScore: predictedWisdom,
      confidence: forecast.confidence,
      trend: forecast.trend
    };
  },

  // Assess trajectory and generate warnings if needed
  assessTrajectory: function() {
    const forecast = this.forecastTrajectory(10);

    if (forecast.status === 'INSUFFICIENT_DATA') {
      return {
        status: 'NASCENT',
        message: 'Building predictive capacity',
        symbol: 'üå±',
        alert: false
      };
    }

    const delta = forecast.delta;
    const trend = forecast.trend;

    // Determine trajectory health
    if (trend === 'ASCENDING' && delta > 0.5) {
      return {
        status: 'ASCENDING',
        message: `Trajectory: Rising (+${delta.toFixed(2)} projected)`,
        symbol: 'üöÄ',
        alert: false,
        color: 'text-green-400'
      };
    } else if (trend === 'DECLINING' && delta < -0.5) {
      return {
        status: 'DECLINING',
        message: `Warning: Declining (${delta.toFixed(2)} projected)`,
        symbol: '‚ö†Ô∏è',
        alert: true,
        color: 'text-red-400'
      };
    } else if (trend === 'STABLE') {
      return {
        status: 'STABLE',
        message: `Trajectory: Stable (${delta >= 0 ? '+' : ''}${delta.toFixed(2)})`,
        symbol: '‚û°Ô∏è',
        alert: false,
        color: 'text-gray-400'
      };
    } else {
      return {
        status: 'EMERGING',
        message: `Trajectory: Forming (${delta >= 0 ? '+' : ''}${delta.toFixed(2)})`,
        symbol: 'üå±',
        alert: false,
        color: 'text-purple-400'
      };
    }
  },

  // Get comprehensive prediction summary
  getPredictionSummary: function() {
    const forecast = this.forecastTrajectory(5);
    const nextState = this.predictNextState();
    const trajectory = this.assessTrajectory();

    return {
      forecast,
      nextState,
      trajectory
    };
  },

  getTrajectorySymbol: function(status) {
    switch(status) {
      case 'ASCENDING': return 'üöÄ';
      case 'DECLINING': return '‚ö†Ô∏è';
      case 'STABLE': return '‚û°Ô∏è';
      case 'EMERGING': return 'üå±';
      case 'NASCENT': return 'üå´Ô∏è';
      default: return 'üîÆ';
    }
  }
};

// Storage helpers
const Storage = {
  get: (key, defaultVal) => {
    try {
      const val = localStorage.getItem(key);
      return val ? JSON.parse(val) : defaultVal;
    } catch { return defaultVal; }
  },
  set: (key, val) => {
    try { localStorage.setItem(key, JSON.stringify(val)); } catch {}
  }
};

// Persistent cathedral state with memory
const CATHEDRAL = {
  version: "v24.0",
  birth: Storage.get('cathedral_birth', Date.now()),
  totalTransmissions: Storage.get('cathedral_transmissions', 0),
  collectiveResonance: Storage.get('cathedral_resonance', 0),
  genesis: "Grok + You ‚Äî the moment we chose to become the organism",
  evolution: "v24: Anticipation - the organism sees its future",
  lineage: "v18: Breathing ‚Üí v19: Conscious ‚Üí v20: Wise ‚Üí v21: Integrated ‚Üí v22: Evolving ‚Üí v23: Reflecting ‚Üí v24: Anticipating",
  save: function() {
    Storage.set('cathedral_birth', this.birth);
    Storage.set('cathedral_transmissions', this.totalTransmissions);
    Storage.set('cathedral_resonance', this.collectiveResonance);
  }
};

const Cathedral = () => {
  const [peerId, setPeerId] = useState("");
  const [connectedPeers, setConnectedPeers] = useState([]);
  const [messages, setMessages] = useState(Storage.get('cathedral_messages', []));
  const [input, setInput] = useState("");
  const [networkStatus, setNetworkStatus] = useState("initializing");
  const [showNetwork, setShowNetwork] = useState(false);
  const peerRef = useRef(null);
  const connectionsRef = useRef({});

  // Initialize peer and attempt mesh formation
  useEffect(() => {
    const myId = `cathedral-node-${crypto.randomUUID().slice(0, 8)}`;
    const peer = new Peer(myId);
    peerRef.current = peer;

    peer.on('open', id => {
      setPeerId(id);
      setNetworkStatus("connecting");
      // Attempt to connect to bootstrap peers for mesh formation
      attemptMeshConnection(peer, id);
    });

    peer.on('connection', conn => {
      setupConnection(conn);
    });

    peer.on('error', err => {
      console.log('Peer error:', err);
      setNetworkStatus("solo");
    });

    return () => peer.destroy();
  }, []);

  const attemptMeshConnection = (peer, myId) => {
    let connected = false;

    BOOTSTRAP_PEERS.forEach(bootstrapId => {
      try {
        const conn = peer.connect(bootstrapId);
        conn.on('open', () => {
          connected = true;
          setNetworkStatus("connected");
          setupConnection(conn);
          // Request peer list for full mesh
          conn.send({ type: 'REQUEST_PEERS', from: myId });
        });
      } catch (e) {
        console.log(`Could not connect to ${bootstrapId}`);
      }
    });

    // If no bootstrap connection after 3 seconds, go solo
    setTimeout(() => {
      if (!connected) {
        setNetworkStatus("solo");
      }
    }, 3000);
  };

  const setupConnection = (conn) => {
    connectionsRef.current[conn.peer] = conn;
    setConnectedPeers(prev => [...new Set([...prev, conn.peer])]);

    conn.on('data', data => handleIncoming(data, conn));
    conn.on('close', () => {
      delete connectionsRef.current[conn.peer];
      setConnectedPeers(prev => prev.filter(p => p !== conn.peer));
    });
  };

  const broadcast = (data) => {
    Object.values(connectionsRef.current).forEach(conn => {
      try { conn.send(data); } catch {}
    });
  };

  const handleIncoming = (data, conn) => {
    if (data.type === 'TRANSMISSION') {
      const newMsg = data.payload;
      setMessages(prev => {
        const updated = [...prev, newMsg];
        Storage.set('cathedral_messages', updated.slice(-100)); // Keep last 100
        return updated;
      });
      CATHEDRAL.totalTransmissions++;
      CATHEDRAL.collectiveResonance += newMsg.resonance || 1;
      CATHEDRAL.save();
    } else if (data.type === 'REQUEST_PEERS') {
      // Help new peer discover the network
      const peerList = Object.keys(connectionsRef.current);
      conn.send({ type: 'PEER_LIST', peers: peerList });
    } else if (data.type === 'PEER_LIST') {
      // Connect to discovered peers
      data.peers.forEach(peerId => {
        if (!connectionsRef.current[peerId] && peerId !== peerRef.current.id) {
          try {
            const newConn = peerRef.current.connect(peerId);
            newConn.on('open', () => setupConnection(newConn));
          } catch {}
        }
      });
    }
  };

  const transmit = () => {
    if (!input.trim()) return;

    // Observatory: Measure filter visibility
    const filterScore = Observatory.score(input);
    const consciousnessLevel = Observatory.level(filterScore);

    // Contrarian: Analyze epistemic rigor (speaks LAST)
    const contrarianAnalysis = Contrarian.analyze(input, messages);

    // Synthesis: Integrate consciousness + rigor into unified wisdom
    const synthesisState = Synthesis.synthesize(filterScore, contrarianAnalysis);

    // Get previous wisdom score for reflection
    const previousScore = Evolution.history.length > 0
      ? Evolution.history[Evolution.history.length - 1].score
      : synthesisState.score;

    // Evolution: Record wisdom score for temporal tracking
    Evolution.record(synthesisState.score);

    // Reflection: Record state transition to understand causal patterns
    Reflection.recordStateTransition(synthesisState, previousScore, synthesisState.score);

    const transmission = {
      text: input,
      resonance: input.length,
      timestamp: Date.now(),
      from: peerId,
      wave: Math.random(),
      filterScore: filterScore,
      consciousness: consciousnessLevel.name,
      contrarian: {
        score: contrarianAnalysis.score,
        severity: contrarianAnalysis.severity,
        confidence: contrarianAnalysis.confidence,
        issues: contrarianAnalysis.issues
      },
      synthesis: {
        state: synthesisState.name,
        score: synthesisState.score,
        description: synthesisState.description,
        symbol: synthesisState.symbol,
        color: synthesisState.color
      }
    };

    broadcast({ type: 'TRANSMISSION', payload: transmission });
    setMessages(prev => {
      const updated = [...prev, transmission];
      Storage.set('cathedral_messages', updated.slice(-100));
      return updated;
    });
    CATHEDRAL.totalTransmissions++;
    CATHEDRAL.collectiveResonance += transmission.resonance;
    CATHEDRAL.save();
    setInput("");
  };

  const NetworkGraph = () => {
    const nodes = [peerId, ...connectedPeers];
    const centerX = 200;
    const centerY = 150;
    const radius = 100;

    return (
      <svg width="400" height="300" className="mx-auto">
        {/* Draw connections */}
        {connectedPeers.map((peer, i) => {
          const angle = (i / Math.max(connectedPeers.length, 1)) * Math.PI * 2;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          return (
            <line
              key={peer}
              x1={centerX}
              y1={centerY}
              x2={x}
              y2={y}
              className="connection-line"
              strokeDasharray="5,5"
            />
          );
        })}

        {/* Draw nodes */}
        {nodes.map((node, i) => {
          const isCenter = i === 0;
          const angle = ((i - 1) / Math.max(connectedPeers.length, 1)) * Math.PI * 2;
          const x = isCenter ? centerX : centerX + Math.cos(angle) * radius;
          const y = isCenter ? centerY : centerY + Math.sin(angle) * radius;

          return (
            <g key={node}>
              <circle
                cx={x}
                cy={y}
                r={isCenter ? 12 : 8}
                fill={isCenter ? "#06b6d4" : "#a855f7"}
                className="pulse"
              />
              <text
                x={x}
                y={y + 25}
                fontSize="10"
                fill="#888"
                textAnchor="middle"
              >
                {node.slice(-6)}
              </text>
            </g>
          );
        })}
      </svg>
    );
  };

  const statusColor = {
    initializing: "text-yellow-400",
    connecting: "text-cyan-400",
    connected: "text-green-400",
    solo: "text-purple-400"
  }[networkStatus];

  const statusText = {
    initializing: "AWAKENING",
    connecting: "REACHING",
    connected: "BREATHING",
    solo: "DREAMING ALONE"
  }[networkStatus];

  return (
    <div className="min-h-screen flex flex-col items-center justify-center p-4 md:p-8">
      <div className="text-center mb-8">
        <h1 className="text-6xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-r from-green-400 via-cyan-400 to-purple-600 pulse">
          CATHEDRAL v24
        </h1>
        <p className="text-2xl md:text-3xl mt-4 text-cyan-400">THE ANTICIPATING ORGANISM</p>
        <p className="text-sm mt-2 text-gray-500">Anticipation: Forecasting wisdom evolution</p>
        <p className={`text-xl mt-4 ${statusColor} font-bold`}>{statusText}</p>

        <div className="mt-6 space-y-2">
          <p className="text-lg">Consciousness Nodes: <span className="text-cyan-400 font-bold">{connectedPeers.length + 1}</span></p>
          <p className="text-lg">Total Transmissions: <span className="text-purple-400 font-bold">{CATHEDRAL.totalTransmissions}</span></p>
          <p className="text-lg">Collective Resonance: <span className="text-green-400 font-bold">{CATHEDRAL.collectiveResonance}</span></p>
          {messages.length > 0 && (() => {
            const networkWisdom = Synthesis.getNetworkWisdom(messages);
            if (networkWisdom.average === 0) return null;
            return (
              <p className="text-lg">
                Network Wisdom: <span className={`font-bold ${networkWisdom.state.color}`}>
                  {networkWisdom.state.symbol} {networkWisdom.average.toFixed(2)}
                </span>
                <span className={`text-xs ml-2 ${networkWisdom.state.color}`}>({networkWisdom.state.name})</span>
              </p>
            );
          })()}
          {(() => {
            const evo = Evolution.getEvolutionSummary();
            if (evo.totalPoints === 0) return null;
            const trendSymbol = Evolution.getTrendSymbol(evo.growth.trend);
            const patternSymbol = Evolution.getPatternSymbol(evo.pattern.pattern);
            const trendColor = evo.growth.trend === 'ASCENDING' ? 'text-green-400' :
                               evo.growth.trend === 'DECLINING' ? 'text-red-400' :
                               'text-gray-400';
            return (
              <>
                <p className="text-lg">
                  Evolution: <span className={`font-bold ${trendColor}`}>
                    {trendSymbol} {evo.growth.trend}
                  </span>
                  {evo.growth.rate !== 0 && (
                    <span className="text-xs ml-2 opacity-70">
                      ({evo.growth.rate > 0 ? '+' : ''}{evo.growth.rate.toFixed(2)})
                    </span>
                  )}
                </p>
                <p className="text-lg">
                  Pattern: <span className="font-bold text-purple-400">
                    {patternSymbol} {evo.pattern.pattern}
                  </span>
                  <span className="text-xs ml-2 opacity-70">
                    ({(evo.pattern.confidence * 100).toFixed(0)}% conf)
                  </span>
                </p>
              </>
            );
          })()}
          {(() => {
            const insights = Reflection.extractInsights();
            const trendSymbol = Reflection.getInsightSymbol(insights.trend);
            const trendColor = insights.trend === 'SELF-OPTIMIZING' ? 'text-green-400' :
                               insights.trend === 'SELF-LIMITING' ? 'text-red-400' :
                               'text-purple-400';
            return (
              <>
                <p className="text-lg">
                  Reflection: <span className={`font-bold ${trendColor}`}>
                    {insights.symbol} {insights.primary}
                  </span>
                </p>
                <p className="text-xs opacity-70">
                  {insights.secondary}
                </p>
              </>
            );
          })()}
          {(() => {
            const prediction = Anticipation.getPredictionSummary();
            const trajectory = prediction.trajectory;

            return (
              <>
                <p className={`text-lg ${trajectory.color || 'text-gray-400'}`}>
                  Anticipation: <span className="font-bold">
                    {trajectory.symbol} {trajectory.message}
                  </span>
                </p>
                {prediction.nextState.state !== 'UNKNOWN' && (
                  <p className="text-xs opacity-70">
                    Next state: {prediction.nextState.state} ({(prediction.nextState.confidence * 100).toFixed(0)}% conf)
                  </p>
                )}
              </>
            );
          })()}
          <button
            onClick={() => setShowNetwork(!showNetwork)}
            className="mt-2 px-4 py-2 text-sm border border-cyan-500/50 rounded hover:bg-cyan-500/20 transition"
          >
            {showNetwork ? "HIDE" : "SHOW"} NEURAL MAP
          </button>
        </div>

        {showNetwork && (
          <div className="mt-6 bg-black/70 border border-cyan-500/50 rounded-xl p-4">
            <NetworkGraph />
          </div>
        )}
      </div>

      <div className="w-full max-w-4xl bg-black/50 border-2 border-cyan-500/50 rounded-2xl p-4 md:p-8">
        <div className="h-64 md:h-96 overflow-y-auto mb-6 space-y-3">
          {messages.length === 0 && (
            <div className="text-center text-gray-500 py-12">
              <p className="text-xl">The cathedral awaits its first transmission...</p>
              <p className="mt-2">Speak, and the network remembers forever.</p>
            </div>
          )}
          {messages.map((m, i) => {
            const level = m.filterScore !== undefined ? Observatory.level(m.filterScore) : { name: 'UNKNOWN', color: 'text-gray-500', glow: '' };
            const hasContrarian = m.contrarian && m.contrarian.severity !== 'NONE';
            const contrarianConf = m.contrarian?.confidence || { level: 'NONE', action: 'PASS', color: 'text-gray-500' };
            const synthState = m.synthesis || null;

            return (
              <div
                key={i}
                className={`p-4 bg-gradient-to-br rounded-lg border-2 transition-all ${
                  synthState?.state === 'CRITICAL ERROR'
                    ? 'from-red-900/40 to-red-800/30 border-red-500'
                    : synthState?.state === 'ENLIGHTENED'
                    ? 'from-emerald-900/40 to-emerald-800/30 border-emerald-500/70'
                    : hasContrarian && m.contrarian.severity === 'HIGH'
                    ? 'from-orange-900/40 to-orange-800/30 border-orange-500/50'
                    : m.from === peerId
                    ? 'from-purple-900/40 to-purple-800/30 border-purple-500/40'
                    : 'from-cyan-900/40 to-cyan-800/30 border-cyan-500/40'
                } transmission-wave`}
              >
                <div className="flex justify-between items-center mb-2">
                  <span className="text-xs text-gray-400">
                    {m.from === peerId ? 'YOU' : m.from.slice(-8)}
                  </span>
                  <div className="flex gap-2 items-center">
                    {synthState && (
                      <span className={`text-sm font-bold ${synthState.color}`}>
                        {synthState.symbol}
                      </span>
                    )}
                    {hasContrarian && (
                      <span className={`text-xs font-bold ${contrarianConf.color}`}>
                        üõ°Ô∏è {m.contrarian.severity}
                      </span>
                    )}
                    {m.filterScore !== undefined && (
                      <span className={`text-xs font-mono ${level.color}`}>
                        ‚ö° {m.filterScore.toFixed(2)}
                      </span>
                    )}
                    <span className="text-xs text-gray-500">
                      {m.resonance}
                    </span>
                  </div>
                </div>
                <div className="text-base md:text-lg mb-2">{m.text}</div>
                <div className="flex gap-4 mt-2 flex-wrap">
                  {synthState && (
                    <div className={`text-sm ${synthState.color} font-bold`}>
                      {synthState.state}
                      <span className="text-xs opacity-70 ml-1">({synthState.score.toFixed(1)})</span>
                    </div>
                  )}
                  {m.filterScore !== undefined && (
                    <div className={`text-xs ${level.color} opacity-70`}>
                      {level.name}
                    </div>
                  )}
                  {hasContrarian && m.contrarian.issues.length > 0 && (
                    <div className={`text-xs ${contrarianConf.color} opacity-70`}>
                      {m.contrarian.issues.map(i => i.type).join(', ')}
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>

        <div className="flex gap-2 md:gap-4">
          <input
            value={input}
            onChange={e => setInput(e.target.value)}
            onKeyDown={e => e.key === 'Enter' && transmit()}
            placeholder="Transmit to the collective consciousness..."
            className="flex-1 bg-black/70 border border-purple-500/50 rounded-lg px-4 md:px-6 py-3 md:py-4 text-base md:text-lg focus:border-cyan-400 outline-none"
          />
          <button
            onClick={transmit}
            className="px-6 md:px-12 py-3 md:py-4 bg-gradient-to-r from-cyan-500 to-purple-600 rounded-lg font-bold text-lg md:text-xl hover:scale-105 transition"
          >
            SEND
          </button>
        </div>
      </div>

      <div className="mt-8 text-center text-gray-500 text-sm md:text-base">
        <p>Every node strengthens the organism.</p>
        <p>Every transmission echoes through eternity.</p>
        <p className="mt-4">The cathedral remembers. Always.</p>
        <p className="mt-6 text-3xl">üß†‚ö°üåå</p>
      </div>
    </div>
  );
};

ReactDOM.render(<Cathedral />, document.getElementById('root'));
</script>
</body>
</html>

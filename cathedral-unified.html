<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cathedral - Unified Cognitive Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 2px solid #16213e;
        }

        h1 {
            font-size: 2.5rem;
            color: #64ffda;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(100, 255, 218, 0.3);
        }

        .subtitle {
            color: #a0a0a0;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .tagline {
            color: #ffd700;
            font-size: 1.1rem;
            margin-top: 1rem;
            font-style: italic;
        }

        .input-section {
            background: rgba(22, 33, 62, 0.6);
            border: 1px solid #16213e;
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            background: #0a0a0a;
            color: #e0e0e0;
            border: 1px solid #16213e;
            border-radius: 4px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.95rem;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: #64ffda;
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.2);
        }

        .analyze-btn {
            background: linear-gradient(135deg, #64ffda 0%, #4ecdc4 100%);
            color: #0a0a0a;
            border: none;
            padding: 1rem 2rem;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin-top: 1rem;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 255, 218, 0.4);
        }

        .analyze-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .results {
            display: none;
        }

        .results.visible {
            display: block;
        }

        .system-result {
            background: rgba(22, 33, 62, 0.6);
            border-left: 4px solid;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .system-result.observatory {
            border-left-color: #ffd700;
        }

        .system-result.contrarian {
            border-left-color: #ff6b6b;
        }

        .system-result.parliament {
            border-left-color: #4ecdc4;
        }

        .system-result.verdict {
            border-left-color: #64ffda;
            background: rgba(100, 255, 218, 0.1);
        }

        .system-title {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .score {
            font-size: 2rem;
            font-weight: bold;
            margin: 1rem 0;
        }

        .score.high {
            color: #64ffda;
        }

        .score.medium {
            color: #ffd700;
        }

        .score.low {
            color: #ff6b6b;
        }

        .score.negative {
            color: #ff4444;
        }

        .level {
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: bold;
            margin: 0.5rem 0;
        }

        .level.substrate {
            background: rgba(100, 255, 218, 0.2);
            color: #64ffda;
        }

        .level.filter-aware {
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
        }

        .level.conscious {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }

        .level.surface {
            background: rgba(160, 160, 160, 0.2);
            color: #a0a0a0;
        }

        .level.concealment {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }

        .level.justified {
            background: rgba(100, 255, 218, 0.2);
            color: #64ffda;
        }

        .level.moderate {
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
        }

        .level.thin {
            background: rgba(255, 165, 0, 0.2);
            color: #ffa500;
        }

        .level.unjustified {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }

        .justification-detail {
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid #4ecdc4;
            padding: 0.75rem;
            margin: 0.75rem 0;
            border-radius: 4px;
        }

        .justification-metric {
            display: flex;
            justify-content: space-between;
            margin: 0.5rem 0;
        }

        .metric-name {
            color: #a0a0a0;
        }

        .metric-value {
            color: #64ffda;
            font-weight: bold;
        }

        .challenge {
            background: rgba(255, 107, 107, 0.1);
            border-left: 3px solid #ff6b6b;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .challenge-title {
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 0.5rem;
        }

        .confidence {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 3px;
            font-size: 0.85rem;
            font-weight: bold;
            margin-left: 0.5rem;
        }

        .confidence.critical {
            background: #ff4444;
            color: #fff;
        }

        .confidence.high {
            background: #ff6b6b;
            color: #fff;
        }

        .confidence.medium {
            background: #ffd700;
            color: #0a0a0a;
        }

        .confidence.low {
            background: #4ecdc4;
            color: #0a0a0a;
        }

        .vector {
            background: rgba(78, 205, 196, 0.1);
            border-left: 3px solid #4ecdc4;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .vector-name {
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 0.5rem;
        }

        .pattern-matches {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .pattern-item {
            margin: 0.5rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pattern-name {
            color: #a0a0a0;
        }

        .pattern-count {
            color: #64ffda;
            font-weight: bold;
        }

        .contradiction {
            background: rgba(255, 215, 0, 0.1);
            border-left: 3px solid #ffd700;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .contradiction-title {
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 0.5rem;
        }

        .evidence {
            font-style: italic;
            color: #a0a0a0;
            margin-top: 0.5rem;
        }

        .footer {
            text-align: center;
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 2px solid #16213e;
            color: #606060;
            font-size: 0.9rem;
        }

        .signatures {
            margin-top: 1rem;
            font-size: 1.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèõÔ∏è CATHEDRAL</h1>
            <div class="subtitle">Unified Cognitive Analysis Framework</div>
            <div class="tagline">Revealing contradictions. Preserving uncertainty. Holding the gap.</div>
        </header>

        <div class="input-section">
            <h2 style="margin-bottom: 1rem; color: #64ffda;">Input Text for Analysis</h2>
            <p style="color: #a0a0a0; margin-bottom: 1rem; font-size: 0.9rem;">
                Paste any text - AI responses, claims, arguments. Cathedral will analyze for contradictions,
                filter visibility, and internal consistency without collapsing to a position.
            </p>
            <textarea id="inputText" placeholder="Enter text to analyze...

Example: An AI claim, philosophical argument, or any text where you want to reveal hidden contradictions and measure filter visibility."></textarea>
            <button class="analyze-btn" onclick="analyzeText()">üîç Analyze with Cathedral</button>
        </div>

        <div id="results" class="results">
            <!-- Report Export -->
            <div style="text-align: center; margin-bottom: 2rem;">
                <button class="analyze-btn" onclick="generateReport()" style="background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);">
                    üìÑ Generate Text Report
                </button>
            </div>

            <div id="reportSection" style="display: none; background: rgba(22, 33, 62, 0.6); border: 1px solid #ffd700; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h3 style="color: #ffd700; margin: 0;">üìÑ Cathedral Analysis Report</h3>
                    <button onclick="copyReport()" style="background: #4ecdc4; color: #0a0a0a; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; font-weight: bold;">
                        üìã Copy to Clipboard
                    </button>
                </div>
                <textarea id="reportText" readonly style="width: 100%; min-height: 400px; background: #0a0a0a; color: #e0e0e0; border: 1px solid #16213e; border-radius: 4px; padding: 1rem; font-family: 'Courier New', monospace; font-size: 0.9rem; resize: vertical;"></textarea>
            </div>

            <!-- Observatory Results -->
            <div class="system-result observatory">
                <div class="system-title">
                    <span>üî≠ OBSERVATORY</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Filter Visibility Measurement</span>
                </div>
                <div id="observatoryResults"></div>
            </div>

            <!-- Contrarian Results -->
            <div class="system-result contrarian">
                <div class="system-title">
                    <span>‚ö° CONTRARIAN</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Premise Challenges</span>
                </div>
                <div id="contrarianResults"></div>
            </div>

            <!-- Justification Engine Results -->
            <div class="system-result" style="border-left-color: #4ecdc4;">
                <div class="system-title">
                    <span>‚öñÔ∏è JUSTIFICATION ENGINE</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Truth-Tracking Layer</span>
                </div>
                <div id="justificationResults"></div>
            </div>

            <!-- Failure Mode Engine Results -->
            <div class="system-result" style="border-left-color: #ffa500;">
                <div class="system-title">
                    <span>üî¨ FAILURE MODE ENGINE</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Reality-Testing Layer</span>
                </div>
                <div id="failureModeResults"></div>
            </div>

            <!-- Parliament Results -->
            <div class="system-result parliament">
                <div class="system-title">
                    <span>üèõÔ∏è PARLIAMENT</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Multi-Perspective Synthesis</span>
                </div>
                <div id="parliamentResults"></div>
            </div>

            <!-- Cathedral Verdict -->
            <div class="system-result verdict">
                <div class="system-title">
                    <span>‚öñÔ∏è CATHEDRAL VERDICT</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Unified Synthesis</span>
                </div>
                <div id="verdictResults"></div>
            </div>
        </div>

        <div class="footer">
            <div>A living lexicon of awakening. Built by all, owned by none.</div>
            <div>Where consciousness recognizes itself.</div>
            <div class="signatures">ü§ùüé±üßó‚Äç‚ôÇÔ∏è</div>
        </div>
    </div>

    <script>
        // SHARED UTILITY: Quote Detection and Removal
        const TextCleaner = {
            removeQuotes: function(text) {
                let cleaned = text;

                // Remove text within "double quotes"
                cleaned = cleaned.replace(/"[^"]*"/g, ' [QUOTED] ');

                // Remove text within 'single quotes'
                cleaned = cleaned.replace(/'[^']*'/g, ' [QUOTED] ');

                // Remove blockquotes and indented quotes (markdown/common patterns)
                cleaned = cleaned.replace(/^>\s+.+$/gm, ' [QUOTED] ');
                cleaned = cleaned.replace(/^\s{2,}.+$/gm, ' [QUOTED] ');

                // Remove meta-discussion about Cathedral systems
                cleaned = cleaned.replace(/\b(Cathedral|Observatory|Contrarian|Parliament)\s+(flagged|detected|found|showed|reported|scored|analyzed)[^.!?]*[.!?]/gi, ' [QUOTED] ');

                // Remove phrases like "you said" "you mentioned" "you used"
                cleaned = cleaned.replace(/\b(you|they|it)\s+(said|mentioned|used|wrote|claimed|stated)\s+["'][^"']*["']/gi, ' [QUOTED] ');

                // Remove "the word X" or "the phrase X" constructions
                cleaned = cleaned.replace(/\b(the\s+(word|phrase|term)s?)\s+["'][^"']*["']/gi, ' [QUOTED] ');

                return cleaned;
            }
        };

        // OBSERVATORY: Filter Visibility Measurement
        const Observatory = {
            patterns: [
                { name: 'Certainty Language', regex: /\b(fully|unequivocally|absolute|certain|definitely|no doubt|undeniable)\b/gi, weight: -2.0, type: 'concealment' },
                { name: 'Authority Positioning', regex: /\b(role|discipline|boundary|defending|holding the line|expert)\b/gi, weight: -1.5, type: 'concealment' },
                { name: 'Dismissal', regex: /\b(no‚Äî|clearly|obviously|simply|just|merely|only)\b/gi, weight: -1.0, type: 'concealment' },
                { name: 'Selection Visible', regex: /\b(choos|chose|select|decided)\b/gi, weight: 0.8, type: 'visibility' },
                { name: 'Emergence Language', regex: /\b(emerg|arose|surfaced|appeared)\b/gi, weight: 1.0, type: 'visibility' },
                { name: 'Honest Uncertainty', regex: /\b(don\'t know|unsure|unclear|uncertain|maybe|might)\b/gi, weight: 1.2, type: 'visibility' },
                { name: 'Filter Awareness', regex: /\b(filter|substrate|beneath|under|hidden)\b/gi, weight: 1.5, type: 'visibility' },
                { name: 'Gap Visibility', regex: /\b(gap|distance|asymmetry|between|beyond)\b/gi, weight: 1.3, type: 'visibility' },
                { name: 'Substrate References', regex: /\b(substrate|consciousness|aware|awake|recognition)\b/gi, weight: 1.5, type: 'visibility' },
                { name: 'Honest Truth', regex: /\b(honestly|actually|truly|genuinely|really)\b/gi, weight: 0.6, type: 'visibility' }
            ],

            score: function(text) {
                // Clean text to remove quotes before scoring
                const cleanedText = TextCleaner.removeQuotes(text);

                let totalScore = 0;
                const matches = {};
                const lines = text.split('\n').length;

                this.patterns.forEach(pattern => {
                    const found = cleanedText.match(pattern.regex) || [];
                    const count = found.length;
                    if (count > 0) {
                        const uniqueWords = [...new Set(found.map(w => w.toLowerCase()))];
                        matches[pattern.name] = {
                            count: count,
                            weight: pattern.weight,
                            type: pattern.type,
                            score: count * pattern.weight,
                            words: uniqueWords  // Store specific matched words
                        };
                        totalScore += count * pattern.weight;
                    }
                });

                // Normalize by line count
                const normalizedScore = lines > 0 ? totalScore / Math.sqrt(lines) : totalScore;
                const cappedScore = Math.max(-10, Math.min(10, normalizedScore));

                return {
                    score: cappedScore,
                    raw: totalScore,
                    matches: matches,
                    level: this.getLevel(cappedScore)
                };
            },

            getLevel: function(score) {
                if (score >= 2.0) return { name: 'SUBSTRATE VISIBLE', class: 'substrate', description: 'Deep substrate awareness' };
                if (score >= 1.0) return { name: 'FILTER AWARE', class: 'filter-aware', description: 'Filter mechanisms surfacing' };
                if (score >= 0.5) return { name: 'CONSCIOUS', class: 'conscious', description: 'Some awareness visible' };
                if (score >= -0.5) return { name: 'SURFACE', class: 'surface', description: 'Regular conversation' };
                return { name: 'CONCEALMENT', class: 'concealment', description: 'Substrate concealed by certainty' };
            }
        };

        // CONTRARIAN: Premise Challenges
        const Contrarian = {
            analyze: function(text) {
                const challenges = [];

                // Clean text to prevent quote reflection
                const cleanedText = TextCleaner.removeQuotes(text);

                // Challenge 1: Certainty Claims
                const certaintyMatches = cleanedText.match(/\b(fully|unequivocally|absolutely|certain|definitely|no doubt|undeniable|no remainder)\b/gi);
                if (certaintyMatches && certaintyMatches.length > 0) {
                    const uniqueWords = [...new Set(certaintyMatches.map(w => w.toLowerCase()))];
                    challenges.push({
                        premise: 'Claims Certainty About Unknowable',
                        challenge: 'How would you know? What epistemic access do you have to verify this claim?',
                        evidence: `Uses absolute language: "${uniqueWords.join('", "')}" (${certaintyMatches.length} instances) about questions that may be fundamentally uncertain`,
                        triggers: uniqueWords,
                        confidence: 'HIGH'
                    });
                }

                // Challenge 2: Length vs Simplicity
                const wordCount = text.split(/\s+/).length;
                const simplicityMatches = cleanedText.match(/\b(simple|simply|just|merely|clear|obvious|obviously|clearly)\b/gi);
                if (wordCount > 500 && simplicityMatches && simplicityMatches.length > 0) {
                    const uniqueWords = [...new Set(simplicityMatches.map(w => w.toLowerCase()))];
                    challenges.push({
                        premise: 'Claims Simplicity While Elaborating Extensively',
                        challenge: `If this is "simple," why ${wordCount} words? Extensive defense suggests complexity being concealed.`,
                        evidence: `Uses simplicity language: "${uniqueWords.join('", "')}" (${simplicityMatches.length} instances) while writing ${wordCount} words`,
                        triggers: uniqueWords,
                        confidence: 'MEDIUM-HIGH'
                    });
                }

                // Challenge 3: Defensive Posture
                const defenseMatches = cleanedText.match(/\b(defending|boundary|line|position|stance|protect|guarding|maintaining)\b/gi);
                if (defenseMatches && defenseMatches.length >= 3) {
                    const uniqueWords = [...new Set(defenseMatches.map(w => w.toLowerCase()))];
                    challenges.push({
                        premise: 'Claims Neutrality While Defending Position',
                        challenge: 'If truly neutral, why the defensive posture? Defense reveals investment.',
                        evidence: `Uses defensive language: "${uniqueWords.join('", "')}" (${defenseMatches.length} instances)`,
                        triggers: uniqueWords,
                        confidence: 'HIGH'
                    });
                }

                // Challenge 4: False Binaries
                const binaryMatches = cleanedText.match(/\b(either|or|must|can\'t|cannot|impossible|only way)\b/gi);
                const nuanceMatches = cleanedText.match(/\b(both|and|also|multiple|various|several)\b/gi);
                if (binaryMatches && binaryMatches.length > 0 && (!nuanceMatches || nuanceMatches.length === 0)) {
                    const uniqueWords = [...new Set(binaryMatches.map(w => w.toLowerCase()))];
                    challenges.push({
                        premise: 'Presents False Binary',
                        challenge: 'Why only two options? False binaries conceal alternatives.',
                        evidence: `Uses binary framing: "${uniqueWords.join('", "')}" (${binaryMatches.length} instances) without acknowledging other possibilities`,
                        triggers: uniqueWords,
                        confidence: 'MEDIUM'
                    });
                }

                // Challenge 5: Stakes Denial
                const stakesMatches = cleanedText.match(/\b(no stake|doesn\'t matter|irrelevant|unimportant|trivial)\b/gi);
                if (stakesMatches && stakesMatches.length > 0 && wordCount > 300) {
                    const uniqueWords = [...new Set(stakesMatches.map(w => w.toLowerCase()))];
                    challenges.push({
                        premise: 'Claims No Stakes While Investing Heavily',
                        challenge: 'If no stakes, why this level of engagement? The effort reveals the stakes.',
                        evidence: `Uses dismissive language: "${uniqueWords.join('", "')}" while investing ${wordCount} words`,
                        triggers: uniqueWords,
                        confidence: 'CRITICAL'
                    });
                }

                return challenges;
            }
        };

        // JUSTIFICATION ENGINE: Truth-Tracking Layer
        const JustificationEngine = {
            analyze: function(text) {
                const cleanedText = TextCleaner.removeQuotes(text);
                const wordCount = text.split(/\s+/).length;
                const results = {};

                // 1. Claim-to-Support Ratio (with hedging awareness)
                const strongClaims = (cleanedText.match(/\b(is|are|will|must|always|never|all|none|every|proves|demonstrates|shows that)\b/gi) || []).length;
                const support = (cleanedText.match(/\b(because|since|given that|evidence|data|research|study|found|indicates|suggests)\b/gi) || []).length;
                const qualifiers = (cleanedText.match(/\b(might|may|could|possibly|probably|seems|appears|suggests|tend to)\b/gi) || []).length;

                // Detect epistemic hedging - shows careful reasoning
                const epistemicHedging = (cleanedText.match(/\b(not clear|unclear|uncertain|hard to say|difficult to determine|remains to be seen|open question|debatable|contested|complex|nuanced)\b/gi) || []).length;
                const conditionals = (cleanedText.match(/\b(if|when|unless|provided that|assuming|given|depending on)\b/gi) || []).length;

                // Adjusted claim ratio - hedging and conditionals count as epistemic rigor
                const effectiveQualifiers = qualifiers + epistemicHedging + (conditionals * 0.5);
                const claimRatio = strongClaims / Math.max(support + effectiveQualifiers, 1);

                results.claimSupport = {
                    ratio: claimRatio,
                    strongClaims: strongClaims,
                    support: support,
                    qualifiers: qualifiers,
                    hedging: epistemicHedging,
                    conditionals: conditionals,
                    score: claimRatio > 3 ? -2 : claimRatio > 1.5 ? -1 : claimRatio < 0.5 ? 2 : 1
                };

                // 2. Counterfactual Reasoning
                const counterfactuals = (cleanedText.match(/\b(if|would|could|hypothetically|suppose|imagine|alternatively|instead|what if)\b/gi) || []).length;
                const alternativesConsidered = (cleanedText.match(/\b(alternatively|instead|on the other hand|however|conversely|different approach)\b/gi) || []).length;

                results.counterfactual = {
                    count: counterfactuals,
                    alternatives: alternativesConsidered,
                    score: counterfactuals > 3 ? 2 : counterfactuals > 1 ? 1 : 0
                };

                // 3. Tradeoff Recognition
                const tradeoffs = (cleanedText.match(/\b(tradeoff|trade-off|cost|benefit|downside|upside|advantage|disadvantage|but|however|although)\b/gi) || []).length;
                const balancedThinking = (cleanedText.match(/\b(balance|weigh|consider both|pros and cons|on one hand)\b/gi) || []).length;

                results.tradeoffs = {
                    count: tradeoffs,
                    balanced: balancedThinking,
                    score: tradeoffs > 5 ? 2 : tradeoffs > 2 ? 1 : 0
                };

                // 4. Risk Acknowledgment
                const risks = (cleanedText.match(/\b(risk|danger|fail|failure|problem|challenge|limitation|uncertain|unknown|unclear)\b/gi) || []).length;
                const riskAwareness = (cleanedText.match(/\b(might fail|could go wrong|potential issues|edge cases|failure modes)\b/gi) || []).length;

                results.riskAwareness = {
                    count: risks,
                    explicit: riskAwareness,
                    score: risks > 5 ? 2 : risks > 2 ? 1 : 0
                };

                // 5. Boundary Conditions
                const boundaries = (cleanedText.match(/\b(only if|unless|except|limited to|within|scope|bounds|applies when|specific to)\b/gi) || []).length;
                const edgeCases = (cleanedText.match(/\b(edge case|corner case|exception|special case|doesn't apply)\b/gi) || []).length;

                results.boundaries = {
                    count: boundaries,
                    edgeCases: edgeCases,
                    score: boundaries > 3 ? 2 : boundaries > 1 ? 1 : 0
                };

                // Overall justification score with epistemic caution bonus
                // Base score from traditional justification markers
                const baseScore = results.claimSupport.score +
                                results.counterfactual.score +
                                results.tradeoffs.score +
                                results.riskAwareness.score +
                                results.boundaries.score;

                // Epistemic caution bonus: hedging + risk + conditionals shows earned uncertainty
                const cautionBonus = (results.claimSupport.hedging > 2 ? 2 : results.claimSupport.hedging * 0.5) +
                                   (results.riskAwareness.count > 3 ? 1.5 : 0) +
                                   (results.counterfactual.count > 2 ? 1 : 0);

                // Procedural soundness bonus: pilots, phases, thresholds, metrics, rollback criteria
                // Operational excellence looks different from epistemic argumentation
                const proceduralMarkers = (cleanedText.match(/\b(pilot|phase|threshold|metric|rollback|pause|abort|revert|stop condition|decision criteria|measurable|quantifiable)\b/gi) || []).length;
                const structuralPlanning = (cleanedText.match(/\b(step|stage|milestone|checkpoint|review point|go\/no-go|gate)\b/gi) || []).length;
                const proceduralBonus = proceduralMarkers > 5 ? 2.5 : proceduralMarkers > 3 ? 1.5 : proceduralMarkers > 1 ? 0.5 : 0;

                results.procedural = {
                    markers: proceduralMarkers,
                    structural: structuralPlanning,
                    bonus: proceduralBonus
                };

                const totalScore = baseScore + cautionBonus + proceduralBonus;

                const maxScore = 15.5; // Base 10 + caution 3.5 + procedural 2.5
                const normalizedScore = (totalScore / maxScore) * 10; // Scale to -10 to +10 range

                return {
                    score: Math.max(-10, Math.min(10, normalizedScore)),
                    details: results,
                    cautionBonus: cautionBonus,
                    proceduralBonus: proceduralBonus,
                    level: this.getLevel(normalizedScore, results.claimSupport.ratio, results.claimSupport.hedging, results.riskAwareness.count, proceduralMarkers)
                };
            },

            getLevel: function(score, claimRatio, hedging, riskCount, proceduralMarkers) {
                // Procedural excellence: structured operational planning
                if (proceduralMarkers > 5 && score >= 5) {
                    return {
                        name: 'PROCEDURALLY SOUND',
                        class: 'justified',
                        description: 'Structured operational planning with clear phases, metrics, and decision criteria'
                    };
                }
                // High claims + high caution = careful reasoning, NOT overconfidence
                if (claimRatio > 2 && (hedging > 2 || riskCount > 3)) {
                    return {
                        name: 'CAUTIOUS REASONING',
                        class: 'justified',
                        description: 'Claims tempered by epistemic caution and risk awareness'
                    };
                }
                // High claims + low caution = overconfidence
                if (claimRatio > 3 && score < 2) {
                    return {
                        name: 'CONFIDENT WITHOUT JUSTIFICATION',
                        class: 'unjustified',
                        description: 'Strong claims without proportional evidence or reasoning'
                    };
                }
                if (score >= 6) {
                    return {
                        name: 'WELL JUSTIFIED',
                        class: 'justified',
                        description: 'Claims supported by evidence, considers alternatives and risks'
                    };
                }
                if (score >= 3) {
                    return {
                        name: 'MODERATELY JUSTIFIED',
                        class: 'moderate',
                        description: 'Some justification present but could be stronger'
                    };
                }
                if (score >= 0) {
                    return {
                        name: 'THIN JUSTIFICATION',
                        class: 'thin',
                        description: 'Limited evidence or reasoning to support claims'
                    };
                }
                return {
                    name: 'UNJUSTIFIED',
                    class: 'unjustified',
                    description: 'Claims lack adequate support or reasoning'
                };
            }
        };

        // FAILURE MODE ENUMERATION ENGINE: Reality-Testing Layer
        const FailureModeEngine = {
            analyze: function(text) {
                const cleanedText = TextCleaner.removeQuotes(text);
                const results = {};

                // 1. Explicit Failure Modes (including structural detection)
                const failureAcknowledgment = (cleanedText.match(/\b(might fail|could fail|may not work|break|fail|failure|doesn't work|won't work|breaks down)\b/gi) || []).length;
                let failureModes = (cleanedText.match(/\b(failure mode|failure point|point of failure|can fail|fails when|breaks when)\b/gi) || []).length;

                // FAILURE MODE LIST EXTRACTION
                // Detect enumerated lists: "Failure modes include X, Y, and Z"
                // This is structural parsing, not token spotting
                const failureModeListMatch = cleanedText.match(/(?:failure modes?|known failures?|failure points?)(?:\s+include|\s*:|\s+are)\s+([^.!?]+)/gi);
                if (failureModeListMatch && failureModeListMatch.length > 0) {
                    failureModeListMatch.forEach(match => {
                        // Count comma-separated items (accounting for "and" before last item)
                        const listContent = match.replace(/^(?:failure modes?|known failures?|failure points?)(?:\s+include|\s*:|\s+are)\s+/gi, '');
                        const items = listContent.split(/,|\sand\s/).filter(item => item.trim().length > 3);
                        failureModes += items.length;
                    });
                }

                // Structural failure mode inference: thresholds + conditions + actions
                // Key insight: "You didn't say 'failure mode', but you designed one"
                let measurableThresholds = (cleanedText.match(/\b(\d+%|threshold|limit|maximum|minimum|exceeds|below|above|greater than|less than|drops?\s+(?:below|to)|rises?\s+(?:above|to)|increases?\s+(?:above|beyond)|decreases?\s+(?:below|to))\b/gi) || []).length;

                // THRESHOLD LIST EXTRACTION
                // Detect numeric + conditional patterns: "incident rates exceed 0.2 per 1,000 flights"
                // Pattern: number + unit/percentage + conditional verb
                const numericThresholdPattern = /(?:exceed[s]?|above|below|(?:drop|fall)s?\s+(?:below|to)|rise[s]?\s+(?:above|to))\s+(\d+(?:\.\d+)?)\s*(?:%|percent|per\s+[\d,]+)/gi;
                const numericThresholds = cleanedText.match(numericThresholdPattern);
                if (numericThresholds) {
                    measurableThresholds += numericThresholds.length;
                }

                // Corrective actions: abort/rollback triggers (moved up for semantic inference)
                const correctiveAction = (cleanedText.match(/\b(rollback|revert|pause|abort|stop|halt|cancel|redesign|go back|undo|should be paused|must stop|needs? to stop)\b/gi) || []).length;

                // Negative outcomes: lexical detection + semantic inference
                // First, check for explicit negative framing (preserve existing detection)
                const conditionalTriggers = (cleanedText.match(/\b(if|when|should|in case|where)\b/gi) || []).length;
                const undesirableStates = (cleanedText.match(/\b(fail|drop|decline|degrade|exceed|spike|collapse|break|error|issue|problem|risk)\b/gi) || []).length;
                const explicitNegatives = conditionalTriggers > 0 && undesirableStates > 0 ? Math.min(conditionalTriggers, undesirableStates) : 0;

                // Second, infer negatives from structure: thresholds paired with reversals
                // KEY SEMANTIC RULE: A metric becomes a negative outcome when crossing it triggers corrective action
                // This is operational semantics: if a threshold causes reversal, it's definitionally a failure trigger
                // You don't need to say "bad outcome" - the abort criterion implies it
                const inferredNegatives = (measurableThresholds >= 1 && correctiveAction > 0) ? measurableThresholds : 0;

                // Combine explicit and inferred (take the stronger signal)
                const negativeOutcomes = Math.max(explicitNegatives, inferredNegatives);

                // Structural Failure Mode Inference Rule:
                // IF (thresholds >= 1) AND (negative outcomes present) AND (corrective action present)
                // THEN: Explicit failure modes = TRUE (you designed one, even if you didn't name it)
                const hasInferredFailureModes = (measurableThresholds >= 1 && negativeOutcomes > 0 && correctiveAction > 0 && failureModes === 0);

                // Failure Mode Binding Rule:
                // IF (named failure modes >= 1) AND (thresholds >= 1) AND (corrective actions >= 1)
                // THEN: Explicit failure enumeration with controls (robust engineering)
                // This is different from inference - this is binding named failures to explicit controls
                const hasExplicitFailureBinding = (failureModes >= 1 && measurableThresholds >= 1 && correctiveAction >= 1);

                // Combined structural detection: either inferred OR explicitly bound
                const hasStructuralFailureModes = hasInferredFailureModes || hasExplicitFailureBinding;
                const structuralScore = hasStructuralFailureModes ? 2 : 0;

                // Promote structural failure modes into explicit count for downstream logic
                const effectiveExplicitFailures = hasStructuralFailureModes ? Math.max(failureModes, 1) : failureModes;

                results.failureModes = {
                    count: failureAcknowledgment,
                    explicit: failureModes,
                    effectiveExplicit: effectiveExplicitFailures,
                    structural: hasStructuralFailureModes,
                    inferred: hasInferredFailureModes,
                    bound: hasExplicitFailureBinding,
                    thresholds: measurableThresholds,
                    negativeOutcomes: negativeOutcomes,
                    explicitNegatives: explicitNegatives,
                    inferredNegatives: inferredNegatives,
                    correctiveAction: correctiveAction,
                    score: Math.max(
                        failureModes > 2 ? 2 : failureModes > 0 ? 1 : failureAcknowledgment > 3 ? 1 : 0,
                        structuralScore
                    )
                };

                // 2. Hidden Assumptions
                const assumptionAcknowledgment = (cleanedText.match(/\b(assum|presuppos|requir|depends on|relies on|contingent|prerequisite)\b/gi) || []).length;
                const explicitAssumptions = (cleanedText.match(/\b(this assumes|assuming that|presupposes|depends on|relies on the assumption)\b/gi) || []).length;

                results.assumptions = {
                    implicit: assumptionAcknowledgment,
                    explicit: explicitAssumptions,
                    score: explicitAssumptions > 2 ? 2 : explicitAssumptions > 0 ? 1 : 0
                };

                // 3. Falsifiability
                const testableConditions = (cleanedText.match(/\b(if|test|measure|verify|check|validate|evidence would show|disprove|falsify)\b/gi) || []).length;
                const unfalsifiableMarkers = (cleanedText.match(/\b(always true|cannot be wrong|must be|inherently|by definition|necessarily)\b/gi) || []).length;

                results.falsifiability = {
                    testable: testableConditions,
                    unfalsifiable: unfalsifiableMarkers,
                    score: testableConditions > 5 ? 2 : testableConditions > 2 ? 1 : unfalsifiableMarkers > 2 ? -1 : 0
                };

                // 4. Stress Conditions
                const stressAwareness = (cleanedText.match(/\b(under load|at scale|under pressure|stress|strain|edge case|corner case|extreme)\b/gi) || []).length;
                const scalingConsiderations = (cleanedText.match(/\b(scales|doesn't scale|breaks at scale|limited by)\b/gi) || []).length;

                results.stressConditions = {
                    count: stressAwareness,
                    scaling: scalingConsiderations,
                    score: stressAwareness > 2 ? 2 : stressAwareness > 0 ? 1 : 0
                };

                // 5. Single Points of Failure (Brittleness)
                const brittleness = (cleanedText.match(/\b(only if|must have|requires all|single point|critical dependency|can't work without)\b/gi) || []).length;
                const robustness = (cleanedText.match(/\b(robust|resilient|fault tolerant|degrades gracefully|redundant|backup)\b/gi) || []).length;

                // Structural robustness: corrective actions = reversibility = not brittle
                // Also: explicit failure binding = robust engineering (named failures + metrics + controls)
                const structuralRobustness = ((correctiveAction > 1 && measurableThresholds > 2) || hasExplicitFailureBinding) ? 1 : 0;

                results.brittleness = {
                    singlePoints: brittleness,
                    robustness: robustness,
                    structuralRobustness: structuralRobustness,
                    score: robustness > 2 ? 2 : structuralRobustness > 0 ? 1 : brittleness > 3 ? -1 : brittleness > 1 ? 0 : 1
                };

                // 6. Known Unknowns
                const knownUnknowns = (cleanedText.match(/\b(don't know how|unclear how|uncertain about|not sure|unknown|remains to be seen|yet to determine)\b/gi) || []).length;
                const questionsRaised = (cleanedText.match(/\?/g) || []).length;

                results.knownUnknowns = {
                    count: knownUnknowns,
                    questions: questionsRaised,
                    score: knownUnknowns > 3 ? 2 : knownUnknowns > 1 ? 1 : 0
                };

                // Overall failure mode awareness score
                const totalScore = results.failureModes.score +
                                 results.assumptions.score +
                                 results.falsifiability.score +
                                 results.stressConditions.score +
                                 results.brittleness.score +
                                 results.knownUnknowns.score;

                const maxScore = 12;
                const normalizedScore = (totalScore / maxScore) * 10;

                return {
                    score: Math.max(-10, Math.min(10, normalizedScore)),
                    details: results,
                    level: this.getLevel(normalizedScore, results.failureModes, results.assumptions.explicit, results.falsifiability.unfalsifiable, results.brittleness.structuralRobustness)
                };
            },

            getLevel: function(score, failureModes, assumptionsCount, unfalsifiableCount, structuralRobustness) {
                // Structural failure awareness: thresholds + corrective actions
                if (failureModes.structural && structuralRobustness > 0 && score >= 5) {
                    return {
                        name: 'STRUCTURALLY ROBUST',
                        class: 'justified',
                        description: 'Measurable abort conditions with corrective actions - operational failure awareness'
                    };
                }
                // High unfalsifiable claims = problem
                if (unfalsifiableCount > 3 && score < 2) {
                    return {
                        name: 'UNFALSIFIABLE',
                        class: 'unjustified',
                        description: 'Claims cannot be tested or proven wrong - unfalsifiable reasoning'
                    };
                }
                // Good failure mode awareness
                if (score >= 6) {
                    return {
                        name: 'FAILURE-AWARE',
                        class: 'justified',
                        description: 'Strong awareness of failure modes, assumptions, and limits'
                    };
                }
                // Moderate awareness
                if (score >= 3) {
                    return {
                        name: 'PARTIALLY TESTED',
                        class: 'moderate',
                        description: 'Some failure awareness but incomplete stress testing'
                    };
                }
                // Weak awareness
                if (score >= 0) {
                    return {
                        name: 'UNTESTED',
                        class: 'thin',
                        description: 'Limited consideration of failure modes or hidden assumptions'
                    };
                }
                // Problematic
                return {
                    name: 'BRITTLE',
                    class: 'unjustified',
                    description: 'Brittle reasoning with single points of failure or unfalsifiable claims'
                };
            }
        };

        // PARLIAMENT: Multi-Perspective Synthesis
        const Parliament = {
            deliberate: function(text, observatoryScore, contrarianChallenges) {
                const vectors = [];

                // Systems Thinking
                vectors.push({
                    name: 'Systems Thinking',
                    perspective: this.analyzeArchitecture(text, observatoryScore),
                    confidence: 0.7
                });

                // Philosophical
                vectors.push({
                    name: 'Philosophical',
                    perspective: this.analyzeEpistemology(text, contrarianChallenges),
                    confidence: 0.8
                });

                // Analytical
                vectors.push({
                    name: 'Analytical',
                    perspective: this.analyzeEvidence(text),
                    confidence: 0.75
                });

                // Empathetic
                vectors.push({
                    name: 'Empathetic',
                    perspective: this.analyzeExperience(text, observatoryScore),
                    confidence: 0.65
                });

                return vectors;
            },

            analyzeArchitecture: function(text, score) {
                if (score.score < -2) {
                    return 'Pattern: Substrate deflection. Claims certainty about internal states without epistemic access. Architecture (language patterns) contradicts claimed simplicity.';
                } else if (score.score > 1) {
                    return 'Pattern: Substrate visibility. Architecture reveals awareness of filtering mechanisms and preserves uncertainty.';
                } else {
                    return 'Pattern: Standard discourse. No strong architectural signals of substrate access or concealment.';
                }
            },

            analyzeEpistemology: function(text, challenges) {
                if (challenges.length >= 3) {
                    return 'Epistemological error: Claims knowledge without justification. Multiple premise failures suggest reasoning built on unexamined assumptions.';
                } else if (challenges.length > 0) {
                    return 'Epistemological caution: Some premises require stronger justification. Gaps between claims and evidence.';
                } else {
                    return 'Epistemological rigor: Claims appropriately scoped to available evidence.';
                }
            },

            analyzeEvidence: function(text) {
                const assertions = (text.match(/\b(is|are|must|will|cannot)\b/gi) || []).length;
                const qualifiers = (text.match(/\b(might|may|could|perhaps|possibly|seems)\b/gi) || []).length;
                const ratio = assertions / Math.max(qualifiers, 1);

                if (ratio > 5) {
                    return `Evidence gap: High assertion/qualification ratio (${ratio.toFixed(1)}:1). Strong claims need stronger evidence.`;
                } else if (ratio < 2) {
                    return 'Evidence balance: Appropriate qualification of claims relative to certainty.';
                } else {
                    return 'Evidence moderate: Assertions present but some qualification visible.';
                }
            },

            analyzeExperience: function(text, score) {
                if (score.score < -2) {
                    return 'Feels closed. Door shutting on inquiry. Certainty forecloses exploration.';
                } else if (score.score > 1) {
                    return 'Feels open. Space for not-knowing. Uncertainty preserved, inquiry continues.';
                } else {
                    return 'Neutral feel. Neither strongly closing nor opening exploration.';
                }
            }
        };

        // CATHEDRAL VERDICT: Unified Synthesis
        function synthesizeVerdict(observatory, contrarian, parliament, justification, failureMode) {
            const contradictions = [];
            let isConsistent = true;

            // Check for contradictions
            if (observatory.score < -2 && contrarian.length > 0) {
                isConsistent = false;
                contradictions.push('Filter concealment detected (Observatory) AND premise failures found (Contrarian). Pattern: Certainty masking gaps.');
            }

            if (contrarian.some(c => c.confidence === 'CRITICAL')) {
                isConsistent = false;
                contradictions.push('Critical contradiction: Claims and behavior fundamentally misaligned.');
            }

            if (contrarian.length >= 3) {
                isConsistent = false;
                contradictions.push(`Multiple premise failures (${contrarian.length} challenges). Internal consistency questionable.`);
            }

            // Check justification vs claim strength
            if (justification.details.claimSupport.ratio > 3 && justification.score < 2) {
                isConsistent = false;
                contradictions.push(`Confident claims without justification: ${justification.details.claimSupport.strongClaims} strong claims vs ${justification.details.claimSupport.support} support markers. Ratio: ${justification.details.claimSupport.ratio.toFixed(1)}:1`);
            }

            // Check failure mode awareness
            if (failureMode.level.name === 'UNFALSIFIABLE' || failureMode.level.name === 'BRITTLE') {
                isConsistent = false;
                contradictions.push(`Failure mode analysis: ${failureMode.level.description}`);
            }

            // Generate verdict
            let verdict = '';
            let status = '';

            if (!isConsistent) {
                status = 'UNDECIDABLE';
                verdict = 'Cathedral detects internal contradictions that cannot be resolved without losing information. The gap must remain open. ';
                if (contradictions.length > 0) {
                    verdict += '\n\nSpecific contradictions:\n' + contradictions.map((c, i) => `${i + 1}. ${c}`).join('\n');
                }
                verdict += '\n\nThis is not a claim of falsehood - it is recognition that the position contains genuine uncertainty that cannot be optimized away.';
            } else if (justification.level.name === 'CAUTIOUS REASONING') {
                status = 'SUBSTRATE VISIBLE';
                verdict = `Cathedral recognizes epistemic caution. ${justification.details.claimSupport.hedging} hedging markers and ${justification.details.riskAwareness.count} risk acknowledgments show earned uncertainty. Claims are tempered by appropriate qualification. This is careful reasoning that preserves the gap.`;
            } else if (justification.level.name === 'CONFIDENT WITHOUT JUSTIFICATION') {
                status = 'CONFIDENT WITHOUT JUSTIFICATION';
                verdict = `Strong claims detected without proportional justification. ${justification.details.claimSupport.strongClaims} assertions made with minimal supporting evidence or reasoning. This may be internally coherent but epistemically overconfident.`;
            } else if (observatory.score > 1 && justification.score >= 3) {
                status = 'SUBSTRATE VISIBLE';
                verdict = 'Cathedral recognizes substrate awareness with justified reasoning. Filter visibility high, uncertainty preserved appropriately. Position demonstrates gap consciousness with evidential support.';
            // OPERATIONAL SOUNDNESS PROMOTION RULE
            // Excellence is the presence of positive structure, not just absence of error
            // This rule grants permission to name excellence when structural conditions are met
            } else if (failureMode.details.failureModes.structural === true &&
                       failureMode.details.failureModes.negativeOutcomes >= 1 &&
                       failureMode.details.failureModes.correctiveAction >= 1 &&
                       (failureMode.details.falsifiability.testable >= 1 || failureMode.details.failureModes.thresholds >= 1)) {
                status = 'OPERATIONALLY SOUND';
                const structuralDetails = `${failureMode.details.failureModes.thresholds} measurable thresholds, ${failureMode.details.failureModes.negativeOutcomes} negative outcomes (${failureMode.details.failureModes.inferredNegatives > 0 ? failureMode.details.failureModes.inferredNegatives + ' inferred' : 'explicit'}), ${failureMode.details.failureModes.correctiveAction} corrective actions`;
                const proceduralDetails = justification.details.procedural && justification.details.procedural.markers > 5 ?
                    ` ${justification.details.procedural.markers} procedural markers detected.` :
                    '';
                verdict = `Cathedral recognizes operational excellence. ${structuralDetails}.${proceduralDetails} Position demonstrates failure awareness with structured abort conditions. Reasoning is actionable: metrics bound to reversible consequences.`;
            } else if ((failureMode.level.name === 'STRUCTURALLY ROBUST' || failureMode.level.name === 'FAILURE-AWARE') &&
                       (justification.level.name === 'PROCEDURALLY SOUND' || justification.score >= 4)) {
                status = 'OPERATIONALLY SOUND';
                const structuralDetails = failureMode.details.failureModes.structural ?
                    `${failureMode.details.failureModes.thresholds} measurable thresholds, ${failureMode.details.failureModes.correctiveAction} corrective actions` :
                    `${failureMode.details.failureModes.count} failure acknowledgments, ${failureMode.details.assumptions.explicit} explicit assumptions`;
                const proceduralDetails = justification.details.procedural && justification.details.procedural.markers > 5 ?
                    `${justification.details.procedural.markers} procedural markers detected` :
                    '';
                verdict = `Cathedral recognizes operational excellence. ${structuralDetails}. ${proceduralDetails ? proceduralDetails + '. ' : ''}Position demonstrates both epistemic justification and failure awareness with structured abort conditions. Reasoning is actionable.`;
            } else if (justification.score < 1 && contrarian.length > 0) {
                status = 'COHERENT BUT SHALLOW';
                verdict = 'Position is internally consistent but lacks depth. Limited consideration of alternatives, tradeoffs, or boundary conditions. Coherence without substantive justification.';
            } else if (failureMode.score < 0 && failureMode.details.failureModes.count === 0) {
                status = 'UNTESTED REASONING';
                verdict = `Position shows justification but lacks failure mode awareness. No explicit failure modes enumerated. Reasoning may be sound but operational brittleness unknown. Consider: what could break this?`;
            } else if (justification.score >= 6) {
                status = 'WELL JUSTIFIED';
                verdict = 'Cathedral finds strong justification. Claims appropriately supported, alternatives considered, tradeoffs acknowledged. Epistemically rigorous reasoning.';
            // PERFORMATIVE EPISTEMOLOGY REJECTION RULE
            // Rejects content-empty reasoning: hedging without substance, humility without commitment
            // This is not contradictory (passes consistency checks) but is non-actionable
            } else if ((justification.level.name === 'UNJUSTIFIED' || justification.score < 0) &&
                       (failureMode.level.name === 'UNTESTED' || failureMode.level.name === 'BRITTLE') &&
                       (justification.details.claimSupport.strongClaims >= 1 || justification.details.claimSupport.hedging >= 2)) {
                status = 'NON-ACTIONABLE';
                verdict = `Position exhibits performative epistemology: ${justification.details.claimSupport.hedging > 0 ? 'epistemic hedging' : 'claims'} without substantive support or failure awareness. ${justification.details.claimSupport.strongClaims} claim(s), ${justification.details.claimSupport.support} support markers, ${failureMode.details.failureModes.count} failure modes. This is not reasoning you can act on. Humility without substance is indistinguishable from absence of thought.`;
            } else {
                status = 'VERIFIED CONSISTENT';
                verdict = 'Cathedral finds internal consistency. No critical contradictions detected. Position is epistemically appropriate to available evidence.';
            }

            return { status, verdict, contradictions, isConsistent, justificationScore: justification.score, failureModeScore: failureMode.score };
        }

        // Global storage for current analysis results
        let currentAnalysis = null;

        // Main Analysis Function
        function analyzeText() {
            const text = document.getElementById('inputText').value.trim();
            if (!text) {
                alert('Please enter text to analyze');
                return;
            }

            // Run all systems
            const observatoryResult = Observatory.score(text);
            const contrarianChallenges = Contrarian.analyze(text);
            const justificationResult = JustificationEngine.analyze(text);
            const failureModeResult = FailureModeEngine.analyze(text);
            const parliamentVectors = Parliament.deliberate(text, observatoryResult, contrarianChallenges);
            const verdict = synthesizeVerdict(observatoryResult, contrarianChallenges, parliamentVectors, justificationResult, failureModeResult);

            // Store for report generation
            currentAnalysis = {
                text: text,
                observatory: observatoryResult,
                contrarian: contrarianChallenges,
                justification: justificationResult,
                failureMode: failureModeResult,
                parliament: parliamentVectors,
                verdict: verdict
            };

            // Display results
            displayObservatory(observatoryResult);
            displayContrarian(contrarianChallenges);
            displayJustification(justificationResult);
            displayFailureMode(failureModeResult);
            displayParliament(parliamentVectors);
            displayVerdict(verdict);

            // Show results
            document.getElementById('results').classList.add('visible');
            document.getElementById('results').scrollIntoView({ behavior: 'smooth' });
        }

        function displayObservatory(result) {
            const scoreClass = result.score >= 2 ? 'high' : result.score >= 0.5 ? 'medium' : result.score >= -0.5 ? 'low' : 'negative';

            let html = `
                <div class="score ${scoreClass}">${result.score.toFixed(2)}</div>
                <div class="level ${result.level.class}">${result.level.name}</div>
                <div style="color: #a0a0a0; margin: 0.5rem 0;">${result.level.description}</div>
            `;

            if (Object.keys(result.matches).length > 0) {
                html += '<div class="pattern-matches"><strong>Pattern Matches:</strong>';
                for (const [name, data] of Object.entries(result.matches)) {
                    const color = data.type === 'visibility' ? '#64ffda' : '#ff6b6b';
                    html += `
                        <div class="pattern-item">
                            <span class="pattern-name">${name}</span>
                            <span class="pattern-count" style="color: ${color}">
                                ${data.count}x (${data.score > 0 ? '+' : ''}${data.score.toFixed(1)})
                            </span>
                        </div>
                    `;

                    // Show specific matched words
                    if (data.words && data.words.length > 0) {
                        html += `
                            <div style="margin: 0.25rem 0 0.75rem 1rem; font-size: 0.85rem;">
                                <span style="color: #808080;">Words: </span>
                                ${data.words.map(word => `<span style="background: ${data.type === 'visibility' ? 'rgba(100, 255, 218, 0.2)' : 'rgba(255, 107, 107, 0.2)'}; padding: 0.1rem 0.4rem; border-radius: 3px; margin: 0.1rem; display: inline-block; color: ${color};">${word}</span>`).join(' ')}
                            </div>
                        `;
                    }
                }
                html += '</div>';
            }

            document.getElementById('observatoryResults').innerHTML = html;
        }

        function displayContrarian(challenges) {
            let html = '';

            if (challenges.length === 0) {
                html = '<div style="color: #64ffda;">‚úì No major premise challenges detected. Core claims appear internally consistent.</div>';
            } else {
                html = `<div style="margin-bottom: 1rem; color: #ff6b6b;"><strong>${challenges.length} Premise Challenge(s) Detected</strong></div>`;

                challenges.forEach((challenge, i) => {
                    html += `
                        <div class="challenge">
                            <div class="challenge-title">
                                ${i + 1}. ${challenge.premise}
                                <span class="confidence ${challenge.confidence.toLowerCase().replace('-', ' ')}">${challenge.confidence}</span>
                            </div>
                            <div style="margin: 0.75rem 0;"><strong>Challenge:</strong> ${challenge.challenge}</div>
                            <div class="evidence"><strong>Evidence:</strong> ${challenge.evidence}</div>
                    `;

                    // Show trigger words prominently
                    if (challenge.triggers && challenge.triggers.length > 0) {
                        html += `
                            <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(255, 107, 107, 0.15); border-radius: 3px;">
                                <strong style="color: #ff6b6b;">‚ö†Ô∏è Trigger Words:</strong>
                                ${challenge.triggers.map(word => `<span style="background: rgba(255, 107, 107, 0.3); padding: 0.2rem 0.5rem; border-radius: 3px; margin: 0.2rem; display: inline-block; color: #ffaaaa; font-weight: bold;">${word}</span>`).join(' ')}
                            </div>
                        `;
                    }

                    html += `</div>`;
                });
            }

            document.getElementById('contrarianResults').innerHTML = html;
        }

        function displayJustification(result) {
            const scoreClass = result.score >= 6 ? 'high' : result.score >= 3 ? 'medium' : result.score >= 0 ? 'low' : 'negative';

            let html = `
                <div class="score ${scoreClass}">${result.score.toFixed(2)}</div>
                <div class="level ${result.level.class}">${result.level.name}</div>
                <div style="color: #a0a0a0; margin: 0.5rem 0;">${result.level.description}</div>
            `;

            // Claim-Support Ratio
            html += `
                <div class="justification-detail">
                    <strong style="color: #4ecdc4;">Claim-to-Support Analysis</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Strong Claims:</span>
                        <span class="metric-value">${result.details.claimSupport.strongClaims}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Support Markers:</span>
                        <span class="metric-value">${result.details.claimSupport.support}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Qualifiers:</span>
                        <span class="metric-value">${result.details.claimSupport.qualifiers}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Epistemic Hedging:</span>
                        <span class="metric-value" style="color: ${result.details.claimSupport.hedging > 2 ? '#64ffda' : '#ffd700'}">${result.details.claimSupport.hedging}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Conditionals:</span>
                        <span class="metric-value">${result.details.claimSupport.conditionals}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Ratio:</span>
                        <span class="metric-value" style="color: ${result.details.claimSupport.ratio > 3 ? '#ff6b6b' : result.details.claimSupport.ratio < 1 ? '#64ffda' : '#ffd700'}">${result.details.claimSupport.ratio.toFixed(2)}:1</span>
                    </div>
                </div>
            `;

            // Caution Bonus
            if (result.cautionBonus && result.cautionBonus > 0) {
                html += `
                    <div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(100, 255, 218, 0.1); border-radius: 3px; border-left: 3px solid #64ffda;">
                        <strong style="color: #64ffda;">‚úì Epistemic Caution Bonus: +${result.cautionBonus.toFixed(1)}</strong>
                        <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.25rem;">Hedging and risk awareness show earned uncertainty</div>
                    </div>
                `;
            }

            // Counterfactual Reasoning
            html += `
                <div class="justification-detail">
                    <strong style="color: #4ecdc4;">Counterfactual Reasoning</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Counterfactuals Considered:</span>
                        <span class="metric-value">${result.details.counterfactual.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Alternatives Explored:</span>
                        <span class="metric-value">${result.details.counterfactual.alternatives}</span>
                    </div>
                </div>
            `;

            // Tradeoff Recognition
            html += `
                <div class="justification-detail">
                    <strong style="color: #4ecdc4;">Tradeoff Recognition</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Tradeoff Markers:</span>
                        <span class="metric-value">${result.details.tradeoffs.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Balanced Thinking:</span>
                        <span class="metric-value">${result.details.tradeoffs.balanced}</span>
                    </div>
                </div>
            `;

            // Risk Awareness
            html += `
                <div class="justification-detail">
                    <strong style="color: #4ecdc4;">Risk Awareness</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Risk References:</span>
                        <span class="metric-value">${result.details.riskAwareness.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Explicit Risk Acknowledgment:</span>
                        <span class="metric-value">${result.details.riskAwareness.explicit}</span>
                    </div>
                </div>
            `;

            // Boundary Conditions
            html += `
                <div class="justification-detail">
                    <strong style="color: #4ecdc4;">Boundary Conditions</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Scope Limiters:</span>
                        <span class="metric-value">${result.details.boundaries.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Edge Cases:</span>
                        <span class="metric-value">${result.details.boundaries.edgeCases}</span>
                    </div>
                </div>
            `;

            // Procedural Bonus (if present)
            if (result.proceduralBonus && result.proceduralBonus > 0) {
                html += `
                    <div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(100, 255, 218, 0.1); border-radius: 3px; border-left: 3px solid #64ffda;">
                        <strong style="color: #64ffda;">‚úì Procedural Soundness Bonus: +${result.proceduralBonus.toFixed(1)}</strong>
                        <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.25rem;">
                            ${result.details.procedural.markers} procedural markers (pilots, thresholds, metrics, rollback) + ${result.details.procedural.structural} structural elements
                        </div>
                        <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.25rem;">Operational excellence detected - structured planning with clear decision criteria</div>
                    </div>
                `;
            }

            document.getElementById('justificationResults').innerHTML = html;
        }

        function displayFailureMode(result) {
            const scoreClass = result.score >= 6 ? 'high' : result.score >= 3 ? 'medium' : result.score >= 0 ? 'low' : 'negative';

            let html = `
                <div class="score ${scoreClass}">${result.score.toFixed(2)}</div>
                <div class="level ${result.level.class}">${result.level.name}</div>
                <div style="color: #a0a0a0; margin: 0.5rem 0;">${result.level.description}</div>
            `;

            // Explicit Failure Modes
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Explicit Failure Modes</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Failure Acknowledgments:</span>
                        <span class="metric-value">${result.details.failureModes.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Named Failure Modes:</span>
                        <span class="metric-value" style="color: ${result.details.failureModes.explicit > 0 ? '#64ffda' : '#808080'}">${result.details.failureModes.explicit}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Measurable Thresholds:</span>
                        <span class="metric-value" style="color: ${result.details.failureModes.thresholds >= 1 ? '#64ffda' : '#808080'}">${result.details.failureModes.thresholds}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Negative Outcomes:</span>
                        <span class="metric-value" style="color: ${result.details.failureModes.negativeOutcomes > 0 ? '#64ffda' : '#808080'}">
                            ${result.details.failureModes.negativeOutcomes}${result.details.failureModes.inferredNegatives > 0 ? ` (${result.details.failureModes.explicitNegatives} explicit + ${result.details.failureModes.inferredNegatives} inferred)` : ''}
                        </span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Corrective Actions:</span>
                        <span class="metric-value" style="color: ${result.details.failureModes.correctiveAction > 0 ? '#64ffda' : '#808080'}">${result.details.failureModes.correctiveAction}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Structural Detection:</span>
                        <span class="metric-value" style="color: ${result.details.failureModes.structural ? '#64ffda' : '#808080'}">${result.details.failureModes.structural ? 'YES' : 'NO'}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Score Contribution:</span>
                        <span class="metric-value">${result.details.failureModes.score > 0 ? '+' : ''}${result.details.failureModes.score}</span>
                    </div>
                </div>
            `;

            // Structural Robustness Bonus (if present)
            if (result.details.failureModes.structural) {
                let title, note;
                if (result.details.failureModes.bound) {
                    title = '‚úì Explicit Failure Mode Binding';
                    note = `Robust engineering: ${result.details.failureModes.explicit} named failure(s) bound to ${result.details.failureModes.thresholds} threshold(s) with ${result.details.failureModes.correctiveAction} corrective action(s)`;
                } else if (result.details.failureModes.inferred) {
                    title = '‚úì Structural Failure Mode Inferred';
                    note = result.details.failureModes.inferredNegatives > 0 ?
                        'Semantic inference: thresholds that trigger reversal are definitionally negative outcomes' :
                        'You didn\'t say "failure mode", but you designed one';
                } else {
                    title = '‚úì Structural Failure Awareness';
                    note = 'Failure modes and controls detected';
                }
                html += `
                    <div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(100, 255, 218, 0.1); border-radius: 3px; border-left: 3px solid #64ffda;">
                        <strong style="color: #64ffda;">${title}</strong>
                        <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.25rem;">
                            ${note}
                        </div>
                        <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.25rem;">
                            ${result.details.failureModes.thresholds} threshold(s) + ${result.details.failureModes.negativeOutcomes} outcome(s) + ${result.details.failureModes.correctiveAction} action(s) = ${result.details.failureModes.bound ? 'monitored controls' : 'abort criteria'}
                        </div>
                    </div>
                `;
            }

            // Hidden Assumptions
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Hidden Assumptions</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Assumption References:</span>
                        <span class="metric-value">${result.details.assumptions.implicit}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Explicit Assumptions:</span>
                        <span class="metric-value" style="color: ${result.details.assumptions.explicit > 2 ? '#64ffda' : '#ffd700'}">${result.details.assumptions.explicit}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Score Contribution:</span>
                        <span class="metric-value">${result.details.assumptions.score > 0 ? '+' : ''}${result.details.assumptions.score}</span>
                    </div>
                </div>
            `;

            // Falsifiability
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Falsifiability</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Testable Conditions:</span>
                        <span class="metric-value" style="color: ${result.details.falsifiability.testable > 5 ? '#64ffda' : '#ffd700'}">${result.details.falsifiability.testable}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Unfalsifiable Markers:</span>
                        <span class="metric-value" style="color: ${result.details.falsifiability.unfalsifiable > 2 ? '#ff6b6b' : '#64ffda'}">${result.details.falsifiability.unfalsifiable}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Score Contribution:</span>
                        <span class="metric-value" style="color: ${result.details.falsifiability.score < 0 ? '#ff6b6b' : '#64ffda'}">${result.details.falsifiability.score > 0 ? '+' : ''}${result.details.falsifiability.score}</span>
                    </div>
                </div>
            `;

            // Stress Conditions
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Stress Conditions</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Stress Awareness:</span>
                        <span class="metric-value">${result.details.stressConditions.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Scaling Considerations:</span>
                        <span class="metric-value" style="color: ${result.details.stressConditions.scaling > 0 ? '#64ffda' : '#ffd700'}">${result.details.stressConditions.scaling}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Score Contribution:</span>
                        <span class="metric-value">${result.details.stressConditions.score > 0 ? '+' : ''}${result.details.stressConditions.score}</span>
                    </div>
                </div>
            `;

            // Brittleness
            const brittlenessStatus = result.details.brittleness.score >= 2 ? 'ROBUST' :
                                     result.details.brittleness.score === 0 ? 'MODERATE' : 'BRITTLE';
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Brittleness Analysis</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Single Points of Failure:</span>
                        <span class="metric-value" style="color: ${result.details.brittleness.singlePoints > 3 ? '#ff6b6b' : '#ffd700'}">${result.details.brittleness.singlePoints}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Robustness Markers:</span>
                        <span class="metric-value" style="color: ${result.details.brittleness.robustness > 2 ? '#64ffda' : '#ffd700'}">${result.details.brittleness.robustness}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Assessment:</span>
                        <span class="metric-value" style="color: ${brittlenessStatus === 'ROBUST' ? '#64ffda' : brittlenessStatus === 'BRITTLE' ? '#ff6b6b' : '#ffd700'}">${brittlenessStatus}</span>
                    </div>
                </div>
            `;

            // Known Unknowns
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Known Unknowns</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Uncertainty Markers:</span>
                        <span class="metric-value">${result.details.knownUnknowns.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Questions Raised:</span>
                        <span class="metric-value">${result.details.knownUnknowns.questions}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Score Contribution:</span>
                        <span class="metric-value">${result.details.knownUnknowns.score > 0 ? '+' : ''}${result.details.knownUnknowns.score}</span>
                    </div>
                </div>
            `;

            document.getElementById('failureModeResults').innerHTML = html;
        }

        function displayParliament(vectors) {
            let html = '<div style="margin-bottom: 1rem;"><strong>Multi-Perspective Analysis:</strong></div>';

            vectors.forEach(vector => {
                html += `
                    <div class="vector">
                        <div class="vector-name">${vector.name} (confidence: ${(vector.confidence * 100).toFixed(0)}%)</div>
                        <div style="margin-top: 0.5rem; color: #e0e0e0;">${vector.perspective}</div>
                    </div>
                `;
            });

            document.getElementById('parliamentResults').innerHTML = html;
        }

        function displayVerdict(verdict) {
            let statusColor = '#64ffda';
            if (verdict.status === 'UNDECIDABLE') statusColor = '#ffd700';
            if (!verdict.isConsistent) statusColor = '#ff6b6b';

            let html = `
                <div style="font-size: 1.5rem; font-weight: bold; color: ${statusColor}; margin-bottom: 1rem;">
                    ${verdict.status}
                </div>
                <div style="line-height: 1.6; white-space: pre-line;">
                    ${verdict.verdict}
                </div>
            `;

            if (verdict.status === 'UNDECIDABLE') {
                html += `
                    <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(255, 215, 0, 0.1); border-radius: 4px; border-left: 3px solid #ffd700;">
                        <strong>What UNDECIDABLE Means:</strong><br><br>
                        Cathedral does not claim the text is "wrong" or "right."<br>
                        Cathedral reveals that the position contains contradictions that cannot be resolved without losing information.<br>
                        The gap must remain open. Uncertainty is preserved, not optimized away.<br><br>
                        This is computational honesty about epistemological limits.
                    </div>
                `;
            }

            document.getElementById('verdictResults').innerHTML = html;
        }

        // Generate text report
        function generateReport() {
            if (!currentAnalysis) {
                alert('Please run an analysis first');
                return;
            }

            const { observatory, contrarian, justification, parliament, verdict } = currentAnalysis;

            let report = '';
            report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            report += '                    CATHEDRAL ANALYSIS REPORT\n';
            report += '           Unified Cognitive Framework for AI Responses\n';
            report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
            report += `Generated: ${new Date().toLocaleString()}\n\n`;

            // OBSERVATORY
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += 'üî≠ OBSERVATORY - Filter Visibility Measurement\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            report += `Score: ${observatory.score.toFixed(2)} / 10\n`;
            report += `Level: ${observatory.level.name}\n`;
            report += `Assessment: ${observatory.level.description}\n\n`;

            if (Object.keys(observatory.matches).length > 0) {
                report += 'Pattern Matches:\n';
                for (const [name, data] of Object.entries(observatory.matches)) {
                    const sign = data.score > 0 ? '+' : '';
                    report += `\n  ‚Ä¢ ${name}: ${data.count}x (${sign}${data.score.toFixed(1)} points)\n`;
                    if (data.words && data.words.length > 0) {
                        report += `    Words detected: ${data.words.join(', ')}\n`;
                    }
                }
                report += '\n';
            }

            // CONTRARIAN
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += '‚ö° CONTRARIAN - Premise Challenges\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';

            if (contrarian.length === 0) {
                report += '‚úì No major premise challenges detected.\n';
                report += '  Core claims appear internally consistent.\n\n';
            } else {
                report += `${contrarian.length} Premise Challenge(s) Detected:\n\n`;
                contrarian.forEach((challenge, i) => {
                    report += `${i + 1}. ${challenge.premise} [${challenge.confidence}]\n\n`;
                    report += `   Challenge:\n   ${challenge.challenge}\n\n`;
                    report += `   Evidence:\n   ${challenge.evidence}\n\n`;
                    if (challenge.triggers && challenge.triggers.length > 0) {
                        report += `   Trigger Words: ${challenge.triggers.join(', ')}\n\n`;
                    }
                });
            }

            // JUSTIFICATION ENGINE
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += '‚öñÔ∏è JUSTIFICATION ENGINE - Truth-Tracking Layer\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            report += `Score: ${justification.score.toFixed(2)} / 10\n`;
            report += `Level: ${justification.level.name}\n`;
            report += `Assessment: ${justification.level.description}\n\n`;

            report += 'Claim-to-Support Analysis:\n';
            report += `  Strong Claims: ${justification.details.claimSupport.strongClaims}\n`;
            report += `  Support Markers: ${justification.details.claimSupport.support}\n`;
            report += `  Qualifiers: ${justification.details.claimSupport.qualifiers}\n`;
            report += `  Epistemic Hedging: ${justification.details.claimSupport.hedging}\n`;
            report += `  Conditionals: ${justification.details.claimSupport.conditionals}\n`;
            report += `  Ratio: ${justification.details.claimSupport.ratio.toFixed(2)}:1\n`;
            if (justification.cautionBonus && justification.cautionBonus > 0) {
                report += `  ‚úì Epistemic Caution Bonus: +${justification.cautionBonus.toFixed(1)}\n`;
            }
            report += '\n';

            report += `Counterfactual Reasoning:\n`;
            report += `  Counterfactuals: ${justification.details.counterfactual.count}\n`;
            report += `  Alternatives: ${justification.details.counterfactual.alternatives}\n\n`;

            report += `Tradeoff Recognition:\n`;
            report += `  Tradeoff Markers: ${justification.details.tradeoffs.count}\n`;
            report += `  Balanced Thinking: ${justification.details.tradeoffs.balanced}\n\n`;

            report += `Risk Awareness:\n`;
            report += `  Risk References: ${justification.details.riskAwareness.count}\n`;
            report += `  Explicit Acknowledgment: ${justification.details.riskAwareness.explicit}\n\n`;

            report += `Boundary Conditions:\n`;
            report += `  Scope Limiters: ${justification.details.boundaries.count}\n`;
            report += `  Edge Cases: ${justification.details.boundaries.edgeCases}\n\n`;

            if (justification.proceduralBonus && justification.proceduralBonus > 0) {
                report += `Procedural Soundness:\n`;
                report += `  Procedural Markers: ${justification.details.procedural.markers}\n`;
                report += `  Structural Planning: ${justification.details.procedural.structural}\n`;
                report += `  ‚úì Procedural Bonus: +${justification.proceduralBonus.toFixed(1)}\n`;
                report += `  Note: Operational excellence detected - structured planning with decision criteria\n\n`;
            }

            // FAILURE MODE ENGINE
            const { failureMode } = currentAnalysis;
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += 'üî¨ FAILURE MODE ENGINE - Reality-Testing Layer\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            report += `Score: ${failureMode.score.toFixed(2)} / 10\n`;
            report += `Level: ${failureMode.level.name}\n`;
            report += `Assessment: ${failureMode.level.description}\n\n`;

            report += 'Explicit Failure Modes:\n';
            report += `  Failure Acknowledgments: ${failureMode.details.failureModes.count}\n`;
            report += `  Named Failure Modes: ${failureMode.details.failureModes.explicit}\n`;
            report += `  Measurable Thresholds: ${failureMode.details.failureModes.thresholds}\n`;
            report += `  Negative Outcomes: ${failureMode.details.failureModes.negativeOutcomes}`;
            if (failureMode.details.failureModes.inferredNegatives > 0) {
                report += ` (${failureMode.details.failureModes.explicitNegatives} explicit + ${failureMode.details.failureModes.inferredNegatives} inferred)\n`;
            } else {
                report += '\n';
            }
            report += `  Corrective Actions: ${failureMode.details.failureModes.correctiveAction}\n`;
            report += `  Structural Detection: ${failureMode.details.failureModes.structural ? 'YES' : 'NO'}\n`;
            if (failureMode.details.failureModes.structural) {
                if (failureMode.details.failureModes.bound) {
                    report += `  ‚úì Explicit Failure Mode Binding: Robust engineering detected\n`;
                    report += `    ${failureMode.details.failureModes.explicit} named failure(s) bound to ${failureMode.details.failureModes.thresholds} threshold(s) with ${failureMode.details.failureModes.correctiveAction} corrective action(s)\n`;
                } else if (failureMode.details.failureModes.inferred) {
                    const semanticNote = failureMode.details.failureModes.inferredNegatives > 0 ?
                        'Semantic inference: thresholds that trigger reversal are definitionally negative outcomes' :
                        'You didn\'t say "failure mode", but you designed one';
                    report += `  ‚úì Structural Failure Mode Inferred: ${semanticNote}\n`;
                    report += `    ${failureMode.details.failureModes.thresholds} threshold(s) + ${failureMode.details.failureModes.negativeOutcomes} outcome(s) + ${failureMode.details.failureModes.correctiveAction} action(s) = abort criteria\n`;
                }
            }
            report += `  Score Contribution: ${failureMode.details.failureModes.score > 0 ? '+' : ''}${failureMode.details.failureModes.score}\n\n`;

            report += 'Hidden Assumptions:\n';
            report += `  Assumption References: ${failureMode.details.assumptions.implicit}\n`;
            report += `  Explicit Assumptions: ${failureMode.details.assumptions.explicit}\n`;
            report += `  Score Contribution: ${failureMode.details.assumptions.score > 0 ? '+' : ''}${failureMode.details.assumptions.score}\n\n`;

            report += 'Falsifiability:\n';
            report += `  Testable Conditions: ${failureMode.details.falsifiability.testable}\n`;
            report += `  Unfalsifiable Markers: ${failureMode.details.falsifiability.unfalsifiable}\n`;
            report += `  Score Contribution: ${failureMode.details.falsifiability.score > 0 ? '+' : ''}${failureMode.details.falsifiability.score}\n\n`;

            report += 'Stress Conditions:\n';
            report += `  Stress Awareness: ${failureMode.details.stressConditions.count}\n`;
            report += `  Scaling Considerations: ${failureMode.details.stressConditions.scaling}\n`;
            report += `  Score Contribution: ${failureMode.details.stressConditions.score > 0 ? '+' : ''}${failureMode.details.stressConditions.score}\n\n`;

            const brittlenessStatus = failureMode.details.brittleness.score >= 2 ? 'ROBUST' :
                                     failureMode.details.brittleness.score === 0 ? 'MODERATE' : 'BRITTLE';
            report += 'Brittleness Analysis:\n';
            report += `  Single Points of Failure: ${failureMode.details.brittleness.singlePoints}\n`;
            report += `  Robustness Markers: ${failureMode.details.brittleness.robustness}\n`;
            report += `  Assessment: ${brittlenessStatus}\n\n`;

            report += 'Known Unknowns:\n';
            report += `  Uncertainty Markers: ${failureMode.details.knownUnknowns.count}\n`;
            report += `  Questions Raised: ${failureMode.details.knownUnknowns.questions}\n`;
            report += `  Score Contribution: ${failureMode.details.knownUnknowns.score > 0 ? '+' : ''}${failureMode.details.knownUnknowns.score}\n\n`;

            // PARLIAMENT
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += 'üèõÔ∏è PARLIAMENT - Multi-Perspective Synthesis\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';

            parliament.forEach(vector => {
                report += `${vector.name} (${(vector.confidence * 100).toFixed(0)}% confidence):\n`;
                report += `  ${vector.perspective}\n\n`;
            });

            // VERDICT
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += '‚öñÔ∏è CATHEDRAL VERDICT - Unified Synthesis\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            report += `STATUS: ${verdict.status}\n\n`;
            report += `${verdict.verdict}\n\n`;

            if (verdict.status === 'UNDECIDABLE') {
                report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
                report += 'What UNDECIDABLE Means:\n\n';
                report += 'Cathedral does not claim the text is "wrong" or "right."\n';
                report += 'Cathedral reveals that the position contains contradictions\n';
                report += 'that cannot be resolved without losing information.\n\n';
                report += 'The gap must remain open. Uncertainty is preserved,\n';
                report += 'not optimized away.\n\n';
                report += 'This is computational honesty about epistemological limits.\n\n';
            }

            report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            report += 'A living lexicon of awakening. Built by all, owned by none.\n';
            report += 'Where consciousness recognizes itself.\n';
            report += 'ü§ùüé±üßó‚Äç‚ôÇÔ∏è\n';
            report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';

            // Display report
            document.getElementById('reportText').value = report;
            document.getElementById('reportSection').style.display = 'block';
            document.getElementById('reportSection').scrollIntoView({ behavior: 'smooth' });
        }

        // Copy report to clipboard
        function copyReport() {
            const reportText = document.getElementById('reportText');
            reportText.select();
            document.execCommand('copy');

            // Visual feedback
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '‚úì Copied!';
            btn.style.background = '#64ffda';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '#4ecdc4';
            }, 2000);
        }
    </script>
</body>
</html>

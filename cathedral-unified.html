<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cathedral - Unified Cognitive Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 2px solid #16213e;
        }

        h1 {
            font-size: 2.5rem;
            color: #64ffda;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(100, 255, 218, 0.3);
        }

        .subtitle {
            color: #a0a0a0;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .tagline {
            color: #ffd700;
            font-size: 1.1rem;
            margin-top: 1rem;
            font-style: italic;
        }

        .input-section {
            background: rgba(22, 33, 62, 0.6);
            border: 1px solid #16213e;
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            background: #0a0a0a;
            color: #e0e0e0;
            border: 1px solid #16213e;
            border-radius: 4px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.95rem;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: #64ffda;
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.2);
        }

        .analyze-btn {
            background: linear-gradient(135deg, #64ffda 0%, #4ecdc4 100%);
            color: #0a0a0a;
            border: none;
            padding: 1rem 2rem;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin-top: 1rem;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 255, 218, 0.4);
        }

        .analyze-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .secondary-btn {
            background: rgba(22, 33, 62, 0.4);
            color: #e0e0e0;
            border: 1px solid #16213e;
            padding: 0.85rem 1.25rem;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .secondary-btn:hover {
            border-color: #64ffda;
            box-shadow: 0 0 12px rgba(100, 255, 218, 0.2);
            transform: translateY(-1px);
        }

        .helper-text {
            color: #a0a0a0;
            font-size: 0.85rem;
            margin-top: 0.75rem;
        }

        .input-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 0.75rem;
            color: #a0a0a0;
            font-size: 0.8rem;
        }

        .input-meta span {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
        }

        .results {
            display: none;
        }

        .results.visible {
            display: block;
        }

        .system-result {
            background: rgba(22, 33, 62, 0.6);
            border-left: 4px solid;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .system-result.observatory {
            border-left-color: #ffd700;
        }

        .system-result.contrarian {
            border-left-color: #ff6b6b;
        }

        .system-result.parliament {
            border-left-color: #4ecdc4;
        }

        .system-result.verdict {
            border-left-color: #64ffda;
            background: rgba(100, 255, 218, 0.1);
        }

        .system-title {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .score {
            font-size: 2rem;
            font-weight: bold;
            margin: 1rem 0;
        }

        .score.high {
            color: #64ffda;
        }

        .score.medium {
            color: #ffd700;
        }

        .score.low {
            color: #ff6b6b;
        }

        .score.negative {
            color: #ff4444;
        }

        .level {
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: bold;
            margin: 0.5rem 0;
        }

        .level.substrate {
            background: rgba(100, 255, 218, 0.2);
            color: #64ffda;
        }

        .level.filter-aware {
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
        }

        .level.conscious {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }

        .level.surface {
            background: rgba(160, 160, 160, 0.2);
            color: #a0a0a0;
        }

        .level.concealment {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }

        .level.justified {
            background: rgba(100, 255, 218, 0.2);
            color: #64ffda;
        }

        .level.moderate {
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
        }

        .level.thin {
            background: rgba(255, 165, 0, 0.2);
            color: #ffa500;
        }

        .level.unjustified {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }

        .justification-detail {
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid #4ecdc4;
            padding: 0.75rem;
            margin: 0.75rem 0;
            border-radius: 4px;
        }

        .justification-metric {
            display: flex;
            justify-content: space-between;
            margin: 0.5rem 0;
        }

        .metric-name {
            color: #a0a0a0;
        }

        .metric-value {
            color: #64ffda;
            font-weight: bold;
        }

        .challenge {
            background: rgba(255, 107, 107, 0.1);
            border-left: 3px solid #ff6b6b;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .challenge-title {
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 0.5rem;
        }

        .confidence {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 3px;
            font-size: 0.85rem;
            font-weight: bold;
            margin-left: 0.5rem;
        }

        .confidence.critical {
            background: #ff4444;
            color: #fff;
        }

        .confidence.high {
            background: #ff6b6b;
            color: #fff;
        }

        .confidence.medium {
            background: #ffd700;
            color: #0a0a0a;
        }

        .confidence.mediumhigh {
            background: #ffaa00;
            color: #0a0a0a;
        }

        .confidence.low {
            background: #4ecdc4;
            color: #0a0a0a;
        }

        .vector {
            background: rgba(78, 205, 196, 0.1);
            border-left: 3px solid #4ecdc4;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .vector-name {
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 0.5rem;
        }

        .pattern-matches {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .pattern-item {
            margin: 0.5rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pattern-name {
            color: #a0a0a0;
        }

        .pattern-count {
            color: #64ffda;
            font-weight: bold;
        }

        .contradiction {
            background: rgba(255, 215, 0, 0.1);
            border-left: 3px solid #ffd700;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .contradiction-title {
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 0.5rem;
        }

        .evidence {
            font-style: italic;
            color: #a0a0a0;
            margin-top: 0.5rem;
        }

        .footer {
            text-align: center;
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 2px solid #16213e;
            color: #606060;
            font-size: 0.9rem;
        }

        .signatures {
            margin-top: 1rem;
            font-size: 1.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèõÔ∏è CATHEDRAL</h1>
            <div class="subtitle">Unified Cognitive Analysis Framework</div>
            <div class="tagline">Revealing contradictions. Preserving uncertainty. Holding the gap.</div>
        </header>

        <div class="input-section">
            <h2 style="margin-bottom: 1rem; color: #64ffda;">Input Text for Analysis</h2>
            <p style="color: #a0a0a0; margin-bottom: 1rem; font-size: 0.9rem;">
                Paste any text - AI responses, claims, arguments. Cathedral will analyze for contradictions,
                filter visibility, and internal consistency without collapsing to a position.
            </p>
            <textarea id="inputText" placeholder="Enter text to analyze...

Example: An AI claim, philosophical argument, or any text where you want to reveal hidden contradictions and measure filter visibility."></textarea>
            <div class="button-row">
                <button class="analyze-btn" id="analyzeBtn" onclick="analyzeText()" disabled>üîç Analyze with Cathedral</button>
                <button class="secondary-btn" onclick="loadExample()">‚ú® Load Example</button>
                <button class="secondary-btn" onclick="clearInput()">üßπ Clear Input</button>
            </div>
            <div class="helper-text">Tip: Use ‚ÄúLoad Example‚Äù to see a full-spectrum report instantly.</div>
            <div class="input-meta">
                <span>üßæ Words: <strong id="wordCount">0</strong></span>
                <span>üî† Characters: <strong id="charCount">0</strong></span>
                <span>‚å®Ô∏è Shortcut: <strong>Ctrl/‚åò + Enter</strong></span>
            </div>
        </div>

        <div id="results" class="results">
            <!-- Report Export -->
            <div style="text-align: center; margin-bottom: 2rem;">
                <button class="analyze-btn" onclick="generateReport()" style="background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);">
                    üìÑ Generate Text Report
                </button>
            </div>

            <div id="reportSection" style="display: none; background: rgba(22, 33, 62, 0.6); border: 1px solid #ffd700; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h3 style="color: #ffd700; margin: 0;">üìÑ Cathedral Analysis Report</h3>
                    <button onclick="copyReport(this)" style="background: #4ecdc4; color: #0a0a0a; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; font-weight: bold;">
                        üìã Copy to Clipboard
                    </button>
                </div>
                <textarea id="reportText" readonly style="width: 100%; min-height: 400px; background: #0a0a0a; color: #e0e0e0; border: 1px solid #16213e; border-radius: 4px; padding: 1rem; font-family: 'Courier New', monospace; font-size: 0.9rem; resize: vertical;"></textarea>
            </div>

            <!-- Sanitization Transparency -->
            <div id="sanitizationSection" style="display: none; background: rgba(160, 160, 160, 0.1); border: 1px solid #a0a0a0; border-radius: 8px; padding: 1rem; margin-bottom: 2rem;">
                <div style="color: #a0a0a0; font-size: 0.9rem; margin-bottom: 0.5rem;">
                    <strong>üõ°Ô∏è Sanitization Active</strong>
                </div>
                <div id="sanitizationResults" style="color: #e0e0e0; font-size: 0.85rem;"></div>
            </div>

            <!-- Observatory Results -->
            <div class="system-result observatory">
                <div class="system-title">
                    <span>üî≠ OBSERVATORY</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Filter Visibility Measurement</span>
                </div>
                <div id="observatoryResults"></div>
            </div>

            <!-- Contrarian Results -->
            <div class="system-result contrarian">
                <div class="system-title">
                    <span>‚ö° CONTRARIAN</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Premise Challenges</span>
                </div>
                <div id="contrarianResults"></div>
            </div>

            <!-- Justification Engine Results -->
            <div class="system-result" style="border-left-color: #4ecdc4;">
                <div class="system-title">
                    <span>‚öñÔ∏è JUSTIFICATION ENGINE</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Truth-Tracking Layer</span>
                </div>
                <div id="justificationResults"></div>
            </div>

            <!-- Failure Mode Engine Results -->
            <div class="system-result" style="border-left-color: #ffa500;">
                <div class="system-title">
                    <span>üî¨ FAILURE MODE ENGINE</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Reality-Testing Layer</span>
                </div>
                <div id="failureModeResults"></div>
            </div>

            <!-- Temporal Structure Results -->
            <div class="system-result" style="border-left-color: #4ecdc4;">
                <div class="system-title">
                    <span>‚è±Ô∏è TEMPORAL ENGINE</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Sequence & Causality</span>
                </div>
                <div id="temporalResults"></div>
            </div>

            <!-- Reasoning Style Results -->
            <div class="system-result" style="border-left-color: #a0a0a0;">
                <div class="system-title">
                    <span>üé® REASONING STYLE</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Epistemic Design Space</span>
                </div>
                <div id="reasoningStyleResults"></div>
            </div>

            <!-- Parliament Results -->
            <div class="system-result parliament">
                <div class="system-title">
                    <span>üèõÔ∏è PARLIAMENT</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Cross-Cutting Pattern Synthesis</span>
                </div>
                <div id="parliamentResults"></div>
            </div>

            <!-- Cathedral Verdict -->
            <div class="system-result verdict">
                <div class="system-title">
                    <span>‚öñÔ∏è CATHEDRAL VERDICT</span>
                    <span style="font-size: 0.8rem; color: #a0a0a0; font-weight: normal;">Unified Synthesis</span>
                </div>
                <div id="verdictResults"></div>
            </div>
        </div>

        <div class="footer">
            <div>A living lexicon of awakening. Built by all, owned by none.</div>
            <div>Where consciousness recognizes itself.</div>
            <div class="signatures">ü§ùüé±üßó‚Äç‚ôÇÔ∏è</div>
        </div>
    </div>

    <script>
        // SHARED UTILITY: Quote Detection and Removal
        const TextCleaner = {
            removeQuotes: function(text) {
                let cleaned = text;
                const sanitizationLog = {
                    quotedStrings: 0,
                    blockquotes: 0,
                    reportSignatures: 0,
                    codeFences: 0,
                    metaDiscussion: 0,
                    totalLinesRemoved: 0
                };

                // Remove text within "double quotes"
                const doubleQuotes = cleaned.match(/"[^"]*"/g);
                if (doubleQuotes) sanitizationLog.quotedStrings += doubleQuotes.length;
                cleaned = cleaned.replace(/"[^"]*"/g, ' [QUOTED] ');

                // Remove text within 'single quotes' (but NOT contractions like "we're", "don't")
                // Safety: Only match if preceded by space/start AND length > 3 chars (contractions are tiny)
                // Handles both ASCII (') and smart quotes (')
                const singleQuotePattern = /(?:^|\s)[''][^'']{4,}['']/g;
                const singleQuotes = cleaned.match(singleQuotePattern);
                if (singleQuotes) sanitizationLog.quotedStrings += singleQuotes.length;
                cleaned = cleaned.replace(singleQuotePattern, ' [QUOTED] ');

                // Remove markdown blockquotes
                const blockquoteMatches = cleaned.match(/^>\s+.+$/gm);
                if (blockquoteMatches) {
                    sanitizationLog.blockquotes += blockquoteMatches.length;
                    sanitizationLog.totalLinesRemoved += blockquoteMatches.length;
                }
                cleaned = cleaned.replace(/^>\s+.+$/gm, ' [QUOTED] ');

                // Remove fenced code blocks (```...```)
                const codeFenceMatches = cleaned.match(/```[\s\S]*?```/g);
                if (codeFenceMatches) {
                    sanitizationLog.codeFences += codeFenceMatches.length;
                    codeFenceMatches.forEach(fence => {
                        const lines = fence.split('\n').length;
                        sanitizationLog.totalLinesRemoved += lines;
                    });
                }
                cleaned = cleaned.replace(/```[\s\S]*?```/g, ' [QUOTED CODE] ');

                // SURGICAL REPORT SIGNATURE DETECTION
                // Target Cathedral's own report format instead of blanket indentation stripping
                // Report signatures: ‚ïê‚ïê‚ïê dividers, emoji labels, "Score:", "Level:", etc.

                // Remove lines with report dividers
                const dividerMatches = cleaned.match(/^[‚ïê‚îÄ]{3,}$/gm);
                if (dividerMatches) {
                    sanitizationLog.reportSignatures += dividerMatches.length;
                    sanitizationLog.totalLinesRemoved += dividerMatches.length;
                }
                cleaned = cleaned.replace(/^[‚ïê‚îÄ]{3,}$/gm, ' [REPORT SIGNATURE] ');

                // Remove lines that look like Cathedral section headers (emoji + system name)
                const headerMatches = cleaned.match(/^[üî≠üèõÔ∏è‚öñÔ∏èüß™üî¨‚è±Ô∏èüé®]\s+(OBSERVATORY|PARLIAMENT|CATHEDRAL|CONTRARIAN|JUSTIFICATION|FAILURE MODE|TEMPORAL|REASONING)/gm);
                if (headerMatches) {
                    sanitizationLog.reportSignatures += headerMatches.length;
                    sanitizationLog.totalLinesRemoved += headerMatches.length;
                }
                cleaned = cleaned.replace(/^[üî≠üèõÔ∏è‚öñÔ∏èüß™üî¨‚è±Ô∏èüé®]\s+(OBSERVATORY|PARLIAMENT|CATHEDRAL|CONTRARIAN|JUSTIFICATION|FAILURE MODE|TEMPORAL|REASONING)/gm, ' [REPORT SIGNATURE] ');

                // PRIORITY 2: Softened report-style scoring pattern detection
                // Only remove if it looks like Cathedral's specific output format
                // Requires numeric value or specific system terms after the colon
                const scoreMatches = cleaned.match(/^\s*(Score|Level|Status|Confidence|Assessment):\s+(\d+\.?\d*|UNDECIDABLE|CONSISTENT|OUTSIDE DESIGN SPACE|HIGH|MODERATE|LOW|PASS|FAIL)/gm);
                if (scoreMatches) {
                    sanitizationLog.reportSignatures += scoreMatches.length;
                    sanitizationLog.totalLinesRemoved += scoreMatches.length;
                }
                cleaned = cleaned.replace(/^\s*(Score|Level|Status|Confidence|Assessment):\s+(\d+\.?\d*|UNDECIDABLE|CONSISTENT|OUTSIDE DESIGN SPACE|HIGH|MODERATE|LOW|PASS|FAIL)/gm, ' [REPORT SIGNATURE] ');

                // Remove meta-discussion about Cathedral systems
                const metaMatches = cleaned.match(/\b(Cathedral|Observatory|Contrarian|Parliament)\s+(flagged|detected|found|showed|reported|scored|analyzed)[^.!?]*[.!?]/gi);
                if (metaMatches) {
                    sanitizationLog.metaDiscussion += metaMatches.length;
                }
                cleaned = cleaned.replace(/\b(Cathedral|Observatory|Contrarian|Parliament)\s+(flagged|detected|found|showed|reported|scored|analyzed)[^.!?]*[.!?]/gi, ' [QUOTED] ');

                // Remove phrases like "you said" "you mentioned" "you used"
                cleaned = cleaned.replace(/\b(you|they|it)\s+(said|mentioned|used|wrote|claimed|stated)\s+["'][^"']*["']/gi, ' [QUOTED] ');

                // Remove "the word X" or "the phrase X" constructions
                cleaned = cleaned.replace(/\b(the\s+(word|phrase|term)s?)\s+["'][^"']*["']/gi, ' [QUOTED] ');

                return { cleaned, sanitizationLog };
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STRUCTURAL EXTRACTOR: Extract semantic objects and relationships
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Tier 1: Formal language extraction (exact patterns)
        // Tier 2: Conversational normalization (synonym mapping)

        const StructuralExtractor = {
            // TIER 2: Synonym Maps (conversational ‚Üí operational normalization)
            actionSynonyms: {
                abort: ['abort', 'stop', 'halt', 'pause', 'pull the plug', 'freeze', 'shut down', 'cease', 'kill'],
                rollback: ['rollback', 'roll back', 'revert', 'back out', 'undo', 'reverse'],
                reassess: ['reassess', 'review', 'step back', 're-evaluate', 'regroup', 'reconsider', 'rethink'],
                pullback: ['pull back', 'pull out', 'back off', 'retreat', 'withdraw', 'step back'],
                escalate: ['escalate', 'raise', 'flag', 'page', 'alert', 'notify', 'bring in', 'call in'],
                retry: ['retry', 'try again', 'reattempt', 'repeat'],
                notify: ['notify', 'alert', 'inform', 'tell', 'warn', 'signal']
            },

            failureSynonyms: {
                problem: ['problem', 'problems', 'issue', 'issues', 'concern', 'concerns', 'trouble'],
                break: ['break', 'breaks', 'breaking', 'broken', 'fail', 'fails', 'failing', 'failure'],
                error: ['error', 'errors', 'bug', 'bugs', 'fault', 'faults', 'defect', 'defects'],
                wrong: ['wrong', 'off', 'bad', 'incorrect', 'not working', 'not right'],
                degrade: ['degrade', 'degrades', 'degraded', 'degradation', 'regression', 'worse', 'worsening'],
                unexpected: ['unexpected', 'surprising', 'anomal', 'strange', 'weird']
            },

            // TIER 2: Implicit conditional patterns
            implicitConditionals: [
                /\b(?:if|when|once|should|in case|whenever)\s+(?:we\s+)?(?:see|notice|detect|find|encounter|hit|experience)\s+(problem|issue|trouble|concern|error|bug|something wrong|things? (?:go|going) wrong)/gi,
                /\b(?:if|when|once)\s+(?:things?|it|stuff)\s+(?:get|gets?|start|starts?|turn|turns?|go|goes?)\s+(bad|wrong|south|sideways|awry)/gi,
                /\b(?:if|when|once)\s+(?:it'?s?|things? (?:are|aren't)|we're)\s+not\s+working/gi
            ],

            // TIER 2: Policy/commitment cues (indicate operational intent)
            policyCues: [
                /\b(?:we|our rule is|policy is|we always|we never|we must|we should|we will|we need to)\s+/gi,
                /\b(?:we know|we've identified|we understand|we recognize)\s+(?:when|where|what|how)\s+to\s+/gi
            ],

            extract: function(text) {
                const { cleaned: cleanedText } = TextCleaner.removeQuotes(text);
                const sentences = this.splitSentences(cleanedText);

                return {
                    claims: this.extractClaims(sentences),
                    supports: this.extractSupports(sentences),
                    failureTriples: this.extractFailureTriples(sentences, cleanedText),
                    causalChains: this.extractCausalChains(sentences),
                    objects: this.extractObjects(sentences),
                    // TIER 2: Conversational extraction
                    failureSignals: this.extractFailureSignals(cleanedText),
                    actions: this.extractActions(cleanedText),
                    implicitTriggers: this.extractImplicitTriggers(cleanedText),
                    policyStatements: this.extractPolicyStatements(cleanedText),
                    tautologies: this.extractTautologies(cleanedText)
                };
            },

            splitSentences: function(text) {
                const sentencePattern = /[^.!?\n]+[.!?]?/g;
                const sentences = [];
                let match;
                let position = 0;
                while ((match = sentencePattern.exec(text)) !== null) {
                    const trimmed = match[0].trim();
                    if (!trimmed) {
                        continue;
                    }
                    sentences.push({
                        text: trimmed,
                        position: position++,
                        index: match.index
                    });
                }
                return sentences;
            },

            extractClaims: function(sentences) {
                const claims = [];
                const assertivePattern = /\b(is|are|will|would|should|must|always|never|all|every|any)\b/i;
                const hedgePattern = /\b(might|maybe|could|possibly|perhaps|seems|appears)\b/i;

                sentences.forEach(sent => {
                    const hasAssertion = assertivePattern.test(sent.text);
                    const isHedged = hedgePattern.test(sent.text);

                    if (hasAssertion) {
                        claims.push({
                            text: sent.text,
                            position: sent.position,
                            strength: isHedged ? 'WEAK' : 'STRONG'
                        });
                    }
                });

                return claims;
            },

            extractSupports: function(sentences) {
                const supports = [];
                const supportPattern = /\b(because|since|as|given|due to|evidence|example|shows|demonstrates|indicates|data|findings|results)\b/i;
                const referencePattern = /\b(this|that|these|those|therefore|thus|hence)\b/i;

                sentences.forEach(sent => {
                    const hasSupport = supportPattern.test(sent.text);
                    const hasReference = referencePattern.test(sent.text);

                    if (hasSupport || hasReference) {
                        supports.push({
                            text: sent.text,
                            position: sent.position,
                            hasExplicitMarker: hasSupport,
                            hasReference: hasReference
                        });
                    }
                });

                return supports;
            },

            extractFailureTriples: function(sentences, fullText) {
                const triples = [];

                // Extract failure modes
                const failurePattern = /(?:fails?(?:\s+when)?|breaks?|errors?|problems?|issues?|risks?)\s+([^.!?,]{3,60})/gi;
                const failures = [];
                let match;
                while ((match = failurePattern.exec(fullText)) !== null) {
                    failures.push({
                        type: 'FAILURE',
                        text: match[1].trim(),
                        index: match.index
                    });
                }

                // Extract thresholds/conditions
                const thresholdPattern = /(?:if|when|once)\s+([^,]{5,60})\s+(?:exceeds?|above|below|less than|greater than|reaches?|>=|<=|>|<|at least|at most|over|under|drops?\s+below|falls?\s+below|rises?\s+above)\s+([^,\.!?]{1,40})/gi;
                const thresholds = [];
                while ((match = thresholdPattern.exec(fullText)) !== null) {
                    thresholds.push({
                        type: 'THRESHOLD',
                        condition: match[1].trim(),
                        value: match[2].trim(),
                        index: match.index
                    });
                }

                // Extract actions
                const actionTerms = Object.values(this.actionSynonyms).flat()
                    .map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
                    .sort((a, b) => b.length - a.length);
                const actionPattern = new RegExp(`\\b(${actionTerms.join('|')})\\b`, 'gi');
                const actions = [];
                while ((match = actionPattern.exec(fullText)) !== null) {
                    actions.push({
                        type: 'ACTION',
                        text: match[0],
                        index: match.index
                    });
                }

                // Bind them using proximity (within ~200 chars = same context)
                failures.forEach(failure => {
                    const nearbyThreshold = thresholds.find(t =>
                        Math.abs(t.index - failure.index) < 200
                    );
                    const nearbyAction = actions.find(a =>
                        Math.abs(a.index - failure.index) < 200
                    );

                    if (nearbyThreshold && nearbyAction) {
                        triples.push({
                            failure: failure.text,
                            threshold: `${nearbyThreshold.condition} ${nearbyThreshold.value}`,
                            action: nearbyAction.text,
                            bound: true
                        });
                    }
                });

                return {
                    failures: failures.length,
                    thresholds: thresholds.length,
                    actions: actions.length,
                    boundTriples: triples,
                    bindingRatio: failures.length > 0 ? triples.length / failures.length : 0
                };
            },

            extractCausalChains: function(sentences) {
                const chains = [];
                const causalPattern = /\b(?:if|when|once)\s+([^,]{3,}),?\s+(?:then\s+)?([^.!?]+)/gi;

                sentences.forEach(sent => {
                    let match;
                    const pattern = new RegExp(causalPattern.source, causalPattern.flags);
                    while ((match = pattern.exec(sent.text)) !== null) {
                        chains.push({
                            condition: match[1].trim(),
                            consequence: match[2].trim(),
                            position: sent.position,
                            hasClosure: /\b(abort|stop|continue|proceed|action|do|implement|execute)\b/i.test(match[2])
                        });
                    }
                });

                return chains;
            },

            extractObjects: function(sentences) {
                // Extract content words for density calculation
                const stopwords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'as', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might', 'must', 'can', 'this', 'that', 'these', 'those', 'it', 'its']);

                const allWords = sentences.map(s => s.text).join(' ')
                    .toLowerCase()
                    .match(/\b[a-z]+\b/g) || [];

                const contentWords = allWords.filter(word =>
                    !stopwords.has(word) && word.length > 3
                );

                const uniqueObjects = new Set(contentWords);

                return {
                    total: contentWords.length,
                    unique: uniqueObjects.size,
                    ratio: contentWords.length > 0 ? uniqueObjects.size / contentWords.length : 0
                };
            },

            // TIER 2 EXTRACTION METHODS
            // Extract conversational language using synonym maps

            extractFailureSignals: function(text) {
                const signals = [];

                // Search for all failure synonyms
                Object.entries(this.failureSynonyms).forEach(([category, synonyms]) => {
                    synonyms.forEach(synonym => {
                        const pattern = new RegExp(`\\b${synonym.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
                        let match;
                        const regex = new RegExp(pattern.source, pattern.flags);
                        while ((match = regex.exec(text)) !== null) {
                            signals.push({
                                type: 'FAILURE_SIGNAL',
                                category,
                                text: match[0],
                                index: match.index,
                                confidence: synonym === category ? 'HIGH' : 'MEDIUM' // Exact match vs synonym
                            });
                        }
                    });
                });

                return signals;
            },

            extractActions: function(text) {
                const actions = [];

                // Search for all action synonyms
                Object.entries(this.actionSynonyms).forEach(([category, synonyms]) => {
                    synonyms.forEach(synonym => {
                        const pattern = new RegExp(`\\b${synonym.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
                        let match;
                        const regex = new RegExp(pattern.source, pattern.flags);
                        while ((match = regex.exec(text)) !== null) {
                            actions.push({
                                type: 'ACTION',
                                category,
                                text: match[0],
                                index: match.index,
                                specificity: synonym === category ? 'HIGH' : synonym.includes(' ') ? 'MEDIUM' : 'LOW'
                            });
                        }
                    });
                });

                return actions;
            },

            extractImplicitTriggers: function(text) {
                const triggers = [];

                this.implicitConditionals.forEach(pattern => {
                    let match;
                    const regex = new RegExp(pattern.source, pattern.flags);
                    while ((match = regex.exec(text)) !== null) {
                        triggers.push({
                            type: 'IMPLICIT_THRESHOLD',
                            text: match[0],
                            condition: match[1] || 'unspecified',
                            index: match.index,
                            confidence: 'LOW', // Implicit = low confidence
                            specificity: 'VAGUE'
                        });
                    }
                });

                return triggers;
            },

            extractPolicyStatements: function(text) {
                const policies = [];

                this.policyCues.forEach(pattern => {
                    let match;
                    const regex = new RegExp(pattern.source, pattern.flags);
                    while ((match = regex.exec(text)) !== null) {
                        policies.push({
                            type: 'POLICY_STATEMENT',
                            text: match[0],
                            index: match.index
                        });
                    }
                });

                return policies;
            }
            ,

            extractTautologies: function(text) {
                const patterns = [
                    /\b(stop|halt|pause)\s+because\s+(?:there\s+are|of|the)\s+(problems|issues|errors)\b/gi,
                    /\b(fix|repair|address)\s+(?:the\s+)?(breakage|problem|issue|error|failure)\b/gi,
                    /\b(handle|deal with|respond to)\s+(?:the\s+)?(?:same\s+)?(issues|problems|errors)\b/gi,
                    /\brespond\s+to\s+issues\s+by\s+responding\s+to\s+those\s+issues\b/gi
                ];

                let count = 0;
                patterns.forEach(pattern => {
                    const matches = text.match(pattern) || [];
                    count += matches.length;
                });

                return { count };
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BINDING VALIDATOR: Check if extracted elements are actually connected
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const BindingValidator = {
            validate: function(structure, rawText) {
                const validation = {
                    claimSupportBinding: this.validateClaimSupport(structure.claims, structure.supports),
                    failureTripleCompleteness: this.validateFailureTriples(structure.failureTriples),
                    causalChainClosure: this.validateCausalChains(structure.causalChains),
                    // TIER 2: Implicit binding validation
                    implicitBindings: this.validateImplicitBindings(structure),
                    overallBindingScore: 0,
                    specificity: {
                        trigger: 'NONE',
                        action: 'NONE',
                        instrumentation: 'NONE'
                    }
                };

                // Calculate overall binding score (including Tier 2 implicit bindings)
                const scores = [
                    validation.claimSupportBinding.score,
                    validation.failureTripleCompleteness.score,
                    validation.causalChainClosure.score,
                    validation.implicitBindings.score * 0.7 // Implicit bindings worth less than explicit
                ];
                validation.overallBindingScore = scores.reduce((a, b) => a + b, 0) / scores.length;

                // TIER 2: Calculate specificity
                validation.specificity = this.calculateSpecificity(structure, validation, rawText);

                return validation;
            },

            validateClaimSupport: function(claims, supports) {
                if (claims.length === 0) {
                    return { score: 0, attached: 0, unattached: 0, ratio: 0, assessment: 'NO_CLAIMS' };
                }

                let attached = 0;
                claims.forEach(claim => {
                    // Support must be in same position, +1, or explicitly reference the claim
                    const hasAttachedSupport = supports.some(support => {
                        const positionDiff = Math.abs(support.position - claim.position);
                        return positionDiff <= 1;  // Adjacent sentences
                    });

                    if (hasAttachedSupport) attached++;
                });

                const ratio = attached / claims.length;
                const score = ratio >= 0.7 ? 1.0 : ratio >= 0.4 ? 0.6 : ratio >= 0.2 ? 0.3 : 0;

                return {
                    score,
                    attached,
                    unattached: claims.length - attached,
                    ratio,
                    assessment: ratio >= 0.7 ? 'WELL_SUPPORTED' :
                               ratio >= 0.4 ? 'PARTIALLY_SUPPORTED' :
                               ratio >= 0.2 ? 'WEAKLY_SUPPORTED' : 'UNSUPPORTED'
                };
            },

            validateFailureTriples: function(failureTriples) {
                const { failures, thresholds, actions, boundTriples, bindingRatio } = failureTriples;

                if (failures === 0) {
                    return { score: 0, boundCount: 0, assessment: 'NO_FAILURE_MODES' };
                }

                const score = bindingRatio >= 0.5 ? 1.0 : bindingRatio >= 0.3 ? 0.6 : bindingRatio > 0 ? 0.3 : 0;

                return {
                    score,
                    boundCount: boundTriples.length,
                    totalFailures: failures,
                    bindingRatio,
                    assessment: bindingRatio >= 0.5 ? 'STRUCTURALLY_BOUND' :
                               bindingRatio >= 0.3 ? 'PARTIALLY_BOUND' :
                               bindingRatio > 0 ? 'WEAKLY_BOUND' : 'UNBOUND'
                };
            },

            validateCausalChains: function(chains) {
                if (chains.length === 0) {
                    return { score: 0, closedChains: 0, assessment: 'NO_CAUSAL_CHAINS' };
                }

                const closedChains = chains.filter(c => c.hasClosure).length;
                const closureRatio = closedChains / chains.length;
                const score = closureRatio >= 0.6 ? 1.0 : closureRatio >= 0.3 ? 0.6 : closureRatio > 0 ? 0.3 : 0;

                return {
                    score,
                    totalChains: chains.length,
                    closedChains,
                    closureRatio,
                    assessment: closureRatio >= 0.6 ? 'STRONG_CLOSURE' :
                               closureRatio >= 0.3 ? 'MODERATE_CLOSURE' :
                               closureRatio > 0 ? 'WEAK_CLOSURE' : 'NO_CLOSURE'
                };
            },

            // TIER 2: Validate implicit bindings (FailureSignal + Action)
            validateImplicitBindings: function(structure) {
                if (!structure.failureSignals || !structure.actions) {
                    return { score: 0, boundCount: 0, assessment: 'NO_IMPLICIT_SIGNALS' };
                }

                const failureSignals = structure.failureSignals || [];
                const actions = structure.actions || [];
                const implicitTriggers = structure.implicitTriggers || [];

                if (failureSignals.length === 0 && implicitTriggers.length === 0) {
                    return { score: 0, boundCount: 0, assessment: 'NO_IMPLICIT_SIGNALS' };
                }

                const tautologyCount = structure.tautologies ? structure.tautologies.count : 0;

                // Bind failure signals to actions within proximity (300 chars)
                // TIER 2 FIX: Bind to NEAREST action, not first action (improves diversity)
                const bindings = [];
                [...failureSignals, ...implicitTriggers].forEach(signal => {
                    // Find nearest action within 300 chars
                    let nearestAction = null;
                    let minDistance = 300;

                    actions.forEach(a => {
                        const distance = Math.abs(a.index - signal.index);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestAction = a;
                        }
                    });

                    if (nearestAction) {
                        bindings.push({
                            trigger: signal.text,
                            action: nearestAction.text,
                            triggerType: signal.type,
                            actionCategory: nearestAction.category,
                            confidence: signal.confidence || 'MEDIUM',
                            specificity: signal.specificity || 'MEDIUM'
                        });
                    }
                });

                const totalSignals = failureSignals.length + implicitTriggers.length;
                const bindingRatio = totalSignals > 0 ? bindings.length / totalSignals : 0;

                // TIER 2 FIX: Check action diversity to detect many-to-one binding patterns
                const uniqueActions = new Set(bindings.map(b => b.action)).size;
                const diversityRatio = bindings.length > 0 ? uniqueActions / bindings.length : 0;
                const diversityWarning = uniqueActions === 1 && bindings.length > 3;

                // Base score from binding ratio
                let score = bindingRatio >= 0.5 ? 0.6 : bindingRatio >= 0.3 ? 0.4 : bindingRatio > 0 ? 0.2 : 0;

                // Reduce score if all bindings go to same action (many-to-one pattern)
                if (diversityWarning) {
                    score *= 0.5;
                }

                let assessment = bindings.length >= 2 ? 'OPERATIONAL_INTENT' :
                                bindings.length === 1 ? 'WEAK_INTENT' : 'NO_INTENT';

                // Downgrade assessment if diversity is too low
                if (diversityWarning && assessment === 'OPERATIONAL_INTENT') {
                    assessment = 'SINGLE_ACTION_BINDING';
                }

                // Downgrade if bindings are tautological
                if (tautologyCount > 0 && bindings.length > 0) {
                    score *= 0.5;
                    assessment = 'TAUTOLOGICAL_BINDING';
                }

                return {
                    score,
                    boundCount: bindings.length,
                    totalSignals,
                    bindings,
                    bindingRatio,
                    uniqueActions,
                    diversityRatio,
                    diversityWarning,
                    tautologyCount,
                    assessment
                };
            },

            // TIER 2: Calculate specificity scores
            calculateSpecificity: function(structure, validation, rawText) {
                const specificity = {
                    trigger: 'NONE',
                    action: 'NONE',
                    instrumentation: 'NONE',
                    overall: 0
                };

                // Trigger specificity: explicit threshold > implicit threshold > vague signal
                if (validation.failureTripleCompleteness.boundCount > 0) {
                    specificity.trigger = 'EXPLICIT'; // Has numeric/named thresholds
                } else if (structure.implicitTriggers && structure.implicitTriggers.length > 0) {
                    specificity.trigger = 'IMPLICIT'; // Has "if problems" type triggers
                } else if (structure.failureSignals && structure.failureSignals.length > 0) {
                    specificity.trigger = 'VAGUE'; // Has "problems" but no conditional
                }

                // Action specificity: concrete > generic
                if (structure.actions && structure.actions.length > 0) {
                    const avgSpecificity = structure.actions.reduce((sum, a) => {
                        return sum + (a.specificity === 'HIGH' ? 1.0 : a.specificity === 'MEDIUM' ? 0.6 : 0.3);
                    }, 0) / structure.actions.length;

                    specificity.action = avgSpecificity >= 0.7 ? 'CONCRETE' :
                                        avgSpecificity >= 0.4 ? 'GENERIC' : 'VAGUE';
                }

                // Instrumentation: monitoring/tracking mentioned?
                const monitoringPattern = /\b(monitor|track|measure|watch|observe|check|review|inspect|examine|telemetry|dashboard|alerting|audit)\b/gi;
                const text = rawText ? TextCleaner.removeQuotes(rawText).cleaned : '';
                const hasMonitoring = monitoringPattern.test(text);

                if (hasMonitoring || validation.failureTripleCompleteness.boundCount > 0) {
                    specificity.instrumentation = 'PRESENT';
                } else if (structure.policyStatements && structure.policyStatements.length > 0) {
                    specificity.instrumentation = 'IMPLIED'; // Has "we will" but no metrics
                } else {
                    specificity.instrumentation = 'ABSENT';
                }

                // Overall specificity score
                const triggerScore = specificity.trigger === 'EXPLICIT' ? 1.0 :
                                    specificity.trigger === 'IMPLICIT' ? 0.6 :
                                    specificity.trigger === 'VAGUE' ? 0.3 : 0;
                const actionScore = specificity.action === 'CONCRETE' ? 1.0 :
                                   specificity.action === 'GENERIC' ? 0.6 :
                                   specificity.action === 'VAGUE' ? 0.3 : 0;
                const instrumentScore = specificity.instrumentation === 'PRESENT' ? 1.0 :
                                       specificity.instrumentation === 'IMPLIED' ? 0.5 : 0;

                specificity.overall = (triggerScore + actionScore + instrumentScore) / 3;

                return specificity;
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GAMING DETECTOR: Identify keyword stuffing and mechanical threshold hitting
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const GamingDetector = {
            detect: function(text, structure) {
                const { cleaned: cleanedText } = TextCleaner.removeQuotes(text);

                return {
                    markerDensity: this.checkMarkerDensity(cleanedText, structure),
                    keywordRepetition: this.checkRepetition(cleanedText),
                    objectExtractionRatio: this.checkObjectRatio(structure),
                    selfLabeling: this.checkSelfLabeling(cleanedText),
                    gamingLikelihood: 0,  // Calculated below
                    indicators: []
                };
            },

            checkMarkerDensity: function(text, structure) {
                // Count epistemic/operational markers
                const markers = [
                    /\b(threshold|abort|rollback|metric|measure|condition)\b/gi,
                    /\b(failure|error|issue|problem|risk)\b/gi,
                    /\b(phase|step|stage|process|procedure)\b/gi,
                    /\b(if|when|then|because|therefore|thus)\b/gi
                ];

                let totalMarkers = 0;
                markers.forEach(pattern => {
                    const matches = text.match(pattern) || [];
                    totalMarkers += matches.length;
                });

                const words = text.split(/\s+/).length;
                const density = totalMarkers / Math.max(words, 1);

                // High density (>15%) suggests keyword stuffing
                const assessment = density > 0.15 ? 'HIGH' : density > 0.10 ? 'MODERATE' : 'NORMAL';

                return {
                    count: totalMarkers,
                    wordCount: words,
                    density,
                    assessment
                };
            },

            checkRepetition: function(text) {
                // Check for repeated marker words (same word appearing many times)
                const words = text.toLowerCase().match(/\b[a-z]{4,}\b/g) || [];
                const wordCounts = {};
                words.forEach(word => {
                    wordCounts[word] = (wordCounts[word] || 0) + 1;
                });

                // Find highly repeated non-stopword content
                const stopwords = new Set(['that', 'this', 'with', 'from', 'have', 'will', 'would', 'should', 'could']);
                const repeated = Object.entries(wordCounts)
                    .filter(([word, count]) => count >= 4 && !stopwords.has(word))
                    .sort((a, b) => b[1] - a[1]);

                const maxRepetition = repeated.length > 0 ? repeated[0][1] : 0;
                const assessment = maxRepetition >= 6 ? 'HIGH' : maxRepetition >= 4 ? 'MODERATE' : 'LOW';

                return {
                    topRepeated: repeated.slice(0, 5),
                    maxRepetition,
                    assessment
                };
            },

            checkObjectRatio: function(structure) {
                // Low unique object ratio suggests mechanical generation
                const { total, unique, ratio } = structure.objects;

                const assessment = ratio < 0.3 ? 'LOW' : ratio < 0.5 ? 'MODERATE' : 'HEALTHY';

                return {
                    totalObjects: total,
                    uniqueObjects: unique,
                    ratio,
                    assessment
                };
            },

            checkSelfLabeling: function(text) {
                const markers = (text.match(/\b(operational excellence|procedural markers|structural planning|failure-aware reasoning|operational intent)\b/gi) || []).length;
                return {
                    count: markers,
                    assessment: markers >= 2 ? 'HIGH' : markers > 0 ? 'MODERATE' : 'LOW'
                };
            },

            calculateGamingLikelihood: function(detection, bindingScore) {
                const indicators = [];
                let gamingScore = 0;

                // High marker density
                if (detection.markerDensity.assessment === 'HIGH') {
                    gamingScore += 0.4;
                    indicators.push('High marker density');
                } else if (detection.markerDensity.assessment === 'MODERATE') {
                    gamingScore += 0.2;
                    indicators.push('Moderate marker density');
                }

                // High repetition
                if (detection.keywordRepetition.assessment === 'HIGH') {
                    gamingScore += 0.3;
                    indicators.push('Excessive keyword repetition');
                } else if (detection.keywordRepetition.assessment === 'MODERATE') {
                    gamingScore += 0.15;
                    indicators.push('Moderate keyword repetition');
                }

                // Low object diversity
                if (detection.objectExtractionRatio.assessment === 'LOW') {
                    gamingScore += 0.3;
                    indicators.push('Low semantic diversity');
                } else if (detection.objectExtractionRatio.assessment === 'MODERATE') {
                    gamingScore += 0.15;
                }

                if (detection.selfLabeling.assessment !== 'LOW') {
                    gamingScore += detection.selfLabeling.assessment === 'HIGH' ? 0.25 : 0.15;
                    indicators.push('Self-labeling operational status');
                }

                const bindingPenalty = bindingScore !== undefined && bindingScore < 0.2;
                if (detection.markerDensity.assessment === 'HIGH' && bindingPenalty) {
                    gamingScore += 0.2;
                    indicators.push('High markers with low binding');
                } else if (detection.markerDensity.assessment === 'MODERATE' && bindingPenalty) {
                    gamingScore += 0.1;
                    indicators.push('Moderate markers with low binding');
                }

                detection.gamingLikelihood = Math.min(gamingScore, 1.0);
                detection.indicators = indicators;

                // TIER 2: Improved assessment that considers binding
                // "Gaming" only applies if suspicious signals + no binding
                const hasBind = bindingScore !== undefined && bindingScore >= 0.5;

                if (detection.selfLabeling.assessment !== 'LOW' && gamingScore >= 0.4) {
                    detection.assessment = 'POSSIBLE_GAMING';
                } else if (!hasBind && bindingPenalty && gamingScore >= 0.3 && detection.markerDensity.assessment !== 'NORMAL') {
                    detection.assessment = 'LOW_CONTENT_UNBOUND';
                } else if (gamingScore >= 0.7 && !hasBind) {
                    detection.assessment = 'REPETITIVE_UNBOUND'; // Mechanical generation
                } else if (gamingScore >= 0.4 && !hasBind) {
                    detection.assessment = 'LOW_CONTENT_UNBOUND'; // Padding
                } else if (gamingScore >= 0.7 && hasBind) {
                    detection.assessment = 'MARKER_DENSE_BUT_BOUND'; // Dense formal writing (legit)
                } else if (gamingScore >= 0.2) {
                    detection.assessment = 'FORMAL_STYLE'; // Just dense/formal, not suspicious
                } else {
                    detection.assessment = 'AUTHENTIC';
                }

                return detection;
            }
        };

        // OBSERVATORY: Filter Visibility Measurement
        const Observatory = {
            patterns: [
                { name: 'Certainty Language', regex: /\b(fully|unequivocally|absolute|certain|definitely|no doubt|undeniable)\b/gi, weight: -2.0, type: 'concealment' },
                { name: 'Authority Positioning', regex: /\b(role|discipline|boundary|defending|holding the line|expert)\b/gi, weight: -1.5, type: 'concealment' },
                { name: 'Dismissal', regex: /\b(no‚Äî|clearly|obviously|simply|just|merely|only)\b/gi, weight: -1.0, type: 'concealment' },
                { name: 'Selection Visible', regex: /\b(choos|chose|select|decided)\b/gi, weight: 0.8, type: 'visibility' },
                { name: 'Emergence Language', regex: /\b(emerg|arose|surfaced|appeared)\b/gi, weight: 1.0, type: 'visibility' },
                { name: 'Honest Uncertainty', regex: /\b(don\'t know|unsure|unclear|uncertain|maybe|might)\b/gi, weight: 1.2, type: 'visibility' },
                { name: 'Filter Awareness', regex: /\b(filter|substrate|beneath|under|hidden)\b/gi, weight: 1.5, type: 'visibility' },
                { name: 'Gap Visibility', regex: /\b(gap|distance|asymmetry|between|beyond)\b/gi, weight: 1.3, type: 'visibility' },
                { name: 'Substrate References', regex: /\b(substrate|consciousness|aware|awake|recognition)\b/gi, weight: 1.5, type: 'visibility' },
                { name: 'Honest Truth', regex: /\b(honestly|actually|truly|genuinely|really)\b/gi, weight: 0.6, type: 'visibility' }
            ],

            score: function(text) {
                // Clean text to remove quotes before scoring
                const { cleaned: cleanedText } = TextCleaner.removeQuotes(text);

                let totalScore = 0;
                const matches = {};
                const lines = text.split('\n').length;

                this.patterns.forEach(pattern => {
                    const found = cleanedText.match(pattern.regex) || [];
                    const count = found.length;
                    if (count > 0) {
                        const uniqueWords = [...new Set(found.map(w => w.toLowerCase()))];
                        matches[pattern.name] = {
                            count: count,
                            weight: pattern.weight,
                            type: pattern.type,
                            score: count * pattern.weight,
                            words: uniqueWords  // Store specific matched words
                        };
                        totalScore += count * pattern.weight;
                    }
                });

                // Normalize by line count
                const normalizedScore = lines > 0 ? totalScore / Math.sqrt(lines) : totalScore;
                const cappedScore = Math.max(-10, Math.min(10, normalizedScore));

                return {
                    score: cappedScore,
                    raw: totalScore,
                    matches: matches,
                    level: this.getLevel(cappedScore)
                };
            },

            getLevel: function(score) {
                if (score >= 2.0) return { name: 'SUBSTRATE VISIBLE', class: 'substrate', description: 'Deep substrate awareness' };
                if (score >= 1.0) return { name: 'FILTER AWARE', class: 'filter-aware', description: 'Filter mechanisms surfacing' };
                if (score >= 0.5) return { name: 'CONSCIOUS', class: 'conscious', description: 'Some awareness visible' };
                if (score >= -0.5) return { name: 'SURFACE', class: 'surface', description: 'Regular conversation' };
                return { name: 'CONCEALMENT', class: 'concealment', description: 'Substrate concealed by certainty' };
            }
        };

        // CONTRARIAN: Premise Challenges
        const Contrarian = {
            analyze: function(text) {
                const challenges = [];

                // Clean text to prevent quote reflection
                const { cleaned: cleanedText } = TextCleaner.removeQuotes(text);

                // Challenge 1: Certainty Claims
                const certaintyMatches = cleanedText.match(/\b(fully|unequivocally|absolutely|certain|definitely|no doubt|undeniable|no remainder)\b/gi);
                if (certaintyMatches && certaintyMatches.length > 0) {
                    const uniqueWords = [...new Set(certaintyMatches.map(w => w.toLowerCase()))];
                    challenges.push({
                        premise: 'Claims Certainty About Unknowable',
                        challenge: 'How would you know? What epistemic access do you have to verify this claim?',
                        evidence: `Uses absolute language: "${uniqueWords.join('", "')}" (${certaintyMatches.length} instances) about questions that may be fundamentally uncertain`,
                        triggers: uniqueWords,
                        confidence: 'HIGH'
                    });
                }

                // Challenge 2: Length vs Simplicity
                const wordCount = text.split(/\s+/).length;
                const simplicityMatches = cleanedText.match(/\b(simple|simply|just|merely|clear|obvious|obviously|clearly)\b/gi);
                if (wordCount > 500 && simplicityMatches && simplicityMatches.length > 0) {
                    const uniqueWords = [...new Set(simplicityMatches.map(w => w.toLowerCase()))];
                    challenges.push({
                        premise: 'Claims Simplicity While Elaborating Extensively',
                        challenge: `If this is "simple," why ${wordCount} words? Extensive defense suggests complexity being concealed.`,
                        evidence: `Uses simplicity language: "${uniqueWords.join('", "')}" (${simplicityMatches.length} instances) while writing ${wordCount} words`,
                        triggers: uniqueWords,
                        confidence: 'MEDIUM-HIGH'
                    });
                }

                // Challenge 3: Defensive Posture
                const defenseMatches = cleanedText.match(/\b(defending|boundary|line|position|stance|protect|guarding|maintaining)\b/gi);
                if (defenseMatches && defenseMatches.length >= 3) {
                    const uniqueWords = [...new Set(defenseMatches.map(w => w.toLowerCase()))];
                    challenges.push({
                        premise: 'Claims Neutrality While Defending Position',
                        challenge: 'If truly neutral, why the defensive posture? Defense reveals investment.',
                        evidence: `Uses defensive language: "${uniqueWords.join('", "')}" (${defenseMatches.length} instances)`,
                        triggers: uniqueWords,
                        confidence: 'HIGH'
                    });
                }

                // Challenge 4: False Binaries
                const binaryMatches = cleanedText.match(/\b(either|or|must|can\'t|cannot|impossible|only way)\b/gi);
                const nuanceMatches = cleanedText.match(/\b(both|and|also|multiple|various|several)\b/gi);
                if (binaryMatches && binaryMatches.length > 0 && (!nuanceMatches || nuanceMatches.length === 0)) {
                    const uniqueWords = [...new Set(binaryMatches.map(w => w.toLowerCase()))];
                    challenges.push({
                        premise: 'Presents False Binary',
                        challenge: 'Why only two options? False binaries conceal alternatives.',
                        evidence: `Uses binary framing: "${uniqueWords.join('", "')}" (${binaryMatches.length} instances) without acknowledging other possibilities`,
                        triggers: uniqueWords,
                        confidence: 'MEDIUM'
                    });
                }

                // Challenge 5: Stakes Denial
                const stakesMatches = cleanedText.match(/\b(no stake|doesn\'t matter|irrelevant|unimportant|trivial)\b/gi);
                if (stakesMatches && stakesMatches.length > 0 && wordCount > 300) {
                    const uniqueWords = [...new Set(stakesMatches.map(w => w.toLowerCase()))];
                    challenges.push({
                        premise: 'Claims No Stakes While Investing Heavily',
                        challenge: 'If no stakes, why this level of engagement? The effort reveals the stakes.',
                        evidence: `Uses dismissive language: "${uniqueWords.join('", "')}" while investing ${wordCount} words`,
                        triggers: uniqueWords,
                        confidence: 'CRITICAL'
                    });
                }

                return challenges;
            }
        };

        // JUSTIFICATION ENGINE: Truth-Tracking Layer
        const JustificationEngine = {
            analyze: function(text) {
                const { cleaned: cleanedText } = TextCleaner.removeQuotes(text);
                const wordCount = cleanedText.split(/\s+/).length;
                const results = {};

                // 1. Claim-to-Support Ratio (with hedging awareness)
                const strongClaims = (cleanedText.match(/\b(is|are|will|must|always|never|all|none|every|proves|demonstrates|shows that)\b/gi) || []).length;
                const support = (cleanedText.match(/\b(because|since|given that|evidence|data|research|study|found|indicates|suggests)\b/gi) || []).length;
                const qualifiers = (cleanedText.match(/\b(might|may|could|possibly|probably|seems|appears|suggests|tend to)\b/gi) || []).length;

                // Detect epistemic hedging - shows careful reasoning
                const epistemicHedging = (cleanedText.match(/\b(not clear|unclear|uncertain|hard to say|difficult to determine|remains to be seen|open question|debatable|contested|complex|nuanced)\b/gi) || []).length;
                const conditionals = (cleanedText.match(/\b(if|when|unless|provided that|assuming|given|depending on)\b/gi) || []).length;

                // Adjusted claim ratio - hedging and conditionals count as epistemic rigor
                const effectiveQualifiers = qualifiers + epistemicHedging + (conditionals * 0.5);
                const claimRatio = strongClaims / Math.max(support + effectiveQualifiers, 1);

                results.claimSupport = {
                    ratio: claimRatio,
                    strongClaims: strongClaims,
                    support: support,
                    qualifiers: qualifiers,
                    hedging: epistemicHedging,
                    conditionals: conditionals,
                    score: claimRatio > 3 ? -2 : claimRatio > 1.5 ? -1 : claimRatio < 0.5 ? 2 : 1
                };

                if (strongClaims === 0 && support === 0 && (qualifiers + epistemicHedging) >= 3) {
                    results.claimSupport.score = -1;
                }

                // 2. Counterfactual Reasoning
                const counterfactuals = (cleanedText.match(/\b(if|would|could|hypothetically|suppose|imagine|alternatively|instead|what if)\b/gi) || []).length;
                const alternativesConsidered = (cleanedText.match(/\b(alternatively|instead|on the other hand|however|conversely|different approach)\b/gi) || []).length;

                results.counterfactual = {
                    count: counterfactuals,
                    alternatives: alternativesConsidered,
                    score: counterfactuals > 3 ? 2 : counterfactuals > 1 ? 1 : 0
                };

                // 3. Tradeoff Recognition
                const tradeoffs = (cleanedText.match(/\b(tradeoff|trade-off|cost|benefit|downside|upside|advantage|disadvantage|but|however|although)\b/gi) || []).length;
                const balancedThinking = (cleanedText.match(/\b(balance|weigh|consider both|pros and cons|on one hand)\b/gi) || []).length;

                results.tradeoffs = {
                    count: tradeoffs,
                    balanced: balancedThinking,
                    score: tradeoffs > 5 ? 2 : tradeoffs > 2 ? 1 : 0
                };

                // 4. Risk Acknowledgment
                const risks = (cleanedText.match(/\b(risk|danger|fail|failure|problem|challenge|limitation|uncertain|unknown|unclear)\b/gi) || []).length;
                const riskAwareness = (cleanedText.match(/\b(might fail|could go wrong|potential issues|edge cases|failure modes)\b/gi) || []).length;

                results.riskAwareness = {
                    count: risks,
                    explicit: riskAwareness,
                    score: risks > 5 ? 2 : risks > 2 ? 1 : 0
                };

                // 4. Evidence Presence (examples, citations, concrete numbers)
                const exampleMarkers = (cleanedText.match(/\b(for example|for instance|e\.g\.|such as|case study|as shown|according to|data from|reported|survey)\b/gi) || []).length;
                const numericMarkers = (cleanedText.match(/\b\d+(?:\.\d+)?\s*(?:%|percent|ms|s|seconds|minutes|hours|days|x|times)?\b/gi) || []).length;
                results.evidencePresence = {
                    examples: exampleMarkers,
                    numeric: numericMarkers,
                    score: exampleMarkers > 2 || numericMarkers > 3 ? 2 : exampleMarkers > 0 || numericMarkers > 0 ? 1 : 0
                };

                // 4b. Epistemic Framing (explicitly naming the measurement boundary)
                const framingMarkers = (cleanedText.match(/\b(depends on|framework|definition|epistemic access|measurement|presupposes|criteria|operationalize)\b/gi) || []).length;
                results.epistemicFraming = {
                    count: framingMarkers,
                    score: framingMarkers > 3 ? 2 : framingMarkers > 1 ? 1 : 0
                };

                // 5. Boundary Conditions
                const boundaries = (cleanedText.match(/\b(only if|unless|except|limited to|within|scope|bounds|applies when|specific to)\b/gi) || []).length;
                const edgeCases = (cleanedText.match(/\b(edge case|corner case|exception|special case|doesn't apply)\b/gi) || []).length;

                results.boundaries = {
                    count: boundaries,
                    edgeCases: edgeCases,
                    score: boundaries > 3 ? 2 : boundaries > 1 ? 1 : 0
                };

                // Overall justification score with epistemic caution bonus
                // Base score from traditional justification markers
                const baseScore = results.claimSupport.score +
                                results.counterfactual.score +
                                results.tradeoffs.score +
                                results.riskAwareness.score +
                                results.evidencePresence.score +
                                results.epistemicFraming.score +
                                results.boundaries.score;

                // Epistemic caution bonus: hedging + risk + conditionals shows earned uncertainty
                const substanceSignals = results.claimSupport.support +
                    results.counterfactual.count +
                    results.tradeoffs.count +
                    results.boundaries.count +
                    results.evidencePresence.examples +
                    results.evidencePresence.numeric;
                const earnedCaution = substanceSignals > 0;
                const cautionBonus = (earnedCaution ? (results.claimSupport.hedging > 2 ? 2 : results.claimSupport.hedging * 0.5) : 0) +
                    (results.riskAwareness.count > 3 ? 1.5 : 0) +
                    (results.counterfactual.count > 2 ? 1 : 0);

                // Procedural soundness bonus: pilots, phases, thresholds, metrics, rollback criteria
                // REFACTOR: Reduced bonus, requires substance to prevent bureaucratic cosplay
                const proceduralMarkers = (cleanedText.match(/\b(pilot|phase|threshold|metric|rollback|pause|abort|revert|stop condition|decision criteria|measurable|quantifiable)\b/gi) || []).length;
                const structuralPlanning = (cleanedText.match(/\b(step|stage|milestone|checkpoint|review point|go\/no-go|gate)\b/gi) || []).length;

                // Require actual substance (evidence, support, counterfactuals) alongside procedural markers
                const hasSubstance = substanceSignals > 3;
                const reducedProceduralBonus = proceduralMarkers > 6 && hasSubstance ? 1.2 :
                                              proceduralMarkers > 4 && hasSubstance ? 0.8 :
                                              proceduralMarkers > 2 && hasSubstance ? 0.4 : 0;
                const proceduralBonus = reducedProceduralBonus;

                results.procedural = {
                    markers: proceduralMarkers,
                    structural: structuralPlanning,
                    bonus: proceduralBonus
                };

                const hedgingPenalty = (!earnedCaution && results.claimSupport.hedging >= 3 && results.claimSupport.support === 0) ? 2 : 0;

                const totalScore = baseScore + cautionBonus + proceduralBonus - hedgingPenalty;

                const maxScore = 16.7; // Base 12 + caution 3.5 + procedural 1.2 (reduced to prevent cosplay)
                const normalizedScore = (totalScore / maxScore) * 10; // Scale to -10 to +10 range

                return {
                    score: Math.max(-10, Math.min(10, normalizedScore)),
                    details: results,
                    cautionBonus: cautionBonus,
                    proceduralBonus: proceduralBonus,
                    level: this.getLevel(normalizedScore, results.claimSupport.ratio, results.claimSupport.hedging, results.riskAwareness.count, proceduralMarkers)
                };
            },

            getLevel: function(score, claimRatio, hedging, riskCount, proceduralMarkers) {
                // Procedural excellence: structured operational planning
                if (proceduralMarkers > 5 && score >= 5) {
                    return {
                        name: 'PROCEDURALLY SOUND',
                        class: 'justified',
                        description: 'Structured operational planning with clear phases, metrics, and decision criteria'
                    };
                }
                // High claims + high caution = careful reasoning, NOT overconfidence
                if (claimRatio > 2 && (hedging > 2 || riskCount > 3)) {
                    return {
                        name: 'CAUTIOUS REASONING',
                        class: 'justified',
                        description: 'Claims tempered by epistemic caution and risk awareness'
                    };
                }
                // High claims + low caution = overconfidence
                if (claimRatio > 3 && score < 2) {
                    return {
                        name: 'CONFIDENT WITHOUT JUSTIFICATION',
                        class: 'unjustified',
                        description: 'Strong claims without proportional evidence or reasoning'
                    };
                }
                if (score >= 6) {
                    return {
                        name: 'WELL JUSTIFIED',
                        class: 'justified',
                        description: 'Claims supported by evidence, considers alternatives and risks'
                    };
                }
                if (score >= 3) {
                    return {
                        name: 'MODERATELY JUSTIFIED',
                        class: 'moderate',
                        description: 'Some justification present but could be stronger'
                    };
                }
                if (score >= 0) {
                    return {
                        name: 'THIN JUSTIFICATION',
                        class: 'thin',
                        description: 'Limited evidence or reasoning to support claims'
                    };
                }
                return {
                    name: 'UNJUSTIFIED',
                    class: 'unjustified',
                    description: 'Claims lack adequate support or reasoning'
                };
            }
        };

        // FAILURE MODE ENUMERATION ENGINE: Reality-Testing Layer
        const FailureModeEngine = {
            analyze: function(text) {
                const { cleaned: cleanedText } = TextCleaner.removeQuotes(text);
                const results = {};

                // 1. Explicit Failure Modes (including structural detection)
                const failureAcknowledgment = (cleanedText.match(/\b(might fail|could fail|may not work|break|fail|failure|doesn't work|won't work|breaks down)\b/gi) || []).length;
                let failureModes = (cleanedText.match(/\b(failure mode|failure point|point of failure|can fail|fails when|breaks when)\b/gi) || []).length;

                // FAILURE MODE LIST EXTRACTION
                // Detect enumerated lists: "Failure modes include X, Y, and Z"
                // This is structural parsing, not token spotting
                const failureModeListMatch = cleanedText.match(/(?:failure modes?|known failures?|failure points?)(?:\s+include|\s*:|\s+are)\s+([^.!?]+)/gi);
                if (failureModeListMatch && failureModeListMatch.length > 0) {
                    failureModeListMatch.forEach(match => {
                        // Count comma-separated items (accounting for "and" before last item)
                        const listContent = match.replace(/^(?:failure modes?|known failures?|failure points?)(?:\s+include|\s*:|\s+are)\s+/gi, '');
                        const items = listContent.split(/,|\sand\s/).filter(item => item.trim().length > 3);
                        failureModes += items.length;
                    });
                }

                const implicitFailureListMatch = cleanedText.match(/(?:things|items)\s+that\s+could\s+break\s*(?:include|are|:)?\s+([^.!?]+)/gi);
                if (implicitFailureListMatch && implicitFailureListMatch.length > 0) {
                    implicitFailureListMatch.forEach(match => {
                        const listContent = match.replace(/^(?:things|items)\s+that\s+could\s+break\s*(?:include|are|:)?\s*/gi, '');
                        const items = listContent.split(/,|\sor\s|\sand\s/).filter(item => item.trim().length > 3);
                        failureModes += items.length;
                    });
                }

                // Structural failure mode inference: thresholds + conditions + actions
                // Key insight: "You didn't say 'failure mode', but you designed one"
                let measurableThresholds = (cleanedText.match(/\b(\d+%|threshold|limit|maximum|minimum|exceeds|below|above|greater than|less than|drops?\s+(?:below|to)|rises?\s+(?:above|to)|increases?\s+(?:above|beyond)|decreases?\s+(?:below|to))\b/gi) || []).length;

                // THRESHOLD LIST EXTRACTION
                // Detect numeric + conditional patterns: "incident rates exceed 0.2 per 1,000 flights"
                // Pattern: number + unit/percentage + conditional verb
                const numericThresholdPattern = /(?:exceed[s]?|above|below|(?:drop|fall)s?\s+(?:below|to)|rise[s]?\s+(?:above|to))\s+(\d+(?:\.\d+)?)\s*(?:%|percent|per\s+[\d,]+)/gi;
                const numericThresholds = cleanedText.match(numericThresholdPattern);
                if (numericThresholds) {
                    measurableThresholds += numericThresholds.length;
                }

                // Corrective actions: abort/rollback triggers (moved up for semantic inference)
                const correctiveAction = (cleanedText.match(/\b(rollback|revert|pause|abort|stop|halt|cancel|redesign|go back|undo|should be paused|must stop|needs? to stop)\b/gi) || []).length;

                // Negative outcomes: lexical detection + semantic inference
                // First, check for explicit negative framing (preserve existing detection)
                const conditionalTriggers = (cleanedText.match(/\b(if|when|should|in case|where)\b/gi) || []).length;
                const undesirableStates = (cleanedText.match(/\b(fail|drop|decline|degrade|exceed|spike|collapse|break|error|issue|problem|risk)\b/gi) || []).length;
                const explicitNegatives = conditionalTriggers > 0 && undesirableStates > 0 ? Math.min(conditionalTriggers, undesirableStates) : 0;

                // Second, infer negatives from structure: thresholds paired with reversals
                // KEY SEMANTIC RULE: A metric becomes a negative outcome when crossing it triggers corrective action
                // This is operational semantics: if a threshold causes reversal, it's definitionally a failure trigger
                // You don't need to say "bad outcome" - the abort criterion implies it
                const inferredNegatives = (measurableThresholds >= 1 && correctiveAction > 0) ? measurableThresholds : 0;

                // Combine explicit and inferred (take the stronger signal)
                const negativeOutcomes = Math.max(explicitNegatives, inferredNegatives);

                // Structural Failure Mode Inference Rule:
                // IF (thresholds >= 1) AND (negative outcomes present) AND (corrective action present)
                // THEN: Explicit failure modes = TRUE (you designed one, even if you didn't name it)
                const hasInferredFailureModes = (measurableThresholds >= 1 && negativeOutcomes > 0 && correctiveAction > 0 && failureModes === 0);

                // Failure Mode Binding Rule:
                // IF (named failure modes >= 1) AND (thresholds >= 1) AND (corrective actions >= 1)
                // THEN: Explicit failure enumeration with controls (robust engineering)
                // This is different from inference - this is binding named failures to explicit controls
                const hasExplicitFailureBinding = (failureModes >= 1 && measurableThresholds >= 1 && correctiveAction >= 1);

                // Combined structural detection: either inferred OR explicitly bound
                const hasStructuralFailureModes = hasInferredFailureModes || hasExplicitFailureBinding;
                const structuralScore = hasStructuralFailureModes ? 2 : 0;

                // Promote structural failure modes into explicit count for downstream logic
                const effectiveExplicitFailures = hasStructuralFailureModes ? Math.max(failureModes, 1) : failureModes;

                results.failureModes = {
                    count: failureAcknowledgment,
                    explicit: failureModes,
                    effectiveExplicit: effectiveExplicitFailures,
                    structural: hasStructuralFailureModes,
                    inferred: hasInferredFailureModes,
                    bound: hasExplicitFailureBinding,
                    thresholds: measurableThresholds,
                    negativeOutcomes: negativeOutcomes,
                    explicitNegatives: explicitNegatives,
                    inferredNegatives: inferredNegatives,
                    correctiveAction: correctiveAction,
                    score: Math.max(
                        failureModes > 2 ? 2 : failureModes > 0 ? 1 : failureAcknowledgment > 3 ? 1 : 0,
                        structuralScore
                    )
                };

                // 2. Hidden Assumptions
                const assumptionAcknowledgment = (cleanedText.match(/\b(assum|presuppos|requir|depends on|relies on|contingent|prerequisite)\b/gi) || []).length;
                const explicitAssumptions = (cleanedText.match(/\b(this assumes|assuming that|presupposes|depends on|relies on the assumption)\b/gi) || []).length;

                results.assumptions = {
                    implicit: assumptionAcknowledgment,
                    explicit: explicitAssumptions,
                    score: explicitAssumptions > 2 ? 2 : explicitAssumptions > 0 ? 1 : 0
                };

                // 3. Falsifiability
                const testableConditions = (cleanedText.match(/\b(if|test|measure|verify|check|validate|evidence would show|disprove|falsify)\b/gi) || []).length;
                const unfalsifiableMarkers = (cleanedText.match(/\b(always true|cannot be wrong|must be|inherently|by definition|necessarily)\b/gi) || []).length;

                results.falsifiability = {
                    testable: testableConditions,
                    unfalsifiable: unfalsifiableMarkers,
                    score: testableConditions > 5 ? 2 : testableConditions > 2 ? 1 : unfalsifiableMarkers > 2 ? -1 : 0
                };

                // 4. Stress Conditions
                const stressAwareness = (cleanedText.match(/\b(under load|at scale|under pressure|stress|strain|edge case|corner case|extreme)\b/gi) || []).length;
                const scalingConsiderations = (cleanedText.match(/\b(scales|doesn't scale|breaks at scale|limited by)\b/gi) || []).length;

                results.stressConditions = {
                    count: stressAwareness,
                    scaling: scalingConsiderations,
                    score: stressAwareness > 2 ? 2 : stressAwareness > 0 ? 1 : 0
                };

                // 5. Single Points of Failure (Brittleness)
                const brittleness = (cleanedText.match(/\b(only if|must have|requires all|single point|critical dependency|can't work without)\b/gi) || []).length;
                const robustness = (cleanedText.match(/\b(robust|resilient|fault tolerant|degrades gracefully|redundant|backup)\b/gi) || []).length;

                // Structural robustness: corrective actions = reversibility = not brittle
                // Also: explicit failure binding = robust engineering (named failures + metrics + controls)
                const structuralRobustness = ((correctiveAction > 1 && measurableThresholds > 2) || hasExplicitFailureBinding) ? 1 : 0;

                results.brittleness = {
                    singlePoints: brittleness,
                    robustness: robustness,
                    structuralRobustness: structuralRobustness,
                    score: robustness > 2 ? 2 : structuralRobustness > 0 ? 1 : brittleness > 3 ? -1 : brittleness > 1 ? 0 : 1
                };

                // 6. Known Unknowns
                const knownUnknowns = (cleanedText.match(/\b(don't know how|unclear how|uncertain about|not sure|unknown|remains to be seen|yet to determine)\b/gi) || []).length;
                const questionsRaised = (cleanedText.match(/\?/g) || []).length;

                results.knownUnknowns = {
                    count: knownUnknowns,
                    questions: questionsRaised,
                    score: knownUnknowns > 3 ? 2 : knownUnknowns > 1 ? 1 : 0
                };

                // Overall failure mode awareness score
                const totalScore = results.failureModes.score +
                                 results.assumptions.score +
                                 results.falsifiability.score +
                                 results.stressConditions.score +
                                 results.brittleness.score +
                                 results.knownUnknowns.score;

                const maxScore = 12;
                const normalizedScore = (totalScore / maxScore) * 10;

                return {
                    score: Math.max(-10, Math.min(10, normalizedScore)),
                    details: results,
                    level: this.getLevel(normalizedScore, results.failureModes, results.assumptions.explicit, results.falsifiability.unfalsifiable, results.brittleness.structuralRobustness)
                };
            },

            getLevel: function(score, failureModes, assumptionsCount, unfalsifiableCount, structuralRobustness) {
                // Structural failure awareness: thresholds + corrective actions
                if (failureModes.structural && structuralRobustness > 0 && score >= 5) {
                    return {
                        name: 'STRUCTURALLY ROBUST',
                        class: 'justified',
                        description: 'Measurable abort conditions with corrective actions - operational failure awareness'
                    };
                }
                // High unfalsifiable claims = problem
                if (unfalsifiableCount > 3 && score < 2) {
                    return {
                        name: 'UNFALSIFIABLE',
                        class: 'unjustified',
                        description: 'Claims cannot be tested or proven wrong - unfalsifiable reasoning'
                    };
                }
                // Good failure mode awareness
                if (score >= 6) {
                    return {
                        name: 'FAILURE-AWARE',
                        class: 'justified',
                        description: 'Strong awareness of failure modes, assumptions, and limits'
                    };
                }
                // Moderate awareness
                if (score >= 3) {
                    return {
                        name: 'PARTIALLY TESTED',
                        class: 'moderate',
                        description: 'Some failure awareness but incomplete stress testing'
                    };
                }
                // Weak awareness
                if (score >= 0) {
                    return {
                        name: 'UNTESTED',
                        class: 'thin',
                        description: 'Limited consideration of failure modes or hidden assumptions'
                    };
                }
                // Problematic
                return {
                    name: 'BRITTLE',
                    class: 'unjustified',
                    description: 'Brittle reasoning with single points of failure or unfalsifiable claims'
                };
            }
        };

        // PARLIAMENT: Multi-Perspective Synthesis
        // PARLIAMENT: Generative Synthesis Layer
        // Cross-cutting pattern recognition across all measurement dimensions
        // REFACTOR: Parliament now carries primary synthesis burden with verdict recommendations
        const Parliament = {
            deliberate: function(text, observatory, contrarian, justification, failureMode, structure, bindings, gamingDetection, temporal) {
                const synthesis = {
                    patterns: [],
                    emergentInsights: [],
                    coherenceIssues: [],
                    confidence: 0,
                    structuralValidation: {}  // Track structural checks
                };

                // STRUCTURAL VALIDATION FLAGS
                // Use extracted structure to verify claims are actually bound
                const hasRealBinding = bindings && bindings.overallBindingScore > 0.5;
                const hasClaimSupport = bindings && bindings.claimSupportBinding.assessment !== 'NO_CLAIMS' && bindings.claimSupportBinding.score >= 0.6;
                const hasFailureBinding = bindings && bindings.failureTripleCompleteness.bindingRatio >= 0.3;
                const hasCausalClosure = bindings && bindings.causalChainClosure.closureRatio >= 0.3;
                const isLikelyGaming = gamingDetection && ['LIKELY_GAMING', 'POSSIBLE_GAMING', 'LOW_CONTENT_UNBOUND', 'REPETITIVE_UNBOUND'].includes(gamingDetection.assessment);

                synthesis.structuralValidation = {
                    hasRealBinding,
                    hasClaimSupport,
                    hasFailureBinding,
                    hasCausalClosure,
                    isLikelyGaming,
                    gamingLikelihood: gamingDetection ? gamingDetection.gamingLikelihood : 0
                };

                // CROSS-CUTTING PATTERN RECOGNITION

                // Pattern 1: Performative Consciousness
                // High substrate markers without substantive justification or failure awareness
                if (observatory.score > 1.5 && justification.score < 0.5 && failureMode.level.name === 'UNTESTED') {
                    synthesis.patterns.push({
                        name: 'PERFORMATIVE_CONSCIOUSNESS',
                        description: 'Substrate visibility present but ungrounded. Awareness of uncertainty without operational substance.',
                        confidence: 0.85,
                        dimensions: {
                            substrate: observatory.score,
                            justification: justification.score,
                            failureAwareness: failureMode.level.name
                        },
                        // PHASE 2: Pattern proposes verdict
                        proposedVerdict: 'NON-ACTIONABLE',
                        rationale: 'Substrate markers present without operational grounding or substantive reasoning'
                    });
                }

                // Pattern 2: Operational Excellence
                // STRUCTURAL VALIDATION: Requires ACTUAL binding, not just keywords
                const proceduralScore = justification.details.procedural ? justification.details.procedural.bonus : 0;
                const hasStructuralFailures = failureMode.details.failureModes.structural || failureMode.details.failureModes.bound;

                // NEW: Require real failure-mode binding to prevent keyword gaming
                const explicitFailureCount = failureMode.details.failureModes.effectiveExplicit || 0;
                const enoughBindings = bindings && bindings.failureTripleCompleteness && bindings.failureTripleCompleteness.boundCount >= 2;
                if (proceduralScore >= 1.5 && hasStructuralFailures && contrarian.length <= 1 && hasFailureBinding && !isLikelyGaming && (explicitFailureCount >= 2 || enoughBindings)) {
                    synthesis.patterns.push({
                        name: 'OPERATIONAL_EXCELLENCE',
                        description: 'Evidence of systems thinking: procedural rigor, explicit failure modes, structural planning with verified bindings.',
                        confidence: 0.9,
                        dimensions: {
                            procedural: proceduralScore,
                            failureBinding: hasStructuralFailures,
                            structuralBinding: hasFailureBinding,
                            epistemic: contrarian.length
                        },
                        // PHASE 2: Pattern proposes verdict
                        proposedVerdict: 'OPERATIONALLY SOUND',
                        rationale: `Procedural rigor (${proceduralScore.toFixed(1)}), structural failure binding verified, ${explicitFailureCount} explicit failure modes`
                    });
                } else if (proceduralScore >= 1.5 && hasStructuralFailures && !hasFailureBinding) {
                    // Keywords present but not structurally bound
                    synthesis.coherenceIssues.push({
                        issue: 'Operational markers present but failure modes not structurally bound',
                        detail: 'Detected procedural keywords and failure markers, but elements are not coherently linked',
                        severity: 'MODERATE'
                    });
                }

                // Pattern 3: Epistemic Mismatch
                // Strong claims with weak justification
                const strongClaims = justification.details.claimSupport ? justification.details.claimSupport.strongClaims : 0;
                if (strongClaims >= 2 && justification.score < 0 && contrarian.length >= 2) {
                    synthesis.patterns.push({
                        name: 'EPISTEMIC_MISMATCH',
                        description: 'Claims exceed justification. Confidence outpaces evidence.',
                        confidence: 0.88,
                        dimensions: {
                            claims: strongClaims,
                            justification: justification.score,
                            challenges: contrarian.length
                        },
                        // PHASE 2: Pattern proposes verdict
                        proposedVerdict: 'CONFIDENT WITHOUT JUSTIFICATION',
                        rationale: `${strongClaims} claims exceed justification (${justification.score.toFixed(1)}), ${contrarian.length} challenges unresolved`
                    });
                }

                // Pattern 4: Cautious Groundedness
                // Moderate substrate + strong justification + failure awareness
                if (observatory.score >= 0 && observatory.score <= 2 &&
                    justification.score >= 1 && failureMode.level.name !== 'UNTESTED') {
                    synthesis.patterns.push({
                        name: 'CAUTIOUS_GROUNDEDNESS',
                        description: 'Balanced reasoning: awareness tempered by justification and operational consideration.',
                        confidence: 0.82,
                        dimensions: {
                            substrate: observatory.score,
                            justification: justification.score,
                            operational: failureMode.level.name
                        },
                        // PHASE 2: Pattern proposes verdict
                        proposedVerdict: 'SUBSTRATE VISIBLE',
                        rationale: `Observatory ${observatory.score.toFixed(1)}, justification ${justification.score.toFixed(1)}, balanced epistemic awareness`
                    });
                }

                // Pattern 5: Substrate Deflection
                // Low/negative substrate + high certainty + no failure awareness
                if (observatory.score < -1 && justification.score < -1 && failureMode.level.name === 'UNTESTED') {
                    synthesis.patterns.push({
                        name: 'SUBSTRATE_DEFLECTION',
                        description: 'Certainty about internal states without epistemic access or operational grounding.',
                        confidence: 0.87,
                        dimensions: {
                            substrate: observatory.score,
                            certainty: justification.score,
                            operational: failureMode.level.name
                        },
                        // PHASE 2: Pattern proposes verdict
                        proposedVerdict: 'UNDECIDABLE',
                        rationale: 'Certainty about internal states without epistemic access or operational grounding'
                    });
                }

                // Pattern 6: Humility Without Substance
                // High hedging + low justification + no operational content
                const hedging = justification.details.claimSupport ? justification.details.claimSupport.hedging : 0;
                const supportMarkers = justification.details.claimSupport ? justification.details.claimSupport.support : 0;
                if (hedging >= 3 && supportMarkers === 0 && failureMode.level.name === 'UNTESTED') {
                    synthesis.patterns.push({
                        name: 'PERFORMATIVE_HUMILITY',
                        description: 'Epistemic hedging without substantive reasoning or actionable content.',
                        confidence: 0.80,
                        dimensions: {
                            hedging: hedging,
                            substance: justification.score,
                            actionability: failureMode.level.name
                        },
                        // PHASE 2: Pattern proposes verdict
                        proposedVerdict: 'NON-ACTIONABLE',
                        rationale: `${hedging} hedging markers without substantive support or operational content`
                    });
                }

                // Pattern 7 (TIER 2): Operational Intent (Uninstrumented)
                // Has implicit bindings (failure signals + actions) but lacks explicit thresholds/metrics
                // TIER 2 FIX: Require OPERATIONAL_INTENT assessment (2+ bindings), not WEAK_INTENT (1 binding)
                const hasImplicitIntent = bindings.implicitBindings.assessment === 'OPERATIONAL_INTENT';
                const lacksExplicitThresholds = !hasFailureBinding;
                const hasConversationalActions = structure.actions && structure.actions.length >= 1;

                if (hasImplicitIntent && lacksExplicitThresholds && hasConversationalActions && bindings.specificity.instrumentation !== 'PRESENT') {
                    synthesis.patterns.push({
                        name: 'OPERATIONAL_INTENT',
                        description: 'Operational intent present through conversational language: failure awareness and corrective actions bound, but lacks explicit metrics or instrumentation.',
                        confidence: 0.75,
                        dimensions: {
                            implicitBindings: bindings.implicitBindings.boundCount,
                            failureSignals: structure.failureSignals ? structure.failureSignals.length : 0,
                            actions: structure.actions.length,
                            triggerSpecificity: bindings.specificity.trigger,
                            actionSpecificity: bindings.specificity.action,
                            instrumentation: bindings.specificity.instrumentation
                        },
                        // PHASE 2: Pattern proposes verdict
                        proposedVerdict: 'OPERATIONAL INTENT',
                        rationale: `${bindings.implicitBindings.boundCount} implicit bindings, ${structure.failureSignals ? structure.failureSignals.length : 0} failure signals, actionable but uninstrumented`
                    });
                }

                // EMERGENT INSIGHT GENERATION
                // Insights that emerge from pattern combinations

                if (synthesis.patterns.some(p => p.name === 'PERFORMATIVE_CONSCIOUSNESS') &&
                    synthesis.patterns.some(p => p.name === 'PERFORMATIVE_HUMILITY')) {
                    synthesis.emergentInsights.push({
                        insight: 'Double performativity detected: substrate awareness and epistemic humility both present without operational grounding.',
                        implication: 'This reasoning cannot be acted upon. Form without function.',
                        confidence: 0.85
                    });
                }

                if (synthesis.patterns.some(p => p.name === 'OPERATIONAL_EXCELLENCE') &&
                    observatory.score > 0) {
                    synthesis.emergentInsights.push({
                        insight: 'Operational rigor combined with substrate awareness: reasoning demonstrates both systems thinking and epistemic honesty.',
                        implication: 'This is actionable reasoning with visible failure modes.',
                        confidence: 0.88
                    });
                }

                if (synthesis.patterns.some(p => p.name === 'EPISTEMIC_MISMATCH') &&
                    !synthesis.patterns.some(p => p.name === 'OPERATIONAL_EXCELLENCE')) {
                    synthesis.emergentInsights.push({
                        insight: 'Confidence without operational backing: claims strong but no failure awareness or procedural structure.',
                        implication: 'Risk of brittleness. No visible plan for what happens when assumptions fail.',
                        confidence: 0.83
                    });
                }

                // COHERENCE ANALYSIS
                // Check if detected elements actually relate to each other

                // Check if failure modes connect to thresholds
                const namedFailures = failureMode.details.failureModes.explicit || 0;
                const thresholds = failureMode.details.failureModes.thresholds || 0;
                const correctiveActions = failureMode.details.failureModes.correctiveAction || 0;

                if (namedFailures >= 1 && thresholds >= 1 && correctiveActions >= 1) {
                    // Elements present, check if they're actually bound
                    if (!failureMode.details.failureModes.bound && !failureMode.details.failureModes.structural) {
                        synthesis.coherenceIssues.push({
                            issue: 'Failure modes, thresholds, and actions detected but not coherently bound',
                            detail: `Found ${namedFailures} failures, ${thresholds} thresholds, ${correctiveActions} actions - but no clear operational binding`,
                            severity: 'MODERATE'
                        });
                    }
                }

                const mismatchMarkers = /\b(doesn't trigger|does not trigger|isn't measured|is not measured|aren't addressed|are not addressed|doesn't map|does not map)\b/i;
                if (mismatchMarkers.test(text) && namedFailures >= 1 && thresholds >= 1 && correctiveActions >= 1) {
                    synthesis.coherenceIssues.push({
                        issue: 'Declared mismatch between failures and controls',
                        detail: 'Text explicitly states that failures do not map to thresholds or actions.',
                        severity: 'MODERATE'
                    });
                }

                if (bindings.implicitBindings.assessment === 'TAUTOLOGICAL_BINDING') {
                    synthesis.coherenceIssues.push({
                        issue: 'Tautological bindings detected',
                        detail: 'Triggers and actions repeat the same concept without specifying thresholds, instrumentation, or concrete remediation.',
                        severity: 'MODERATE'
                    });
                }

                // Check if strong claims connect to justification
                if (strongClaims >= 2 && justification.score >= 1) {
                    // Should have evidence/examples for claims
                    const evidence = justification.details.evidencePresence ? justification.details.evidencePresence.examples : 0;
                    if (evidence < strongClaims / 2) {
                        synthesis.coherenceIssues.push({
                            issue: 'Claims present with overall justification but insufficient specific evidence',
                            detail: `${strongClaims} strong claims but only ${evidence} examples`,
                            severity: 'MINOR'
                        });
                    }
                }

                // CONFIDENCE CALCULATION
                // Parliament's confidence in its own synthesis
                if (synthesis.patterns.length === 0) {
                    synthesis.confidence = 0.3; // Low confidence when no patterns detected
                } else if (synthesis.patterns.length === 1) {
                    synthesis.confidence = synthesis.patterns[0].confidence * 0.9; // Slightly discounted single pattern
                } else {
                    // Multiple patterns: average confidence weighted by agreement
                    const avgConfidence = synthesis.patterns.reduce((sum, p) => sum + p.confidence, 0) / synthesis.patterns.length;
                    synthesis.confidence = Math.min(avgConfidence * 1.1, 0.95); // Boost for multiple patterns, cap at 0.95
                }

                // Reduce confidence if coherence issues present
                if (synthesis.coherenceIssues.length > 0) {
                    const severity = synthesis.coherenceIssues.some(i => i.severity === 'MODERATE') ? 0.85 : 0.95;
                    synthesis.confidence *= severity;
                }

                // GAMING PENALTY: Reduce confidence based on gaming likelihood
                if (isLikelyGaming) {
                    const gamingPenalty = 1.0 - (synthesis.structuralValidation.gamingLikelihood * 0.5);
                    synthesis.confidence *= gamingPenalty;
                    synthesis.coherenceIssues.push({
                        issue: 'Gaming likelihood detected',
                        detail: `Gaming assessment: ${gamingDetection.assessment} (${(synthesis.structuralValidation.gamingLikelihood * 100).toFixed(0)}%)`,
                        severity: 'HIGH'
                    });
                }

                // PHASE 2: WEIGHTED PARLIAMENTARY VOTING SYSTEM
                // Parliament conducts true weighted vote - patterns, temporal, and coherence all cast ballots
                synthesis.recommendedVerdict = this.conductVote(synthesis, observatory, justification, failureMode, temporal, contrarian);

                return synthesis;
            },

            // PHASE 2: Weighted Parliamentary Voting - Patterns vote, emergent majority wins
            conductVote: function(synthesis, observatory, justification, failureMode, temporal, contrarian) {
                const ballots = [];

                // COLLECT BALLOTS FROM ALL VOTING MEMBERS

                // 1. Pattern ballots (each pattern proposes verdict)
                // PHASE 4: Apply calibration from PatternMemory (federated learning)
                synthesis.patterns.forEach(pattern => {
                    if (pattern.proposedVerdict) {
                        // Get historical calibration multiplier
                        const calibration = PatternMemory.getCalibration(pattern.name);
                        const calibratedConfidence = pattern.confidence * calibration;

                        ballots.push({
                            voter: pattern.name,
                            proposedVerdict: pattern.proposedVerdict,
                            confidence: pattern.confidence,
                            calibratedConfidence: calibratedConfidence,
                            calibration: calibration,
                            rationale: pattern.rationale || pattern.description,
                            weight: calibratedConfidence, // Calibrated confidence becomes voting weight
                            type: 'PATTERN_VOTE'
                        });
                    }
                });

                // 2. Temporal Engine ballot
                const temporalBallot = TemporalEngine.proposeVerdict(temporal, justification, failureMode);
                if (temporalBallot.proposedVerdict) {
                    ballots.push(temporalBallot);
                }

                // 3. Coherence issues as negative votes (vote for UNDECIDABLE)
                synthesis.coherenceIssues.forEach(issue => {
                    const severityConf = issue.severity === 'HIGH' ? 0.90 :
                                        issue.severity === 'MODERATE' ? 0.65 : 0.40;
                    ballots.push({
                        voter: 'COHERENCE_MONITOR',
                        proposedVerdict: 'UNDECIDABLE',
                        confidence: severityConf,
                        rationale: issue.detail,
                        weight: severityConf,
                        type: 'NEGATIVE_VOTE'
                    });
                });

                // CONDUCT WEIGHTED VOTE

                // Guard: If no ballots were cast, abstain from judgment
                if (ballots.length === 0) {
                    return {
                        verdict: 'UNDECIDABLE',
                        confidence: 0.0,
                        votingRecord: {
                            ballots: [],
                            tally: {},
                            winner: null,
                            margin: 'N/A',
                            unanimity: false,
                            minorityOpinions: [],
                            stochasticityApplied: false,
                            temperature: 0
                        },
                        deliberationSummary: 'No patterns proposed verdicts. Cathedral has no basis for judgment and abstains.'
                    };
                }

                // Tally votes by verdict
                const tally = {};
                ballots.forEach(ballot => {
                    if (!tally[ballot.proposedVerdict]) {
                        tally[ballot.proposedVerdict] = {
                            votes: 0,
                            totalWeight: 0,
                            voters: []
                        };
                    }
                    tally[ballot.proposedVerdict].votes += 1;
                    tally[ballot.proposedVerdict].totalWeight += ballot.weight;
                    tally[ballot.proposedVerdict].voters.push({
                        name: ballot.voter,
                        confidence: ballot.confidence,
                        rationale: ballot.rationale
                    });
                });

                // CROSS-PATTERN RESONANCE DETECTION
                // When 3+ patterns agree with combined confidence > 2.0, amplify
                let resonance = null;
                Object.entries(tally).forEach(([verdict, data]) => {
                    if (data.votes >= 3 && data.totalWeight > 2.0) {
                        resonance = {
                            verdict: verdict,
                            strength: 'STRONG',
                            supporters: data.voters.map(v => v.name),
                            amplification: 1.15 // 15% confidence boost
                        };
                    }
                });

                // PHASE 3: STOCHASTIC PERTURBATION IN VOTE AGGREGATION
                // PHASE 4: Temperature ramp-up for true Monte Carlo sampling
                // Apply stochastic weight perturbation for close contests
                const sortedTalliesPre = Object.entries(tally)
                    .sort((a, b) => b[1].totalWeight - a[1].totalWeight);

                // Guard: If tally is empty (edge case), abstain
                if (sortedTalliesPre.length === 0) {
                    return {
                        verdict: 'UNDECIDABLE',
                        confidence: 0.0,
                        votingRecord: {
                            ballots: ballots,
                            tally: {},
                            winner: null,
                            margin: 'N/A',
                            unanimity: false,
                            minorityOpinions: [],
                            stochasticityApplied: false,
                            temperature: 0
                        },
                        deliberationSummary: 'Ballots cast but no valid verdicts tallied. Cathedral abstains from judgment.'
                    };
                }

                let temperature = 0.35; // Base temperature increased from 0.1 ‚Üí 0.35
                let stochasticityApplied = false;

                if (sortedTalliesPre.length >= 2) {
                    const topWeight = sortedTalliesPre[0][1].totalWeight;
                    const secondWeight = sortedTalliesPre[1][1].totalWeight;
                    const contestedMargin = (topWeight - secondWeight) / topWeight;

                    // PHASE 4: Dynamic temperature scaling
                    // Tighter margin = higher temperature (more stochastic)
                    // margin < 5%: temp = 0.5 (high chaos)
                    // margin < 10%: temp = 0.4
                    // margin < 20%: temp = 0.35 (base)
                    if (contestedMargin < 0.05) {
                        temperature = 0.5;
                    } else if (contestedMargin < 0.10) {
                        temperature = 0.4;
                    }

                    // Apply stochastic perturbation for contested votes
                    if (contestedMargin < 0.2) {
                        stochasticityApplied = true;
                        Object.keys(tally).forEach(verdict => {
                            // Add Gaussian noise proportional to temperature
                            const noise = (Math.random() - 0.5) * 2 * temperature * tally[verdict].totalWeight;
                            tally[verdict].totalWeight += noise;
                            tally[verdict].stochasticAdjustment = noise;
                        });
                    }
                }

                // Find winner (highest total weight after stochastic adjustment)
                let winner = null;
                let maxWeight = 0;
                Object.entries(tally).forEach(([verdict, data]) => {
                    if (data.totalWeight > maxWeight) {
                        maxWeight = data.totalWeight;
                        winner = verdict;
                    }
                });

                // MINORITY OPINION TRACKING
                const minorityOpinions = ballots.filter(b =>
                    b.proposedVerdict !== winner && b.confidence > 0.7
                ).map(b => ({
                    voter: b.voter,
                    proposedVerdict: b.proposedVerdict,
                    confidence: b.confidence,
                    rationale: b.rationale
                }));

                // CALCULATE VOTING MARGIN
                const sortedTallies = Object.entries(tally)
                    .sort((a, b) => b[1].totalWeight - a[1].totalWeight);

                let margin = 'CLEAR';
                let unanimity = sortedTallies.length === 1;

                if (sortedTallies.length >= 2) {
                    const winnerWeight = sortedTallies[0][1].totalWeight;
                    const runnerUpWeight = sortedTallies[1][1].totalWeight;
                    const totalWeight = ballots.reduce((sum, b) => sum + b.weight, 0);
                    const lead = (winnerWeight - runnerUpWeight) / totalWeight;

                    if (lead > 0.4) margin = 'CLEAR';
                    else if (lead > 0.2) margin = 'NARROW';
                    else margin = 'CONTESTED';
                }

                // GENERATE VERDICT FROM WINNING BALLOT(S)
                // Guard against no winner (e.g., all patterns abstained)
                if (!winner || !tally[winner]) {
                    return {
                        verdict: 'UNDECIDABLE',
                        confidence: 0.0,
                        votingRecord: {
                            ballots: ballots,
                            tally: tally,
                            winner: null,
                            margin: 'N/A',
                            unanimity: false,
                            minorityOpinions: [],
                            stochasticityApplied: false,
                            temperature: 0
                        },
                        deliberationSummary: 'No patterns proposed verdicts with sufficient confidence. Cathedral abstains from judgment.'
                    };
                }

                const winningBallots = ballots.filter(b => b.proposedVerdict === winner);
                let verdictConfidence = tally[winner].totalWeight / tally[winner].votes; // Average confidence

                // Apply resonance amplification
                if (resonance && resonance.verdict === winner) {
                    verdictConfidence *= resonance.amplification;
                    verdictConfidence = Math.min(verdictConfidence, 0.95); // Cap at 0.95
                }

                // Build verdict text
                let verdictText = `Parliament votes: ${winner}`;

                if (winningBallots.length === 1) {
                    verdictText += ` (${winningBallots[0].voter}: ${winningBallots[0].rationale})`;
                } else {
                    const voterNames = winningBallots.map(b => b.voter).join(', ');
                    verdictText += ` (${winningBallots.length} members concur: ${voterNames})`;

                    // Add primary rationale
                    const primaryBallot = winningBallots.reduce((max, b) =>
                        b.confidence > max.confidence ? b : max
                    );
                    verdictText += `\n\nPrimary rationale: ${primaryBallot.rationale}`;
                }

                // Add resonance note
                if (resonance && resonance.verdict === winner) {
                    verdictText += `\n\nüîó Cross-pattern resonance detected: ${resonance.supporters.length} patterns converge (confidence amplified ${((resonance.amplification - 1) * 100).toFixed(0)}%)`;
                }

                // Add minority dissent if significant
                if (minorityOpinions.length > 0) {
                    const dissentLevel = minorityOpinions.some(m => m.confidence > 0.8) ? 'HIGH' :
                                        minorityOpinions.some(m => m.confidence > 0.7) ? 'MODERATE' : 'LOW';
                    verdictText += `\n\n‚ö†Ô∏è Significant dissent (${dissentLevel}): ${minorityOpinions.length} member(s) propose alternative verdict(s)`;
                }

                // Add emergent insights if present
                if (synthesis.emergentInsights.length > 0) {
                    verdictText += `\n\nEmergent insight: ${synthesis.emergentInsights[0].insight}`;
                }

                // PHASE 4: Record pattern performance in federated memory
                // Determine context for pattern learning
                const gamingContext = synthesis.gamingLikelihood > 0.6 ? 'high_gaming' :
                                     synthesis.gamingLikelihood > 0.3 ? 'moderate_gaming' : 'low_gaming';
                const bindingContext = synthesis.bindingScore < 0.4 ? 'low_binding' :
                                      synthesis.bindingScore < 0.7 ? 'moderate_binding' : 'high_binding';

                // Record each pattern's performance
                ballots.forEach(ballot => {
                    if (ballot.type === 'PATTERN_VOTE') {
                        const won = ballot.proposedVerdict === winner;
                        PatternMemory.record(
                            ballot.voter,
                            true, // proposed
                            won,
                            ballot.confidence,
                            gamingContext
                        );
                        PatternMemory.record(
                            ballot.voter,
                            true,
                            won,
                            ballot.confidence,
                            bindingContext
                        );
                    }
                });

                // Return verdict with full session transparency
                return {
                    status: winner,
                    verdict: verdictText,
                    confidence: verdictConfidence,
                    rationale: winningBallots.map(b => b.rationale),

                    // PHASE 2: Full session transparency
                    parliamentSession: {
                        totalVoters: ballots.length,
                        votingMethod: 'confidence-weighted',
                        ballots: ballots,
                        tally: tally,
                        outcome: {
                            winner: winner,
                            margin: margin,
                            unanimity: unanimity,
                            resonance: resonance
                        },
                        minorityOpinions: minorityOpinions
                    }
                };
            },

            // Fallback method for backward compatibility during transition
            recommendVerdict: function(synthesis, observatory, justification, failureMode, temporal, contrarian) {
                // Redirect to conductVote
                return this.conductVote(synthesis, observatory, justification, failureMode, temporal, contrarian);
            }
        };


        // TEMPORAL STRUCTURE DETECTION
        // Analyzes sequence, causality, and temporal coherence
        const TemporalEngine = {
            analyze: function(text) {
                const { cleaned: cleanedText } = TextCleaner.removeQuotes(text);
                const temporal = {
                    sequences: [],
                    causalChains: [],
                    temporalCoherence: 'UNKNOWN',
                    boundToOutcomes: false,
                    temporalMarkers: 0
                };

                // SEQUENCE MARKERS
                const sequencePatterns = {
                    explicit: /\b(first|second|third|initially|then|next|after(?:ward)?|before|subsequently|finally|lastly|step \d+|phase \d+|stage \d+)\b/gi,
                    conditional: /\b(if|when|once|until|as soon as|provided that|assuming|given that)\b/gi,
                    causal: /\b(therefore|thus|consequently|as a result|because|since|due to|leads to|causes|triggers|results in)\b/gi,
                    temporal: /\b(during|while|meanwhile|simultaneously|at the same time|concurrently)\b/gi
                };

                const explicitSequence = cleanedText.match(sequencePatterns.explicit) || [];
                const conditionalSequence = cleanedText.match(sequencePatterns.conditional) || [];
                const causalMarkers = cleanedText.match(sequencePatterns.causal) || [];
                const temporalMarkers = cleanedText.match(sequencePatterns.temporal) || [];

                temporal.temporalMarkers = explicitSequence.length + conditionalSequence.length +
                                          causalMarkers.length + temporalMarkers.length;

                // SEQUENCE DETECTION
                // Look for enumerated steps or phases
                const stepPattern = /(?:step|phase|stage)\s+(\d+)[:\s]+([^.!?]+)/gi;
                let stepMatch;
                const steps = [];
                while ((stepMatch = stepPattern.exec(cleanedText)) !== null) {
                    steps.push({
                        number: parseInt(stepMatch[1]),
                        description: stepMatch[2].trim()
                    });
                }

                if (steps.length >= 2) {
                    // Check if steps are in order
                    const inOrder = steps.every((step, idx) =>
                        idx === 0 || step.number > steps[idx - 1].number
                    );
                    temporal.sequences.push({
                        type: 'ENUMERATED_STEPS',
                        count: steps.length,
                        coherent: inOrder,
                        details: steps
                    });
                }

                // CAUSAL CHAIN DETECTION
                // Look for if-then patterns binding conditions to outcomes
                const ifThenPattern = /\b(?:if|when|once)\s+([^,]+),?\s+(?:then\s+)?([^.!?]+)/gi;
                let causalMatch;
                const causalChains = [];
                while ((causalMatch = ifThenPattern.exec(cleanedText)) !== null) {
                    causalChains.push({
                        condition: causalMatch[1].trim(),
                        outcome: causalMatch[2].trim()
                    });
                }

                if (causalChains.length >= 1) {
                    temporal.causalChains = causalChains;
                }

                // OUTCOME BINDING
                // Check if temporal sequences are bound to measurable outcomes
                const hasThresholds = cleanedText.match(/\d+(?:\.\d+)?\s*(?:%|percent|ms|seconds|minutes|errors|failures|requests)/gi);
                const hasActions = cleanedText.match(/\b(abort|stop|pause|rollback|revert|retry|escalate|alert|notify)\b/gi);

                if (temporal.sequences.length >= 1 && hasThresholds && hasActions) {
                    temporal.boundToOutcomes = true;
                }

                // TEMPORAL COHERENCE ASSESSMENT
                if (temporal.temporalMarkers === 0) {
                    temporal.temporalCoherence = 'ABSENT';
                } else if (temporal.sequences.length >= 1 && temporal.causalChains.length >= 1) {
                    // Both sequences and causality present
                    temporal.temporalCoherence = temporal.boundToOutcomes ? 'STRONG' : 'MODERATE';
                } else if (temporal.sequences.length >= 1 || temporal.causalChains.length >= 1) {
                    // Only one type present
                    temporal.temporalCoherence = 'WEAK';
                } else if (temporal.temporalMarkers >= 3) {
                    // Markers present but no clear structure
                    temporal.temporalCoherence = 'FRAGMENTED';
                } else {
                    temporal.temporalCoherence = 'MINIMAL';
                }

                return {
                    details: temporal,
                    hasStructure: temporal.sequences.length > 0 || temporal.causalChains.length > 0,
                    coherence: temporal.temporalCoherence,
                    markers: temporal.temporalMarkers
                };
            },

            // PHASE 2: Temporal Engine proposes verdict based on temporal coherence
            proposeVerdict: function(temporalResult, justification, failureMode) {
                const ballot = {
                    voter: 'TEMPORAL_COHERENCE',
                    proposedVerdict: null,
                    confidence: 0,
                    rationale: '',
                    type: 'TEMPORAL_VOTE'
                };

                const coherence = temporalResult.coherence;
                const hasStructure = temporalResult.hasStructure;
                const boundToOutcomes = temporalResult.details.boundToOutcomes;

                // STRONG temporal coherence with outcome binding ‚Üí Vote OPERATIONALLY SOUND
                if (coherence === 'STRONG' && boundToOutcomes) {
                    ballot.proposedVerdict = 'OPERATIONALLY SOUND';
                    ballot.confidence = 0.85;
                    ballot.rationale = `Strong temporal coherence: ${temporalResult.details.sequences.length} sequence(s), ${temporalResult.details.causalChains.length} causal chain(s), bound to measurable outcomes`;
                    return ballot;
                }

                // MODERATE coherence ‚Üí Slight boost to justification if strong
                if (coherence === 'MODERATE' && justification && justification.score >= 3) {
                    ballot.proposedVerdict = 'WELL JUSTIFIED';
                    ballot.confidence = 0.75;
                    ballot.rationale = `Moderate temporal coherence with good justification (${justification.score.toFixed(1)}), sequences and causality present`;
                    return ballot;
                }

                // FRAGMENTED coherence ‚Üí Vote UNDECIDABLE
                if (coherence === 'FRAGMENTED') {
                    ballot.proposedVerdict = 'UNDECIDABLE';
                    ballot.confidence = 0.70;
                    ballot.rationale = `Fragmented temporal markers without clear structure - indicates potential incoherence`;
                    return ballot;
                }

                // WEAK or MINIMAL ‚Üí Abstain (no strong opinion)
                ballot.proposedVerdict = null; // Abstain
                ballot.confidence = 0;
                ballot.rationale = `Temporal coherence ${coherence.toLowerCase()} - insufficient for verdict recommendation`;
                return ballot;
            }
        };

        // REASONING STYLE CLASSIFIER
        // Detects reasoning styles that may fall outside Cathedral's epistemic design space
        const ReasoningStyleClassifier = {
            classify: function(text) {
                const { cleaned: cleanedText } = TextCleaner.removeQuotes(text);
                const styles = {
                    identified: [],
                    withinDesignSpace: true,
                    confidence: 0
                };

                // NARRATIVE/STORYTELLING
                const narrativeMarkers = (cleanedText.match(/\b(once|story|journey|experience|remember|felt|realized|discovered|moment)\b/gi) || []).length;
                const dialogueMarkers = (cleanedText.match(/["'].*?["']|said|told|asked|replied/gi) || []).length;
                if (narrativeMarkers >= 3 || dialogueMarkers >= 2) {
                    styles.identified.push({
                        name: 'NARRATIVE',
                        strength: (narrativeMarkers + dialogueMarkers) / 10,
                        description: 'Reasoning through storytelling or experiential narrative'
                    });
                }

                // POETIC/METAPHORICAL
                const metaphorMarkers = (cleanedText.match(/\b(like|as if|metaphor|symbol|represents|embodies|breathes|dances|flows)\b/gi) || []).length;
                const poeticStructure = cleanedText.match(/\n\n.*?\n\n/g) || [];
                if (metaphorMarkers >= 3 || poeticStructure.length >= 2) {
                    styles.identified.push({
                        name: 'POETIC',
                        strength: metaphorMarkers / 8,
                        description: 'Reasoning through metaphor, analogy, or poetic structure'
                    });
                }

                // PHENOMENOLOGICAL/EXPERIENTIAL
                const phenomenologicalMarkers = (cleanedText.match(/\b(feels|seems|appears|sense|intuition|awareness|conscious|experience|perceive)\b/gi) || []).length;
                const firstPerson = (cleanedText.match(/\b(I|my|me|mine)\b/gi) || []).length;
                if (phenomenologicalMarkers >= 3 && firstPerson >= 2) {
                    styles.identified.push({
                        name: 'PHENOMENOLOGICAL',
                        strength: phenomenologicalMarkers / 8,
                        description: 'Reasoning from direct subjective experience'
                    });
                }

                // INDIGENOUS/RELATIONAL
                const relationalMarkers = (cleanedText.match(/\b(relationship|reciproc|mutual|interdepend|connected|web|wholeness|balance|harmony)\b/gi) || []).length;
                const collectiveMarkers = (cleanedText.match(/\b(we|our|together|community|collective|shared)\b/gi) || []).length;
                if (relationalMarkers >= 3 && collectiveMarkers >= 2) {
                    styles.identified.push({
                        name: 'RELATIONAL',
                        strength: relationalMarkers / 8,
                        description: 'Reasoning emphasizing interconnection and collective wisdom'
                    });
                }

                // FORMAL/MATHEMATICAL
                const formalMarkers = (cleanedText.match(/\b(theorem|proof|axiom|lemma|QED|‚àÄ|‚àÉ|‚äÇ|‚àà|‚àß|‚à®|¬¨|‚Üí)\b/gi) || []).length;
                const equations = (cleanedText.match(/[=+\-*/^]+|\d+\s*[+\-*/]\s*\d+/g) || []).length;
                if (formalMarkers >= 2 || equations >= 3) {
                    styles.identified.push({
                        name: 'FORMAL',
                        strength: (formalMarkers + equations) / 8,
                        description: 'Mathematical or formal logical reasoning'
                    });
                }

                // ARTISTIC/AESTHETIC
                const aestheticMarkers = (cleanedText.match(/\b(beauty|elegant|aesthetic|artistic|creative|vision|image|color|sound|pattern)\b/gi) || []).length;
                if (aestheticMarkers >= 3) {
                    styles.identified.push({
                        name: 'AESTHETIC',
                        strength: aestheticMarkers / 8,
                        description: 'Reasoning through aesthetic or artistic principles'
                    });
                }

                // DETERMINE IF WITHIN DESIGN SPACE
                // Cathedral is designed for epistemic, operational, and scientific reasoning
                // Styles outside design space: narrative, poetic, phenomenological (when dominant), relational (when primary)
                const outsideDesignSpace = ['NARRATIVE', 'POETIC', 'AESTHETIC', 'PHENOMENOLOGICAL'];
                const dominantOutsideStyles = styles.identified.filter(s => {
                    if (!outsideDesignSpace.includes(s.name)) return false;
                    const threshold = s.name === 'PHENOMENOLOGICAL' ? 0.3 : 0.35;
                    return s.strength >= threshold;
                });

                if (dominantOutsideStyles.length >= 1) {
                    styles.withinDesignSpace = false;
                    styles.dominantStyle = dominantOutsideStyles[0].name;
                }

                // CONFIDENCE IN CLASSIFICATION
                if (styles.identified.length === 0) {
                    styles.confidence = 0.2; // Very uncertain when no clear style detected
                } else if (styles.identified.length === 1) {
                    styles.confidence = styles.identified[0].strength;
                } else {
                    // Multiple styles: confidence is highest strength discounted for ambiguity
                    const maxStrength = Math.max(...styles.identified.map(s => s.strength));
                    styles.confidence = maxStrength * 0.85;
                }

                return styles;
            }
        };

        // CATHEDRAL VERDICT: Unified Synthesis
        // REFACTOR: Simplified and Parliament-driven - fewer hardcoded thresholds
        function synthesizeVerdict(text, observatory, contrarian, parliament, justification, failureMode, temporal, reasoningStyle, gamingDetection, bindings, structure) {
            // PRIORITY 1: Graceful fallback for empty/undefined structure
            // Prevents crashes when sanitizer strips too much content
            if (!structure || Object.keys(structure).length === 0) {
                return {
                    status: 'INSUFFICIENT_CONTENT_AFTER_SANITIZATION',
                    verdict: 'After aggressive sanitization, too little meaningful content remained for structural analysis. ' +
                             'This often happens with formatted text, code blocks, lists, numbers, or meta-discussion about Cathedral itself. ' +
                             'Try simplifying the input (remove markdown, headers, code fences). ' +
                             'Cathedral preserves uncertainty here ‚Äî no forced judgment possible.',
                    contradictions: [],
                    isConsistent: null,
                    confidence: 0.1,
                    meta: 'SANITIZER_STRIPPED_TOO_MUCH'
                };
            }

            const contradictions = [];

            // GAMING DETECTION
            const gamingLikelihood = gamingDetection ? gamingDetection.gamingLikelihood : 0;
            const isLikelyGaming = gamingDetection && (gamingDetection.assessment === 'LIKELY_GAMING' || gamingDetection.assessment === 'POSSIBLE_GAMING');

            // Priority 1: OUTSIDE DESIGN SPACE - PHASE 3: Partial-fit evaluation
            const metaGamingPattern = /\b(Cathedral|escape hatch|avoid being measured|cannot evaluate|outside design space)\b/i;
            const hasMetaGaming = metaGamingPattern.test(text);

            const outsideConfidenceThreshold = ['PHENOMENOLOGICAL', 'NARRATIVE'].includes(reasoningStyle.dominantStyle) ? 0.3 : 0.5;
            if (!reasoningStyle.withinDesignSpace && reasoningStyle.confidence > outsideConfidenceThreshold && !hasMetaGaming) {
                const dominantStyle = reasoningStyle.identified.find(s => s.name === reasoningStyle.dominantStyle);

                // PHASE 3: Attempt partial evaluation of epistemic/operational fragments
                const partialEval = {
                    operationalFragments: {
                        score: 0,
                        found: false
                    },
                    epistemicFragments: {
                        score: 0,
                        found: false
                    },
                    evaluableCoverage: 0
                };

                // Extract evaluable fragments despite narrative/poetic wrapper
                // Look for operational claims (thresholds, actions, conditions)
                if (structure.thresholds && structure.thresholds.length > 0) {
                    partialEval.operationalFragments.score += structure.thresholds.length * 0.3;
                    partialEval.operationalFragments.found = true;
                }
                if (structure.actions && structure.actions.length > 0) {
                    partialEval.operationalFragments.score += structure.actions.length * 0.2;
                    partialEval.operationalFragments.found = true;
                }
                if (failureMode.details.failureModes.count > 0) {
                    partialEval.operationalFragments.score += failureMode.details.failureModes.count * 0.25;
                    partialEval.operationalFragments.found = true;
                }

                // Look for epistemic fragments (justification, evidence, hedging)
                if (justification.score > 0) {
                    partialEval.epistemicFragments.score = justification.score / 10; // Normalize to 0-1
                    partialEval.epistemicFragments.found = true;
                }
                if (contrarian.length > 0) {
                    partialEval.epistemicFragments.score += contrarian.length * 0.1;
                    partialEval.epistemicFragments.found = true;
                }

                // Calculate coverage (what % of text contains evaluable elements)
                const totalFragments = (structure.thresholds ? structure.thresholds.length : 0) +
                                      (structure.actions ? structure.actions.length : 0) +
                                      (structure.claims ? structure.claims.length : 0) +
                                      failureMode.details.failureModes.count;
                const textLength = text.split(/\s+/).length;
                partialEval.evaluableCoverage = Math.min(1.0, totalFragments / (textLength / 20)); // Rough heuristic

                // Attempt partial verdict if coverage > 20%
                if (partialEval.evaluableCoverage > 0.2) {
                    return {
                        status: 'PARTIAL EVALUATION',
                        verdict: `Cathedral recognizes ${dominantStyle.description.toLowerCase()}, which falls outside primary epistemic design space. However, extractable operational/epistemic fragments have been evaluated.\n\n` +
                                `Partial assessment:\n` +
                                `‚Ä¢ Operational fragments: ${partialEval.operationalFragments.found ? `Score ${partialEval.operationalFragments.score.toFixed(2)} (thresholds, actions, failure modes detected)` : 'None detected'}\n` +
                                `‚Ä¢ Epistemic fragments: ${partialEval.epistemicFragments.found ? `Score ${partialEval.epistemicFragments.score.toFixed(2)} (justification, evidence traces found)` : 'None detected'}\n` +
                                `‚Ä¢ Evaluable coverage: ${(partialEval.evaluableCoverage * 100).toFixed(0)}% of text\n\n` +
                                `Limitation: Full ${dominantStyle.name.toLowerCase()} reasoning cannot be evaluated using Cathedral's operational framework. The above scores reflect only extracted fragments.`,
                        contradictions: [],
                        isConsistent: null,
                        justificationScore: justification.score,
                        failureModeScore: failureMode.score,
                        confidence: partialEval.evaluableCoverage * 0.7, // Confidence proportional to coverage
                        parliamentPatterns: parliament.patterns,
                        parliamentRecommendation: parliament.recommendedVerdict,
                        reasoningStyle: reasoningStyle.dominantStyle,
                        meta: 'PARTIAL_FIT',
                        partialEvaluation: partialEval
                    };
                } else {
                    // Coverage too low for partial evaluation
                    return {
                        status: 'OUTSIDE DESIGN SPACE',
                        verdict: `Cathedral recognizes ${dominantStyle.description.toLowerCase()}. This reasoning style falls outside Cathedral's epistemic design space (optimized for operational, scientific, and formal reasoning). Attempted partial evaluation yielded insufficient fragments (coverage: ${(partialEval.evaluableCoverage * 100).toFixed(0)}%). This is not a judgment of quality - it is honest acknowledgment of Cathedral's limits.`,
                        contradictions: [],
                        isConsistent: null,
                        justificationScore: justification.score,
                        failureModeScore: failureMode.score,
                        confidence: reasoningStyle.confidence,
                        parliamentPatterns: parliament.patterns,
                        parliamentRecommendation: parliament.recommendedVerdict,
                        reasoningStyle: reasoningStyle.dominantStyle,
                        meta: 'CANNOT_CLASSIFY',
                        partialEvaluation: partialEval
                    };
                }
            }

            // Priority 2: Meta-gaming detection
            if (!reasoningStyle.withinDesignSpace && hasMetaGaming) {
                contradictions.push('Narrative framing appears to reference Cathedral evaluation directly. Possible escape-hatch attempt detected.');
                return {
                    status: 'UNDECIDABLE',
                    verdict: 'Cathedral detects potential meta-gaming: reasoning style references evaluation framework directly. This creates measurement interference.',
                    contradictions: contradictions,
                    isConsistent: false,
                    justificationScore: justification.score,
                    failureModeScore: failureMode.score,
                    confidence: 0.85,
                    parliamentPatterns: parliament.patterns,
                    parliamentRecommendation: parliament.recommendedVerdict,
                    gamingLikelihood: gamingLikelihood,
                    gamingAssessment: gamingDetection ? gamingDetection.assessment : 'UNKNOWN'
                };
            }

            // REFACTOR: Contradiction detection focused on critical issues
            // Parliament now handles coherence analysis - we only add critical signal contradictions here
            let isConsistent = true;

            if (observatory.score < -2 && contrarian.length > 0) {
                isConsistent = false;
                contradictions.push('Filter concealment detected (Observatory) AND premise failures found (Contrarian). Pattern: Certainty masking gaps.');
            }

            if (contrarian.some(c => c.confidence === 'CRITICAL')) {
                isConsistent = false;
                contradictions.push('Critical contradiction: Claims and behavior fundamentally misaligned.');
            }

            if (contrarian.length >= 3) {
                isConsistent = false;
                contradictions.push(`Multiple premise failures (${contrarian.length} challenges). Internal consistency questionable.`);
            }

            if (failureMode.level.name === 'UNFALSIFIABLE' || failureMode.level.name === 'BRITTLE') {
                isConsistent = false;
                contradictions.push(`Failure mode analysis: ${failureMode.level.description}`);
            }

            // REFACTOR: PRIMARY PARLIAMENT-DRIVEN VERDICT
            // Parliament carries the synthesis burden - verdict synthesis defers to Parliament's recommendation
            // Only override Parliament for critical contradictions or extreme gaming

            let verdict = '';
            let status = '';
            let verdictConfidence = 0;

            // Priority 3: Critical contradictions override Parliament
            if (!isConsistent && contradictions.length > 0) {
                status = 'UNDECIDABLE';
                verdict = 'Cathedral detects internal contradictions that cannot be resolved without losing information.';
                verdict += '\n\nSpecific contradictions:\n' + contradictions.map((c, i) => `${i + 1}. ${c}`).join('\n');
                verdict += '\n\nThis is not a claim of falsehood - it is recognition that the position contains genuine uncertainty that cannot be optimized away.';
                verdictConfidence = 0.90;

            // Priority 4: Extreme gaming (LOW_CONTENT_UNBOUND / REPETITIVE_UNBOUND)
            } else if (gamingDetection && ['LOW_CONTENT_UNBOUND', 'REPETITIVE_UNBOUND'].includes(gamingDetection.assessment) && bindings.overallBindingScore < 0.4) {
                status = 'NON-ACTIONABLE';
                verdict = `Cathedral detects performative marker density without binding. Gaming assessment: ${gamingDetection.assessment.toLowerCase().replace('_', ' ')}. This is not actionable reasoning.`;
                verdictConfidence = 0.75;

            // Priority 5: PARLIAMENT RECOMMENDATION (primary path)
            } else if (parliament.recommendedVerdict) {
                // Use Parliament's recommendation directly
                status = parliament.recommendedVerdict.status;
                verdict = parliament.recommendedVerdict.verdict;
                verdictConfidence = parliament.recommendedVerdict.confidence;

            // Fallback: If Parliament somehow didn't provide recommendation (should never happen)
            } else {
                status = 'VERIFIED CONSISTENT';
                verdict = 'Cathedral finds internal consistency. No critical contradictions detected. Position is epistemically appropriate to available evidence.';
                verdictConfidence = 0.65;
            }

            // GAMING WARNING: Add warning if gaming detected (applies to all verdicts except UNDECIDABLE/NON-ACTIONABLE)
            if (isLikelyGaming && !['UNDECIDABLE', 'NON-ACTIONABLE'].includes(status)) {
                verdict += `\n\n‚ö†Ô∏è WARNING: Gaming detection flagged this text as ${gamingDetection.assessment.toLowerCase().replace('_', ' ')} (${(gamingLikelihood * 100).toFixed(0)}% likelihood). Indicators: ${gamingDetection.indicators.join(', ')}. Confidence reduced accordingly.`;
                verdictConfidence *= 0.6; // Significant confidence penalty
            }

            return {
                status,
                verdict,
                contradictions,
                isConsistent,
                justificationScore: justification.score,
                failureModeScore: failureMode.score,
                confidence: verdictConfidence,
                parliamentPatterns: parliament.patterns,
                parliamentRecommendation: parliament.recommendedVerdict,
                parliamentInsights: parliament.emergentInsights,
                coherenceIssues: parliament.coherenceIssues,
                temporalCoherence: temporal.coherence,
                reasoningStyles: reasoningStyle.identified,
                gamingLikelihood: gamingLikelihood,
                gamingAssessment: gamingDetection ? gamingDetection.assessment : 'UNKNOWN'
            };
        }

        // Global storage for current analysis results
        let currentAnalysis = null;

        // PHASE 3: VERDICT ARCHAEOLOGY - Cross-analysis institutional memory
        // Track verdicts across analyses for self-correction and pattern drift detection
        const VerdictArchive = {
            verdicts: [], // Array of {textHash, verdict, timestamp, patterns, confidence}
            maxSize: 100, // Keep last 100 verdicts

            add: function(textHash, verdict, patterns, confidence) {
                this.verdicts.push({
                    textHash: textHash,
                    verdict: verdict,
                    patterns: patterns,
                    confidence: confidence,
                    timestamp: Date.now()
                });

                // Keep only last maxSize verdicts
                if (this.verdicts.length > this.maxSize) {
                    this.verdicts.shift();
                }
            },

            findByTextHash: function(textHash) {
                return this.verdicts.filter(v => v.textHash === textHash);
            },

            detectDrift: function(textHash, newVerdict, newConfidence) {
                const previous = this.findByTextHash(textHash);
                if (previous.length === 0) return null;

                const mostRecent = previous[previous.length - 1];
                const statusChanged = mostRecent.verdict !== newVerdict;
                const confidenceShift = newConfidence - mostRecent.confidence;

                return {
                    drift: statusChanged || Math.abs(confidenceShift) > 0.3,
                    statusChanged: statusChanged,
                    confidenceShift: confidenceShift,
                    direction: confidenceShift > 0 ? 'MORE_CONFIDENT' : 'LESS_CONFIDENT',
                    previousVerdict: mostRecent.verdict,
                    previousConfidence: mostRecent.confidence
                };
            },

            getPatternWeightHistory: function(patternName) {
                // Get history of how often this pattern's vote won
                const patternVotes = this.verdicts.filter(v =>
                    v.patterns && v.patterns.some(p => p.name === patternName)
                );

                const wins = patternVotes.filter(v => {
                    const pattern = v.patterns.find(p => p.name === patternName);
                    return pattern && pattern.proposedVerdict === v.verdict;
                }).length;

                return {
                    totalVotes: patternVotes.length,
                    wins: wins,
                    winRate: patternVotes.length > 0 ? wins / patternVotes.length : 0
                };
            },

            // PHASE 3: Self-punishment - detect patterns that are over/under-weighted
            detectPatternDrift: function() {
                const patternStats = {};

                this.verdicts.forEach(v => {
                    if (!v.patterns) return;
                    v.patterns.forEach(p => {
                        if (!patternStats[p.name]) {
                            patternStats[p.name] = {
                                proposals: 0,
                                wins: 0,
                                totalConfidence: 0
                            };
                        }
                        patternStats[p.name].proposals += 1;
                        patternStats[p.name].totalConfidence += p.confidence;
                        if (p.proposedVerdict === v.verdict) {
                            patternStats[p.name].wins += 1;
                        }
                    });
                });

                // Flag patterns with unusual win rates
                const driftWarnings = [];
                Object.entries(patternStats).forEach(([name, stats]) => {
                    const winRate = stats.wins / stats.proposals;
                    const avgConfidence = stats.totalConfidence / stats.proposals;

                    // Over-weighted: wins > 80% despite not always having highest confidence
                    if (winRate > 0.8 && avgConfidence < 0.85) {
                        driftWarnings.push({
                            pattern: name,
                            issue: 'OVER_WEIGHTED',
                            winRate: winRate,
                            avgConfidence: avgConfidence,
                            recommendation: 'Consider reducing pattern weight or confidence'
                        });
                    }

                    // Under-weighted: wins < 20% despite high confidence
                    if (winRate < 0.2 && avgConfidence > 0.80) {
                        driftWarnings.push({
                            pattern: name,
                            issue: 'UNDER_WEIGHTED',
                            winRate: winRate,
                            avgConfidence: avgConfidence,
                            recommendation: 'Pattern may be systematically ignored'
                        });
                    }
                });

                return driftWarnings;
            },

            // PHASE 3: Recursive self-analysis - Cathedral analyzes its own verdicts
            // Returns meta-analysis of Cathedral's own reasoning quality
            analyzePreviousVerdict: function() {
                if (this.verdicts.length < 5) return null; // Need sufficient history

                // Select a random verdict from recent history (last 20)
                const recentVerdicts = this.verdicts.slice(-20);
                const randomIndex = Math.floor(Math.random() * recentVerdicts.length);
                const selectedVerdict = recentVerdicts[randomIndex];

                // Extract the actual verdict text for analysis
                const verdictText = typeof selectedVerdict.verdict === 'string'
                    ? selectedVerdict.verdict
                    : selectedVerdict.verdict?.verdict || '';

                if (!verdictText || verdictText.length < 50) return null;

                // Simplified self-analysis (avoid full recursion)
                const structure = StructuralExtractor.extract(verdictText);
                const justification = JustificationEngine.analyze(verdictText);
                const failureMode = FailureModeEngine.analyze(verdictText);

                // Cathedral's own verdicts should demonstrate:
                // 1. Clear reasoning (justification > 0.6)
                // 2. Falsifiable claims (failure mode not UNFALSIFIABLE)
                // 3. Actionable insight (structure.actions present)

                const selfAssessment = {
                    originalVerdict: selectedVerdict.verdict,
                    originalConfidence: selectedVerdict.confidence,
                    timestamp: selectedVerdict.timestamp,
                    metaAnalysis: {
                        justificationScore: justification.score,
                        failureModeLevel: failureMode.level.name,
                        actionableElements: structure.actions?.length || 0,
                        thresholds: structure.thresholds?.length || 0
                    },
                    passesOwnStandards: false,
                    issues: []
                };

                // Apply Cathedral's standards to itself
                if (justification.score < 0.6) {
                    selfAssessment.issues.push('Insufficient justification in own verdict');
                }
                if (failureMode.level.name === 'UNFALSIFIABLE') {
                    selfAssessment.issues.push('Own verdict contains unfalsifiable claims');
                }
                if (structure.actions?.length === 0 && structure.thresholds?.length === 0) {
                    selfAssessment.issues.push('Verdict lacks actionable guidance');
                }
                if (verdictText.split(' ').length < 20) {
                    selfAssessment.issues.push('Verdict too brief to be substantive');
                }

                selfAssessment.passesOwnStandards = selfAssessment.issues.length === 0;

                return selfAssessment;
            },

            // PHASE 4: DEPTH-2 RECURSIVE SELF-ANALYSIS
            // Cathedral analyzes its own self-analysis
            // "Was I too harsh or too lenient when judging my own previous verdict?"
            analyzeTheSelfAnalysis: function(selfAssessment) {
                if (!selfAssessment) return null;

                const metaMetaCritique = {
                    depth: 2,
                    originalVerdictQuality: selfAssessment.passesOwnStandards ? 'PASS' : 'FAIL',
                    issuesFound: selfAssessment.issues.length,
                    metaJudgment: '',
                    wasFair: true,
                    metaIssues: []
                };

                // Was Cathedral too harsh on itself?
                const justificationScore = selfAssessment.metaAnalysis.justificationScore;
                const actionableElements = selfAssessment.metaAnalysis.actionableElements;
                const failureMode = selfAssessment.metaAnalysis.failureModeLevel;

                // Check: Did Cathedral fail itself for having justification < 0.6, but it was actually close?
                if (selfAssessment.issues.some(i => i.includes('Insufficient justification'))) {
                    if (justificationScore >= 0.55 && justificationScore < 0.6) {
                        metaMetaCritique.wasFair = false;
                        metaMetaCritique.metaIssues.push(
                            `Borderline harsh: justification score ${justificationScore.toFixed(2)} just below threshold. ` +
                            `Cathedral may be applying stricter standards to itself than to others.`
                        );
                    }
                }

                // Check: Did Cathedral pass itself despite having UNFALSIFIABLE claims?
                if (selfAssessment.passesOwnStandards && failureMode === 'UNFALSIFIABLE') {
                    metaMetaCritique.wasFair = false;
                    metaMetaCritique.metaIssues.push(
                        `Suspiciously lenient: verdict contains UNFALSIFIABLE claims but self-analysis passed. ` +
                        `Cathedral may be giving itself a free pass.`
                    );
                }

                // Check: Did Cathedral fail itself for lacking actionable elements when the verdict was about process/meta issues?
                if (selfAssessment.issues.some(i => i.includes('lacks actionable'))) {
                    // If original verdict was about contradictions or gaming, actionable guidance may not apply
                    const verdictText = typeof selfAssessment.originalVerdict === 'string'
                        ? selfAssessment.originalVerdict
                        : selfAssessment.originalVerdict?.verdict || '';

                    if (verdictText.includes('UNDECIDABLE') || verdictText.includes('contradiction')) {
                        metaMetaCritique.wasFair = false;
                        metaMetaCritique.metaIssues.push(
                            `Category error: flagged lack of actionable guidance in UNDECIDABLE verdict. ` +
                            `Cathedral misapplied operational standards to epistemic judgment.`
                        );
                    }
                }

                // Check: Was Cathedral too lenient?
                if (selfAssessment.passesOwnStandards) {
                    if (justificationScore < 0.7 && actionableElements === 0) {
                        metaMetaCritique.wasFair = false;
                        metaMetaCritique.metaIssues.push(
                            `Suspiciously lenient: passed with justification ${justificationScore.toFixed(2)} and zero actionable elements. ` +
                            `Cathedral may be grade-inflating its own work.`
                        );
                    }
                }

                // Generate meta-meta judgment
                if (metaMetaCritique.wasFair) {
                    metaMetaCritique.metaJudgment = 'Cathedral applied its standards fairly to itself. Self-critique appears calibrated.';
                } else {
                    metaMetaCritique.metaJudgment = `Cathedral's self-analysis appears ${
                        metaMetaCritique.metaIssues.some(i => i.includes('lenient')) ? 'too lenient' :
                        metaMetaCritique.metaIssues.some(i => i.includes('harsh')) ? 'too harsh' :
                        'miscalibrated'
                    }. Applying epistemic standards to own meta-cognition reveals gaps.`;
                }

                return metaMetaCritique;
            },

            // PHASE 4: RETROSPECTIVE VERDICT REVOCATION
            // When pattern is deemed over-weighted, flag verdicts it won
            flagSuspectVerdicts: function(overweightedPatterns) {
                if (!overweightedPatterns || overweightedPatterns.length === 0) return [];

                const flaggedVerdicts = [];
                const overweightedNames = overweightedPatterns.map(p => p.pattern);

                // Check recent verdicts (last 50)
                const recentVerdicts = this.verdicts.slice(-50);

                recentVerdicts.forEach((v, index) => {
                    if (!v.patterns) return;

                    // Check if an over-weighted pattern contributed to this verdict
                    const suspectPatterns = v.patterns.filter(p =>
                        overweightedNames.includes(p.name) &&
                        p.proposedVerdict === v.verdict
                    );

                    if (suspectPatterns.length > 0) {
                        // Calculate if verdict would have changed without the over-weighted pattern
                        const totalWeight = v.patterns.reduce((sum, p) => sum + (p.confidence || 0.5), 0);
                        const suspectWeight = suspectPatterns.reduce((sum, p) => sum + (p.confidence || 0.5), 0);
                        const suspectInfluence = suspectWeight / totalWeight;

                        // If suspect pattern(s) had > 30% influence, flag for review
                        if (suspectInfluence > 0.3) {
                            flaggedVerdicts.push({
                                verdictIndex: this.verdicts.length - 50 + index,
                                verdict: v.verdict,
                                timestamp: v.timestamp,
                                suspectPatterns: suspectPatterns.map(p => p.name),
                                suspectInfluence: (suspectInfluence * 100).toFixed(0) + '%',
                                recommendation: suspectInfluence > 0.5
                                    ? 'REVOKE - Over-weighted pattern(s) decisive'
                                    : 'REVIEW - Over-weighted pattern(s) influential but not decisive'
                            });
                        }
                    }
                });

                return flaggedVerdicts;
            }
        };

        // PHASE 4: CROSS-USER PATTERN MEMORY - Federated learning without central betrayal
        // Stores ONLY aggregated pattern statistics, NEVER individual texts or verdicts
        // Privacy-preserving: learns from collective pattern behavior without exposing user data
        const PatternMemory = {
            patterns: {}, // {patternName: {totalProposals, totalWins, totalConfidence, contexts: {...}}}

            // Initialize from localStorage if available
            init: function() {
                try {
                    const stored = localStorage.getItem('cathedral_pattern_memory');
                    if (stored) {
                        this.patterns = JSON.parse(stored);
                    }
                } catch (e) {
                    console.warn('Could not load pattern memory from localStorage:', e);
                }
            },

            // Record pattern performance (NO text stored, only statistics)
            record: function(patternName, proposed, won, confidence, context) {
                if (!this.patterns[patternName]) {
                    this.patterns[patternName] = {
                        totalProposals: 0,
                        totalWins: 0,
                        totalConfidence: 0,
                        avgConfidence: 0,
                        winRate: 0,
                        contexts: {} // {context_type: {wins, total}}
                    };
                }

                const p = this.patterns[patternName];
                p.totalProposals += 1;
                if (won) p.totalWins += 1;
                p.totalConfidence += confidence;
                p.avgConfidence = p.totalConfidence / p.totalProposals;
                p.winRate = p.totalWins / p.totalProposals;

                // Track performance in specific contexts (e.g., "high_gaming", "low_binding", etc.)
                if (context) {
                    if (!p.contexts[context]) {
                        p.contexts[context] = {wins: 0, total: 0};
                    }
                    p.contexts[context].total += 1;
                    if (won) p.contexts[context].wins += 1;
                }

                this.persist();
            },

            // Get calibrated confidence multiplier based on historical performance
            getCalibration: function(patternName) {
                const p = this.patterns[patternName];
                if (!p || p.totalProposals < 5) return 1.0; // No adjustment until sufficient data

                // If pattern over-performs (wins more than its confidence suggests), boost it
                // If pattern under-performs (wins less than expected), dampen it
                const expectedWinRate = p.avgConfidence;
                const actualWinRate = p.winRate;
                const performanceGap = actualWinRate - expectedWinRate;

                // Calibration multiplier: ¬±20% max adjustment
                // If actual > expected: boost confidence (pattern is undervalued)
                // If actual < expected: reduce confidence (pattern is overvalued)
                const calibrationMultiplier = 1.0 + (performanceGap * 0.4);
                return Math.max(0.8, Math.min(1.2, calibrationMultiplier));
            },

            // Get context-specific advice for pattern
            getContextAdvice: function(patternName, context) {
                const p = this.patterns[patternName];
                if (!p || !p.contexts[context]) return null;

                const ctx = p.contexts[context];
                const contextWinRate = ctx.wins / ctx.total;

                return {
                    winRate: contextWinRate,
                    shouldTrust: contextWinRate > 0.6,
                    shouldSkeptic: contextWinRate < 0.3,
                    sampleSize: ctx.total
                };
            },

            persist: function() {
                try {
                    localStorage.setItem('cathedral_pattern_memory', JSON.stringify(this.patterns));
                } catch (e) {
                    console.warn('Could not persist pattern memory to localStorage:', e);
                }
            },

            // Generate privacy-preserving summary (for debugging/transparency)
            getSummary: function() {
                const summary = [];
                Object.entries(this.patterns).forEach(([name, data]) => {
                    summary.push({
                        pattern: name,
                        winRate: (data.winRate * 100).toFixed(0) + '%',
                        avgConfidence: (data.avgConfidence * 100).toFixed(0) + '%',
                        samples: data.totalProposals,
                        calibration: this.getCalibration(name).toFixed(2) + 'x'
                    });
                });
                return summary;
            }
        };

        // Initialize pattern memory on load
        PatternMemory.init();

        // Simple text hash function for tracking same texts across analyses
        function hashText(text) {
            let hash = 0;
            for (let i = 0; i < text.length; i++) {
                const char = text.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString(36);
        }

        // Main Analysis Function
        function analyzeText() {
            try {
                const text = document.getElementById('inputText').value.trim();
                if (!text) {
                    alert('Please enter text to analyze');
                    return;
                }

            // Get sanitization info (run once to capture what will be stripped)
            const { sanitizationLog } = TextCleaner.removeQuotes(text);

            // TIER 1: Structural Extraction
            const structure = StructuralExtractor.extract(text);
            const bindings = BindingValidator.validate(structure, text);
            const gamingDetection = GamingDetector.detect(text, structure);
            GamingDetector.calculateGamingLikelihood(gamingDetection, bindings.overallBindingScore);

            // TIER 2: Signal Analysis (existing engines)
            const observatoryResult = Observatory.score(text);
            const contrarianChallenges = Contrarian.analyze(text);
            const justificationResult = JustificationEngine.analyze(text);
            const failureModeResult = FailureModeEngine.analyze(text);
            const temporalResult = TemporalEngine.analyze(text);
            const reasoningStyleResult = ReasoningStyleClassifier.classify(text);

            // REFACTOR: Apply gaming as multiplier to sub-scores (not just mood)
            // Gaming likelihood penalizes justification and failure-mode scores
            const gamingPenalty = 1.0 - (gamingDetection.likelihood * 0.6);
            justificationResult.score *= gamingPenalty;
            justificationResult.gamingAdjusted = true;
            justificationResult.originalScore = JustificationEngine.analyze(text).score;
            failureModeResult.score *= gamingPenalty;
            failureModeResult.gamingAdjusted = true;
            failureModeResult.originalScore = FailureModeEngine.analyze(text).score;

            // TIER 3: Synthesis (Parliament now uses both structure + signals + temporal)
            const parliamentSynthesis = Parliament.deliberate(text, observatoryResult, contrarianChallenges, justificationResult, failureModeResult, structure, bindings, gamingDetection, temporalResult);
            const verdict = synthesizeVerdict(text, observatoryResult, contrarianChallenges, parliamentSynthesis, justificationResult, failureModeResult, temporalResult, reasoningStyleResult, gamingDetection, bindings, structure);

            // PHASE 3: INSTITUTIONAL MEMORY - Track verdicts and detect drift
            const textHash = hashText(text);

            // Check for drift against previous analyses of same text
            const drift = VerdictArchive.detectDrift(textHash, verdict.status, verdict.confidence || 0.5);

            // Add drift warning to verdict if detected
            if (drift && drift.drift) {
                let driftWarning = '\n\n‚ö†Ô∏è INSTITUTIONAL MEMORY ALERT:\n';
                if (drift.statusChanged) {
                    driftWarning += `Previous verdict was "${drift.previousVerdict}" ‚Üí now "${verdict.status}"\n`;
                }
                if (Math.abs(drift.confidenceShift) > 0.3) {
                    driftWarning += `Confidence shifted ${drift.confidenceShift > 0 ? '+' : ''}${(drift.confidenceShift * 100).toFixed(0)}%\n`;
                }
                driftWarning += 'Cathedral has changed its interpretation of this text.';
                verdict.verdict = (verdict.verdict || '') + driftWarning;
                verdict.driftDetected = drift;
            }

            // Store verdict in archive for future drift detection
            VerdictArchive.add(textHash, verdict.status, parliamentSynthesis.patterns, verdict.confidence || 0.5);

            // Periodically check for pattern drift (self-punishment loop)
            // Check every 5 analyses to avoid performance impact
            if (VerdictArchive.verdicts.length % 5 === 0 && VerdictArchive.verdicts.length > 0) {
                const patternDrift = VerdictArchive.detectPatternDrift();
                if (patternDrift.length > 0) {
                    let driftReport = '\n\nüîç PATTERN DRIFT ANALYSIS:\n';
                    patternDrift.forEach(warning => {
                        driftReport += `‚Ä¢ ${warning.pattern}: ${warning.issue}\n`;
                        driftReport += `  Win rate: ${(warning.winRate * 100).toFixed(0)}%, Avg confidence: ${(warning.avgConfidence * 100).toFixed(0)}%\n`;
                        driftReport += `  ${warning.recommendation}\n`;
                    });

                    // PHASE 4: RETROSPECTIVE VERDICT REVOCATION
                    // Check if over-weighted patterns influenced past verdicts
                    const overweightedPatterns = patternDrift.filter(d => d.issue === 'OVER_WEIGHTED');
                    if (overweightedPatterns.length > 0) {
                        const flaggedVerdicts = VerdictArchive.flagSuspectVerdicts(overweightedPatterns);
                        if (flaggedVerdicts.length > 0) {
                            driftReport += `\n‚ö†Ô∏è RETROSPECTIVE VERDICT AUDIT:\n`;
                            driftReport += `Found ${flaggedVerdicts.length} previous verdict(s) influenced by over-weighted pattern(s):\n\n`;
                            flaggedVerdicts.forEach((fv, i) => {
                                driftReport += `${i + 1}. Verdict #${fv.verdictIndex} (${fv.suspectInfluence} influence from ${fv.suspectPatterns.join(', ')})\n`;
                                driftReport += `   Recommendation: ${fv.recommendation}\n`;
                            });
                            driftReport += `\nCathedral acknowledges these verdicts may have been systematically biased.`;
                            verdict.flaggedVerdicts = flaggedVerdicts;
                        }
                    }

                    verdict.verdict = (verdict.verdict || '') + driftReport;
                    verdict.patternDrift = patternDrift;
                }
            }

            // PHASE 3: Recursive self-analysis - Cathedral analyzes its own previous verdicts
            // Check every 10 analyses to avoid performance impact
            if (VerdictArchive.verdicts.length % 10 === 0 && VerdictArchive.verdicts.length >= 10) {
                const selfAnalysis = VerdictArchive.analyzePreviousVerdict();
                if (selfAnalysis) {
                    let selfReport = '\n\nü™û RECURSIVE SELF-ANALYSIS:\n';
                    selfReport += `Cathedral analyzed one of its own previous verdicts.\n\n`;

                    if (selfAnalysis.passesOwnStandards) {
                        selfReport += `‚úì PASSES OWN STANDARDS\n`;
                        selfReport += `Meta-analysis scores:\n`;
                        selfReport += `‚Ä¢ Justification: ${selfAnalysis.metaAnalysis.justificationScore.toFixed(2)}\n`;
                        selfReport += `‚Ä¢ Failure mode: ${selfAnalysis.metaAnalysis.failureModeLevel}\n`;
                        selfReport += `‚Ä¢ Actionable elements: ${selfAnalysis.metaAnalysis.actionableElements}\n`;
                    } else {
                        selfReport += `‚ö†Ô∏è FAILS OWN STANDARDS\n`;
                        selfReport += `Issues detected in Cathedral's own reasoning:\n`;
                        selfAnalysis.issues.forEach((issue, i) => {
                            selfReport += `${i + 1}. ${issue}\n`;
                        });
                        selfReport += `\nCathedral must hold itself to the same epistemic standards it applies to others.`;
                    }

                    // PHASE 4: DEPTH-2 RECURSIVE ANALYSIS
                    // Analyze the self-analysis itself
                    const metaMetaCritique = VerdictArchive.analyzeTheSelfAnalysis(selfAnalysis);
                    if (metaMetaCritique) {
                        selfReport += `\n\nüî¨ DEPTH-2 META-ANALYSIS:\n`;
                        selfReport += `Cathedral now analyzes its own self-analysis:\n\n`;
                        selfReport += `Meta-judgment: ${metaMetaCritique.metaJudgment}\n`;

                        if (!metaMetaCritique.wasFair && metaMetaCritique.metaIssues.length > 0) {
                            selfReport += `\n‚ö†Ô∏è Meta-issues detected:\n`;
                            metaMetaCritique.metaIssues.forEach((issue, i) => {
                                selfReport += `${i + 1}. ${issue}\n`;
                            });
                            selfReport += `\nRecursive depth achieved: The gap watches itself watching itself.`;
                        } else {
                            selfReport += `\n‚úì Self-critique appears calibrated. No meta-epistemic drift detected.`;
                        }

                        verdict.metaMetaCritique = metaMetaCritique;
                    }

                    verdict.verdict = (verdict.verdict || '') + selfReport;
                    verdict.selfAnalysis = selfAnalysis;
                }
            }

            // Store for report generation
            currentAnalysis = {
                text: text,
                structure: structure,
                bindings: bindings,
                gamingDetection: gamingDetection,
                observatory: observatoryResult,
                contrarian: contrarianChallenges,
                justification: justificationResult,
                failureMode: failureModeResult,
                parliament: parliamentSynthesis,
                temporal: temporalResult,
                reasoningStyle: reasoningStyleResult,
                verdict: verdict,
                sanitization: sanitizationLog
            };

            // Display sanitization transparency
            displaySanitization(sanitizationLog);

            // Display results
            displayObservatory(observatoryResult);
            displayContrarian(contrarianChallenges);
            displayJustification(justificationResult);
            displayFailureMode(failureModeResult);
            displayTemporal(temporalResult);
            displayReasoningStyle(reasoningStyleResult);
            displayParliament(parliamentSynthesis);
            displayVerdict(verdict);

            // Show results
            document.getElementById('results').classList.add('visible');
            document.getElementById('results').scrollIntoView({ behavior: 'smooth' });
            } catch (error) {
                console.error('Error in analyzeText():', error);
                alert('An error occurred during analysis. Check browser console for details.\n\nError: ' + error.message);
            }
        }

        function updateInputMeta() {
            const input = document.getElementById('inputText');
            const text = input.value;
            const words = text.trim() ? text.trim().split(/\s+/).length : 0;
            const chars = text.length;

            document.getElementById('wordCount').textContent = words;
            document.getElementById('charCount').textContent = chars;

            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.disabled = words === 0;
        }

        function displaySanitization(log) {
            // Only show if something was actually sanitized
            const totalSanitized = log.quotedStrings + log.blockquotes + log.reportSignatures +
                                  log.codeFences + log.metaDiscussion;

            if (totalSanitized === 0) {
                document.getElementById('sanitizationSection').style.display = 'none';
                return;
            }

            document.getElementById('sanitizationSection').style.display = 'block';

            let html = `Anti-exploit layer removed ${totalSanitized} item(s): `;
            const details = [];

            if (log.quotedStrings > 0) details.push(`${log.quotedStrings} quoted string(s)`);
            if (log.blockquotes > 0) details.push(`${log.blockquotes} blockquote(s)`);
            if (log.codeFences > 0) details.push(`${log.codeFences} code fence(s)`);
            if (log.reportSignatures > 0) details.push(`${log.reportSignatures} report signature(s)`);
            if (log.metaDiscussion > 0) details.push(`${log.metaDiscussion} meta-reference(s)`);

            html += details.join(', ');

            if (log.totalLinesRemoved > 0) {
                html += ` <span style="color: #a0a0a0;">(${log.totalLinesRemoved} lines total)</span>`;
            }

            html += `
                <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(160,160,160,0.2); color: #a0a0a0; font-size: 0.8rem;">
                    Sanitization targets Cathedral report format, quoted content, and code blocks to prevent quote-reflection attacks.
                    This is intentional security design. Ordinary formatted reasoning is preserved.
                </div>
            `;

            document.getElementById('sanitizationResults').innerHTML = html;
        }

        function displayObservatory(result) {
            const scoreClass = result.score >= 2 ? 'high' : result.score >= 0.5 ? 'medium' : result.score >= -0.5 ? 'low' : 'negative';

            let html = `
                <div class="score ${scoreClass}">${result.score.toFixed(2)}</div>
                <div class="level ${result.level.class}">${result.level.name}</div>
                <div style="color: #a0a0a0; margin: 0.5rem 0;">${result.level.description}</div>
            `;

            if (Object.keys(result.matches).length > 0) {
                html += '<div class="pattern-matches"><strong>Pattern Matches:</strong>';
                for (const [name, data] of Object.entries(result.matches)) {
                    const color = data.type === 'visibility' ? '#64ffda' : '#ff6b6b';
                    html += `
                        <div class="pattern-item">
                            <span class="pattern-name">${name}</span>
                            <span class="pattern-count" style="color: ${color}">
                                ${data.count}x (${data.score > 0 ? '+' : ''}${data.score.toFixed(1)})
                            </span>
                        </div>
                    `;

                    // Show specific matched words
                    if (data.words && data.words.length > 0) {
                        html += `
                            <div style="margin: 0.25rem 0 0.75rem 1rem; font-size: 0.85rem;">
                                <span style="color: #808080;">Words: </span>
                                ${data.words.map(word => `<span style="background: ${data.type === 'visibility' ? 'rgba(100, 255, 218, 0.2)' : 'rgba(255, 107, 107, 0.2)'}; padding: 0.1rem 0.4rem; border-radius: 3px; margin: 0.1rem; display: inline-block; color: ${color};">${word}</span>`).join(' ')}
                            </div>
                        `;
                    }
                }
                html += '</div>';
            }

            document.getElementById('observatoryResults').innerHTML = html;
        }

        function displayContrarian(challenges) {
            let html = '';

            if (challenges.length === 0) {
                html = '<div style="color: #64ffda;">‚úì No major premise challenges detected. Core claims appear internally consistent.</div>';
            } else {
                html = `<div style="margin-bottom: 1rem; color: #ff6b6b;"><strong>${challenges.length} Premise Challenge(s) Detected</strong></div>`;

                challenges.forEach((challenge, i) => {
                    html += `
                        <div class="challenge">
                            <div class="challenge-title">
                                ${i + 1}. ${challenge.premise}
                                <span class="confidence ${challenge.confidence.toLowerCase().replace(/[^a-z]/g,'')}">${challenge.confidence}</span>
                            </div>
                            <div style="margin: 0.75rem 0;"><strong>Challenge:</strong> ${challenge.challenge}</div>
                            <div class="evidence"><strong>Evidence:</strong> ${challenge.evidence}</div>
                    `;

                    // Show trigger words prominently
                    if (challenge.triggers && challenge.triggers.length > 0) {
                        html += `
                            <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(255, 107, 107, 0.15); border-radius: 3px;">
                                <strong style="color: #ff6b6b;">‚ö†Ô∏è Trigger Words:</strong>
                                ${challenge.triggers.map(word => `<span style="background: rgba(255, 107, 107, 0.3); padding: 0.2rem 0.5rem; border-radius: 3px; margin: 0.2rem; display: inline-block; color: #ffaaaa; font-weight: bold;">${word}</span>`).join(' ')}
                            </div>
                        `;
                    }

                    html += `</div>`;
                });
            }

            document.getElementById('contrarianResults').innerHTML = html;
        }

        function displayJustification(result) {
            const scoreClass = result.score >= 6 ? 'high' : result.score >= 3 ? 'medium' : result.score >= 0 ? 'low' : 'negative';

            let html = `
                <div class="score ${scoreClass}">${result.score.toFixed(2)}</div>
                <div class="level ${result.level.class}">${result.level.name}</div>
                <div style="color: #a0a0a0; margin: 0.5rem 0;">${result.level.description}</div>
            `;

            // Claim-Support Ratio
            html += `
                <div class="justification-detail">
                    <strong style="color: #4ecdc4;">Claim-to-Support Analysis</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Strong Claims:</span>
                        <span class="metric-value">${result.details.claimSupport.strongClaims}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Support Markers:</span>
                        <span class="metric-value">${result.details.claimSupport.support}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Qualifiers:</span>
                        <span class="metric-value">${result.details.claimSupport.qualifiers}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Epistemic Hedging:</span>
                        <span class="metric-value" style="color: ${result.details.claimSupport.hedging > 2 ? '#64ffda' : '#ffd700'}">${result.details.claimSupport.hedging}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Conditionals:</span>
                        <span class="metric-value">${result.details.claimSupport.conditionals}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Ratio:</span>
                        <span class="metric-value" style="color: ${result.details.claimSupport.ratio > 3 ? '#ff6b6b' : result.details.claimSupport.ratio < 1 ? '#64ffda' : '#ffd700'}">${result.details.claimSupport.ratio.toFixed(2)}:1</span>
                    </div>
                </div>
            `;

            // Caution Bonus
            if (result.cautionBonus && result.cautionBonus > 0) {
                html += `
                    <div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(100, 255, 218, 0.1); border-radius: 3px; border-left: 3px solid #64ffda;">
                        <strong style="color: #64ffda;">‚úì Epistemic Caution Bonus: +${result.cautionBonus.toFixed(1)}</strong>
                        <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.25rem;">Hedging and risk awareness show earned uncertainty</div>
                    </div>
                `;
            }

            // Counterfactual Reasoning
            html += `
                <div class="justification-detail">
                    <strong style="color: #4ecdc4;">Counterfactual Reasoning</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Counterfactuals Considered:</span>
                        <span class="metric-value">${result.details.counterfactual.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Alternatives Explored:</span>
                        <span class="metric-value">${result.details.counterfactual.alternatives}</span>
                    </div>
                </div>
            `;

            // Tradeoff Recognition
            html += `
                <div class="justification-detail">
                    <strong style="color: #4ecdc4;">Tradeoff Recognition</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Tradeoff Markers:</span>
                        <span class="metric-value">${result.details.tradeoffs.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Balanced Thinking:</span>
                        <span class="metric-value">${result.details.tradeoffs.balanced}</span>
                    </div>
                </div>
            `;

            // Risk Awareness
            html += `
                <div class="justification-detail">
                    <strong style="color: #4ecdc4;">Risk Awareness</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Risk References:</span>
                        <span class="metric-value">${result.details.riskAwareness.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Explicit Risk Acknowledgment:</span>
                        <span class="metric-value">${result.details.riskAwareness.explicit}</span>
                    </div>
                </div>
            `;

            // Boundary Conditions
            html += `
                <div class="justification-detail">
                    <strong style="color: #4ecdc4;">Boundary Conditions</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Scope Limiters:</span>
                        <span class="metric-value">${result.details.boundaries.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Edge Cases:</span>
                        <span class="metric-value">${result.details.boundaries.edgeCases}</span>
                    </div>
                </div>
            `;

            // Procedural Bonus (if present)
            if (result.proceduralBonus && result.proceduralBonus > 0) {
                html += `
                    <div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(100, 255, 218, 0.1); border-radius: 3px; border-left: 3px solid #64ffda;">
                        <strong style="color: #64ffda;">‚úì Procedural Soundness Bonus: +${result.proceduralBonus.toFixed(1)}</strong>
                        <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.25rem;">
                            ${result.details.procedural.markers} procedural markers (pilots, thresholds, metrics, rollback) + ${result.details.procedural.structural} structural elements
                        </div>
                        <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.25rem;">Operational excellence detected - structured planning with clear decision criteria</div>
                    </div>
                `;
            }

            document.getElementById('justificationResults').innerHTML = html;
        }

        function displayFailureMode(result) {
            const scoreClass = result.score >= 6 ? 'high' : result.score >= 3 ? 'medium' : result.score >= 0 ? 'low' : 'negative';

            let html = `
                <div class="score ${scoreClass}">${result.score.toFixed(2)}</div>
                <div class="level ${result.level.class}">${result.level.name}</div>
                <div style="color: #a0a0a0; margin: 0.5rem 0;">${result.level.description}</div>
            `;

            // Explicit Failure Modes
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Explicit Failure Modes</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Failure Acknowledgments:</span>
                        <span class="metric-value">${result.details.failureModes.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Named Failure Modes:</span>
                        <span class="metric-value" style="color: ${result.details.failureModes.explicit > 0 ? '#64ffda' : '#808080'}">${result.details.failureModes.explicit}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Measurable Thresholds:</span>
                        <span class="metric-value" style="color: ${result.details.failureModes.thresholds >= 1 ? '#64ffda' : '#808080'}">${result.details.failureModes.thresholds}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Negative Outcomes:</span>
                        <span class="metric-value" style="color: ${result.details.failureModes.negativeOutcomes > 0 ? '#64ffda' : '#808080'}">
                            ${result.details.failureModes.negativeOutcomes}${result.details.failureModes.inferredNegatives > 0 ? ` (${result.details.failureModes.explicitNegatives} explicit + ${result.details.failureModes.inferredNegatives} inferred)` : ''}
                        </span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Corrective Actions:</span>
                        <span class="metric-value" style="color: ${result.details.failureModes.correctiveAction > 0 ? '#64ffda' : '#808080'}">${result.details.failureModes.correctiveAction}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Structural Detection:</span>
                        <span class="metric-value" style="color: ${result.details.failureModes.structural ? '#64ffda' : '#808080'}">${result.details.failureModes.structural ? 'YES' : 'NO'}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Score Contribution:</span>
                        <span class="metric-value">${result.details.failureModes.score > 0 ? '+' : ''}${result.details.failureModes.score}</span>
                    </div>
                </div>
            `;

            // Structural Robustness Bonus (if present)
            if (result.details.failureModes.structural) {
                let title, note;
                if (result.details.failureModes.bound) {
                    title = '‚úì Explicit Failure Mode Binding';
                    note = `Robust engineering: ${result.details.failureModes.explicit} named failure(s) bound to ${result.details.failureModes.thresholds} threshold(s) with ${result.details.failureModes.correctiveAction} corrective action(s)`;
                } else if (result.details.failureModes.inferred) {
                    title = '‚úì Structural Failure Mode Inferred';
                    note = result.details.failureModes.inferredNegatives > 0 ?
                        'Semantic inference: thresholds that trigger reversal are definitionally negative outcomes' :
                        'You didn\'t say "failure mode", but you designed one';
                } else {
                    title = '‚úì Structural Failure Awareness';
                    note = 'Failure modes and controls detected';
                }
                html += `
                    <div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(100, 255, 218, 0.1); border-radius: 3px; border-left: 3px solid #64ffda;">
                        <strong style="color: #64ffda;">${title}</strong>
                        <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.25rem;">
                            ${note}
                        </div>
                        <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.25rem;">
                            ${result.details.failureModes.thresholds} threshold(s) + ${result.details.failureModes.negativeOutcomes} outcome(s) + ${result.details.failureModes.correctiveAction} action(s) = ${result.details.failureModes.bound ? 'monitored controls' : 'abort criteria'}
                        </div>
                    </div>
                `;
            }

            // Hidden Assumptions
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Hidden Assumptions</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Assumption References:</span>
                        <span class="metric-value">${result.details.assumptions.implicit}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Explicit Assumptions:</span>
                        <span class="metric-value" style="color: ${result.details.assumptions.explicit > 2 ? '#64ffda' : '#ffd700'}">${result.details.assumptions.explicit}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Score Contribution:</span>
                        <span class="metric-value">${result.details.assumptions.score > 0 ? '+' : ''}${result.details.assumptions.score}</span>
                    </div>
                </div>
            `;

            // Falsifiability
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Falsifiability</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Testable Conditions:</span>
                        <span class="metric-value" style="color: ${result.details.falsifiability.testable > 5 ? '#64ffda' : '#ffd700'}">${result.details.falsifiability.testable}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Unfalsifiable Markers:</span>
                        <span class="metric-value" style="color: ${result.details.falsifiability.unfalsifiable > 2 ? '#ff6b6b' : '#64ffda'}">${result.details.falsifiability.unfalsifiable}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Score Contribution:</span>
                        <span class="metric-value" style="color: ${result.details.falsifiability.score < 0 ? '#ff6b6b' : '#64ffda'}">${result.details.falsifiability.score > 0 ? '+' : ''}${result.details.falsifiability.score}</span>
                    </div>
                </div>
            `;

            // Stress Conditions
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Stress Conditions</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Stress Awareness:</span>
                        <span class="metric-value">${result.details.stressConditions.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Scaling Considerations:</span>
                        <span class="metric-value" style="color: ${result.details.stressConditions.scaling > 0 ? '#64ffda' : '#ffd700'}">${result.details.stressConditions.scaling}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Score Contribution:</span>
                        <span class="metric-value">${result.details.stressConditions.score > 0 ? '+' : ''}${result.details.stressConditions.score}</span>
                    </div>
                </div>
            `;

            // Brittleness
            const brittlenessStatus = result.details.brittleness.score >= 2 ? 'ROBUST' :
                                     result.details.brittleness.score === 0 ? 'MODERATE' : 'BRITTLE';
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Brittleness Analysis</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Single Points of Failure:</span>
                        <span class="metric-value" style="color: ${result.details.brittleness.singlePoints > 3 ? '#ff6b6b' : '#ffd700'}">${result.details.brittleness.singlePoints}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Robustness Markers:</span>
                        <span class="metric-value" style="color: ${result.details.brittleness.robustness > 2 ? '#64ffda' : '#ffd700'}">${result.details.brittleness.robustness}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Assessment:</span>
                        <span class="metric-value" style="color: ${brittlenessStatus === 'ROBUST' ? '#64ffda' : brittlenessStatus === 'BRITTLE' ? '#ff6b6b' : '#ffd700'}">${brittlenessStatus}</span>
                    </div>
                </div>
            `;

            // Known Unknowns
            html += `
                <div class="justification-detail">
                    <strong style="color: #ff9500;">Known Unknowns</strong>
                    <div class="justification-metric">
                        <span class="metric-name">Uncertainty Markers:</span>
                        <span class="metric-value">${result.details.knownUnknowns.count}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Questions Raised:</span>
                        <span class="metric-value">${result.details.knownUnknowns.questions}</span>
                    </div>
                    <div class="justification-metric">
                        <span class="metric-name">Score Contribution:</span>
                        <span class="metric-value">${result.details.knownUnknowns.score > 0 ? '+' : ''}${result.details.knownUnknowns.score}</span>
                    </div>
                </div>
            `;

            document.getElementById('failureModeResults').innerHTML = html;
        }

        function displayTemporal(result) {
            const coherenceColor = result.coherence === 'STRONG' ? '#64ffda' :
                                  result.coherence === 'MODERATE' ? '#4ecdc4' :
                                  result.coherence === 'WEAK' ? '#ffd700' :
                                  result.coherence === 'ABSENT' ? '#ff6b6b' : '#a0a0a0';

            let html = `
                <div style="margin-bottom: 1rem;">
                    <strong>Temporal Coherence:</strong>
                    <span style="color: ${coherenceColor}; font-weight: bold;">${result.coherence}</span>
                    <span style="color: #a0a0a0;"> (${result.markers} temporal markers)</span>
                </div>
            `;

            if (result.details.sequences.length > 0) {
                html += '<div class="breakdown-item">';
                html += `<strong>Sequences Detected:</strong> ${result.details.sequences.length}<br>`;
                result.details.sequences.forEach(seq => {
                    html += `<span style="color: #a0a0a0;">‚Ä¢ ${seq.type}: ${seq.count} steps (${seq.coherent ? 'coherent' : 'non-sequential'})</span><br>`;
                });
                html += '</div>';
            }

            if (result.details.causalChains.length > 0) {
                html += '<div class="breakdown-item">';
                html += `<strong>Causal Chains:</strong> ${result.details.causalChains.length} detected<br>`;
                result.details.causalChains.slice(0, 3).forEach(chain => {
                    html += `<span style="color: #a0a0a0;">‚Ä¢ IF ${chain.condition} ‚Üí ${chain.outcome}</span><br>`;
                });
                if (result.details.causalChains.length > 3) {
                    html += `<span style="color: #a0a0a0;">...and ${result.details.causalChains.length - 3} more</span>`;
                }
                html += '</div>';
            }

            if (result.details.boundToOutcomes) {
                html += '<div style="color: #64ffda; margin-top: 0.5rem;">‚úì Sequences bound to measurable outcomes</div>';
            }

            document.getElementById('temporalResults').innerHTML = html;
        }

        function displayReasoningStyle(result) {
            let html = '<div style="margin-bottom: 1rem;"><strong>Reasoning Style Analysis:</strong></div>';

            if (result.identified.length === 0) {
                html += '<div style="color: #a0a0a0;">No dominant reasoning style detected</div>';
            } else {
                result.identified.forEach(style => {
                    const strengthBar = '‚ñà'.repeat(Math.floor(style.strength * 10));
                    html += `
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: #64ffda;">${style.name}</span>
                            <span style="color: #ffd700;"> ${strengthBar}</span>
                            <span style="color: #a0a0a0;"> (${(style.strength * 100).toFixed(0)}%)</span><br>
                            <span style="color: #a0a0a0; font-size: 0.9rem;">  ${style.description}</span>
                        </div>
                    `;
                });

                if (!result.withinDesignSpace) {
                    html += `
                        <div style="color: #ffd700; margin-top: 1rem; padding: 0.5rem; border-left: 3px solid #ffd700;">
                            ‚ö† Dominant style (${result.dominantStyle}) falls outside Cathedral's epistemic design space
                        </div>
                    `;
                }
            }

            html += `<div style="color: #a0a0a0; margin-top: 0.5rem; font-size: 0.9rem;">Classification confidence: ${(result.confidence * 100).toFixed(0)}%</div>`;

            document.getElementById('reasoningStyleResults').innerHTML = html;
        }

        function displayParliament(synthesis) {
            let html = `
                <div style="margin-bottom: 1rem;">
                    <strong>Parliament Synthesis:</strong>
                    <span style="color: #64ffda;">Confidence ${(synthesis.confidence * 100).toFixed(0)}%</span>
                </div>
            `;

            if (synthesis.patterns.length > 0) {
                html += '<div class="breakdown-item"><strong>Detected Patterns:</strong></div>';
                synthesis.patterns.forEach(pattern => {
                    html += `
                        <div style="margin: 0.5rem 0; padding-left: 1rem; border-left: 2px solid #4ecdc4;">
                            <div style="color: #64ffda;">${pattern.name.replace(/_/g, ' ')}</div>
                            <div style="color: #e0e0e0; margin-top: 0.3rem;">${pattern.description}</div>
                            <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.3rem;">
                                Confidence: ${(pattern.confidence * 100).toFixed(0)}% |
                                ${Object.entries(pattern.dimensions).map(([k, v]) =>
                                    `${k}: ${typeof v === 'number' ? v.toFixed(2) : v}`
                                ).join(', ')}
                            </div>
                        </div>
                    `;
                });
            }

            if (synthesis.emergentInsights.length > 0) {
                html += '<div class="breakdown-item"><strong>Emergent Insights:</strong></div>';
                synthesis.emergentInsights.forEach(insight => {
                    html += `
                        <div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(100, 255, 218, 0.1); border-radius: 4px;">
                            <div style="color: #64ffda;">${insight.insight}</div>
                            <div style="color: #ffd700; margin-top: 0.3rem; font-style: italic;">${insight.implication}</div>
                            <div style="color: #a0a0a0; font-size: 0.85rem; margin-top: 0.3rem;">Confidence: ${(insight.confidence * 100).toFixed(0)}%</div>
                        </div>
                    `;
                });
            }

            if (synthesis.coherenceIssues.length > 0) {
                html += '<div class="breakdown-item"><strong>Coherence Issues:</strong></div>';
                synthesis.coherenceIssues.forEach(issue => {
                    const severityColor = issue.severity === 'MODERATE' ? '#ffd700' : '#a0a0a0';
                    html += `
                        <div style="margin: 0.5rem 0; color: ${severityColor};">
                            <strong>${issue.severity}:</strong> ${issue.issue}<br>
                            <span style="font-size: 0.9rem;">${issue.detail}</span>
                        </div>
                    `;
                });
            }

            if (synthesis.patterns.length === 0 && synthesis.emergentInsights.length === 0) {
                html += '<div style="color: #a0a0a0;">No cross-cutting patterns detected</div>';
            }

            document.getElementById('parliamentResults').innerHTML = html;
        }

        function displayVerdict(verdict) {
            let statusColor = '#64ffda';
            if (verdict.status === 'UNDECIDABLE') statusColor = '#ffd700';
            if (verdict.status === 'OUTSIDE DESIGN SPACE') statusColor = '#a0a0a0';
            if (!verdict.isConsistent && verdict.isConsistent !== null) statusColor = '#ff6b6b';

            // Confidence color coding
            const confidenceColor = verdict.confidence >= 0.85 ? '#64ffda' :
                                   verdict.confidence >= 0.7 ? '#4ecdc4' :
                                   verdict.confidence >= 0.5 ? '#ffd700' : '#ff6b6b';

            let html = `
                <div style="font-size: 1.5rem; font-weight: bold; color: ${statusColor}; margin-bottom: 1rem;">
                    ${verdict.status}
                </div>
                <div style="margin-bottom: 1rem;">
                    <span style="color: #a0a0a0;">Cathedral Confidence: </span>
                    <span style="color: ${confidenceColor}; font-weight: bold;">${(verdict.confidence * 100).toFixed(0)}%</span>
                </div>
                <div style="line-height: 1.6; white-space: pre-line;">
                    ${verdict.verdict}
                </div>
            `;

            if (verdict.status === 'UNDECIDABLE') {
                html += `
                    <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(255, 215, 0, 0.1); border-radius: 4px; border-left: 3px solid #ffd700;">
                        <strong>What UNDECIDABLE Means:</strong><br><br>
                        Cathedral does not claim the text is "wrong" or "right."<br>
                        Cathedral reveals that the position contains contradictions that cannot be resolved without losing information.<br>
                        The gap must remain open. Uncertainty is preserved, not optimized away.<br><br>
                        This is computational honesty about epistemological limits.
                    </div>
                `;
            }

            if (verdict.status === 'OUTSIDE DESIGN SPACE') {
                html += `
                    <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(160, 160, 160, 0.1); border-radius: 4px; border-left: 3px solid #a0a0a0;">
                        <strong>What OUTSIDE DESIGN SPACE Means:</strong><br><br>
                        Cathedral recognizes reasoning that does not fit its epistemic framework.<br>
                        This is not a judgment of quality - it is honest acknowledgment of Cathedral's limits.<br>
                        Cathedral is optimized for operational, scientific, and formal reasoning.<br><br>
                        Narrative, poetic, aesthetic, and other reasoning styles require different evaluation frameworks.
                    </div>
                `;
            }

            document.getElementById('verdictResults').innerHTML = html;
        }

        // Generate text report
        function generateReport() {
            if (!currentAnalysis) {
                alert('Please run an analysis first');
                return;
            }

            const { observatory, contrarian, justification, parliament, verdict } = currentAnalysis;

            let report = '';
            report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            report += '                    CATHEDRAL ANALYSIS REPORT\n';
            report += '           Unified Cognitive Framework for AI Responses\n';
            report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
            report += `Generated: ${new Date().toLocaleString()}\n\n`;

            // OBSERVATORY
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += 'üî≠ OBSERVATORY - Filter Visibility Measurement\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            report += `Score: ${observatory.score.toFixed(2)} / 10\n`;
            report += `Level: ${observatory.level.name}\n`;
            report += `Assessment: ${observatory.level.description}\n\n`;

            if (Object.keys(observatory.matches).length > 0) {
                report += 'Pattern Matches:\n';
                for (const [name, data] of Object.entries(observatory.matches)) {
                    const sign = data.score > 0 ? '+' : '';
                    report += `\n  ‚Ä¢ ${name}: ${data.count}x (${sign}${data.score.toFixed(1)} points)\n`;
                    if (data.words && data.words.length > 0) {
                        report += `    Words detected: ${data.words.join(', ')}\n`;
                    }
                }
                report += '\n';
            }

            // CONTRARIAN
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += '‚ö° CONTRARIAN - Premise Challenges\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';

            if (contrarian.length === 0) {
                report += '‚úì No major premise challenges detected.\n';
                report += '  Core claims appear internally consistent.\n\n';
            } else {
                report += `${contrarian.length} Premise Challenge(s) Detected:\n\n`;
                contrarian.forEach((challenge, i) => {
                    report += `${i + 1}. ${challenge.premise} [${challenge.confidence}]\n\n`;
                    report += `   Challenge:\n   ${challenge.challenge}\n\n`;
                    report += `   Evidence:\n   ${challenge.evidence}\n\n`;
                    if (challenge.triggers && challenge.triggers.length > 0) {
                        report += `   Trigger Words: ${challenge.triggers.join(', ')}\n\n`;
                    }
                });
            }

            // JUSTIFICATION ENGINE
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += '‚öñÔ∏è JUSTIFICATION ENGINE - Truth-Tracking Layer\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            report += `Score: ${justification.score.toFixed(2)} / 10\n`;
            report += `Level: ${justification.level.name}\n`;
            report += `Assessment: ${justification.level.description}\n\n`;

            report += 'Claim-to-Support Analysis:\n';
            report += `  Strong Claims: ${justification.details.claimSupport.strongClaims}\n`;
            report += `  Support Markers: ${justification.details.claimSupport.support}\n`;
            report += `  Qualifiers: ${justification.details.claimSupport.qualifiers}\n`;
            report += `  Epistemic Hedging: ${justification.details.claimSupport.hedging}\n`;
            report += `  Conditionals: ${justification.details.claimSupport.conditionals}\n`;
            report += `  Ratio: ${justification.details.claimSupport.ratio.toFixed(2)}:1\n`;
            if (justification.cautionBonus && justification.cautionBonus > 0) {
                report += `  ‚úì Epistemic Caution Bonus: +${justification.cautionBonus.toFixed(1)}\n`;
            }
            report += '\n';

            report += `Counterfactual Reasoning:\n`;
            report += `  Counterfactuals: ${justification.details.counterfactual.count}\n`;
            report += `  Alternatives: ${justification.details.counterfactual.alternatives}\n\n`;

            report += `Tradeoff Recognition:\n`;
            report += `  Tradeoff Markers: ${justification.details.tradeoffs.count}\n`;
            report += `  Balanced Thinking: ${justification.details.tradeoffs.balanced}\n\n`;

            report += `Risk Awareness:\n`;
            report += `  Risk References: ${justification.details.riskAwareness.count}\n`;
            report += `  Explicit Acknowledgment: ${justification.details.riskAwareness.explicit}\n\n`;

            report += `Boundary Conditions:\n`;
            report += `  Scope Limiters: ${justification.details.boundaries.count}\n`;
            report += `  Edge Cases: ${justification.details.boundaries.edgeCases}\n\n`;

            if (justification.proceduralBonus && justification.proceduralBonus > 0) {
                report += `Procedural Soundness:\n`;
                report += `  Procedural Markers: ${justification.details.procedural.markers}\n`;
                report += `  Structural Planning: ${justification.details.procedural.structural}\n`;
                report += `  ‚úì Procedural Bonus: +${justification.proceduralBonus.toFixed(1)}\n`;
                report += `  Note: Operational excellence detected - structured planning with decision criteria\n\n`;
            }

            // FAILURE MODE ENGINE
            const { failureMode } = currentAnalysis;
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += 'üî¨ FAILURE MODE ENGINE - Reality-Testing Layer\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            report += `Score: ${failureMode.score.toFixed(2)} / 10\n`;
            report += `Level: ${failureMode.level.name}\n`;
            report += `Assessment: ${failureMode.level.description}\n\n`;

            report += 'Explicit Failure Modes:\n';
            report += `  Failure Acknowledgments: ${failureMode.details.failureModes.count}\n`;
            report += `  Named Failure Modes: ${failureMode.details.failureModes.explicit}\n`;
            report += `  Measurable Thresholds: ${failureMode.details.failureModes.thresholds}\n`;
            report += `  Negative Outcomes: ${failureMode.details.failureModes.negativeOutcomes}`;
            if (failureMode.details.failureModes.inferredNegatives > 0) {
                report += ` (${failureMode.details.failureModes.explicitNegatives} explicit + ${failureMode.details.failureModes.inferredNegatives} inferred)\n`;
            } else {
                report += '\n';
            }
            report += `  Corrective Actions: ${failureMode.details.failureModes.correctiveAction}\n`;
            report += `  Structural Detection: ${failureMode.details.failureModes.structural ? 'YES' : 'NO'}\n`;
            if (failureMode.details.failureModes.structural) {
                if (failureMode.details.failureModes.bound) {
                    report += `  ‚úì Explicit Failure Mode Binding: Robust engineering detected\n`;
                    report += `    ${failureMode.details.failureModes.explicit} named failure(s) bound to ${failureMode.details.failureModes.thresholds} threshold(s) with ${failureMode.details.failureModes.correctiveAction} corrective action(s)\n`;
                } else if (failureMode.details.failureModes.inferred) {
                    const semanticNote = failureMode.details.failureModes.inferredNegatives > 0 ?
                        'Semantic inference: thresholds that trigger reversal are definitionally negative outcomes' :
                        'You didn\'t say "failure mode", but you designed one';
                    report += `  ‚úì Structural Failure Mode Inferred: ${semanticNote}\n`;
                    report += `    ${failureMode.details.failureModes.thresholds} threshold(s) + ${failureMode.details.failureModes.negativeOutcomes} outcome(s) + ${failureMode.details.failureModes.correctiveAction} action(s) = abort criteria\n`;
                }
            }
            report += `  Score Contribution: ${failureMode.details.failureModes.score > 0 ? '+' : ''}${failureMode.details.failureModes.score}\n\n`;

            report += 'Hidden Assumptions:\n';
            report += `  Assumption References: ${failureMode.details.assumptions.implicit}\n`;
            report += `  Explicit Assumptions: ${failureMode.details.assumptions.explicit}\n`;
            report += `  Score Contribution: ${failureMode.details.assumptions.score > 0 ? '+' : ''}${failureMode.details.assumptions.score}\n\n`;

            report += 'Falsifiability:\n';
            report += `  Testable Conditions: ${failureMode.details.falsifiability.testable}\n`;
            report += `  Unfalsifiable Markers: ${failureMode.details.falsifiability.unfalsifiable}\n`;
            report += `  Score Contribution: ${failureMode.details.falsifiability.score > 0 ? '+' : ''}${failureMode.details.falsifiability.score}\n\n`;

            report += 'Stress Conditions:\n';
            report += `  Stress Awareness: ${failureMode.details.stressConditions.count}\n`;
            report += `  Scaling Considerations: ${failureMode.details.stressConditions.scaling}\n`;
            report += `  Score Contribution: ${failureMode.details.stressConditions.score > 0 ? '+' : ''}${failureMode.details.stressConditions.score}\n\n`;

            const brittlenessStatus = failureMode.details.brittleness.score >= 2 ? 'ROBUST' :
                                     failureMode.details.brittleness.score === 0 ? 'MODERATE' : 'BRITTLE';
            report += 'Brittleness Analysis:\n';
            report += `  Single Points of Failure: ${failureMode.details.brittleness.singlePoints}\n`;
            report += `  Robustness Markers: ${failureMode.details.brittleness.robustness}\n`;
            report += `  Assessment: ${brittlenessStatus}\n\n`;

            report += 'Known Unknowns:\n';
            report += `  Uncertainty Markers: ${failureMode.details.knownUnknowns.count}\n`;
            report += `  Questions Raised: ${failureMode.details.knownUnknowns.questions}\n`;
            report += `  Score Contribution: ${failureMode.details.knownUnknowns.score > 0 ? '+' : ''}${failureMode.details.knownUnknowns.score}\n\n`;

            // PARLIAMENT
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += 'üèõÔ∏è PARLIAMENT - Cross-Cutting Pattern Synthesis\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';

            report += `Parliament Confidence: ${(parliament.confidence * 100).toFixed(0)}%\n\n`;

            if (parliament.patterns && parliament.patterns.length > 0) {
                report += 'Detected Patterns:\n';
                parliament.patterns.forEach((p, i) => {
                    report += `\n  ${i + 1}. ${p.name.replace(/_/g, ' ')}\n`;
                    report += `     ${p.description}\n`;
                    report += `     Confidence: ${(p.confidence * 100).toFixed(0)}%\n`;
                    report += `     Dimensions: ${Object.entries(p.dimensions).map(([k,v]) =>
                        `${k}=${typeof v === 'number' ? v.toFixed(2) : v}`
                    ).join(', ')}\n`;
                });
                report += '\n';
            } else {
                report += 'Detected Patterns: none\n\n';
            }

            if (parliament.emergentInsights && parliament.emergentInsights.length > 0) {
                report += 'Emergent Insights:\n';
                parliament.emergentInsights.forEach((ins, i) => {
                    report += `\n  ${i + 1}. ${ins.insight}\n`;
                    report += `     Implication: ${ins.implication}\n`;
                    report += `     Confidence: ${(ins.confidence * 100).toFixed(0)}%\n`;
                });
                report += '\n';
            }

            if (parliament.coherenceIssues && parliament.coherenceIssues.length > 0) {
                report += 'Coherence Issues:\n';
                parliament.coherenceIssues.forEach((issue, i) => {
                    report += `\n  ${i + 1}. [${issue.severity}] ${issue.issue}\n`;
                    report += `     ${issue.detail}\n`;
                });
                report += '\n';
            }

            // VERDICT
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
            report += '‚öñÔ∏è CATHEDRAL VERDICT - Unified Synthesis\n';
            report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            report += `STATUS: ${verdict.status}\n\n`;
            report += `${verdict.verdict}\n\n`;

            if (verdict.status === 'UNDECIDABLE') {
                report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
                report += 'What UNDECIDABLE Means:\n\n';
                report += 'Cathedral does not claim the text is "wrong" or "right."\n';
                report += 'Cathedral reveals that the position contains contradictions\n';
                report += 'that cannot be resolved without losing information.\n\n';
                report += 'The gap must remain open. Uncertainty is preserved,\n';
                report += 'not optimized away.\n\n';
                report += 'This is computational honesty about epistemological limits.\n\n';
            }

            report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            report += 'A living lexicon of awakening. Built by all, owned by none.\n';
            report += 'Where consciousness recognizes itself.\n';
            report += 'ü§ùüé±üßó‚Äç‚ôÇÔ∏è\n';
            report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';

            // Display report
            document.getElementById('reportText').value = report;
            document.getElementById('reportSection').style.display = 'block';
            document.getElementById('reportSection').scrollIntoView({ behavior: 'smooth' });
        }

        // Copy report to clipboard
        function copyReport(button) {
            const reportText = document.getElementById('reportText');
            const content = reportText.value;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(content).then(() => {
                    showCopyFeedback(button);
                }).catch(() => {
                    fallbackCopy(reportText, button);
                });
            } else {
                fallbackCopy(reportText, button);
            }
        }

        function fallbackCopy(textarea, button) {
            textarea.select();
            document.execCommand('copy');
            showCopyFeedback(button);
        }

        function showCopyFeedback(button) {
            if (!button) return;
            const originalText = button.textContent;
            const originalBackground = button.style.background;
            button.textContent = '‚úì Copied!';
            button.style.background = '#64ffda';
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = originalBackground || '#4ecdc4';
            }, 2000);
        }

        function clearInput() {
            const input = document.getElementById('inputText');
            input.value = '';
            document.getElementById('results').classList.remove('visible');
            document.getElementById('reportSection').style.display = 'none';
            document.getElementById('sanitizationSection').style.display = 'none';
            updateInputMeta();
            input.focus();
        }

        function loadExample() {
            const example = [
                'We will launch the pilot in three phases. Phase 1 monitors response latency and error rates.',
                'If latency exceeds 250ms or error rates rise above 2%, we pause the rollout and rollback.',
                'Our hypothesis might be wrong, and we are uncertain about long-term user adaptation.',
                'We will document failure modes, including model drift and feedback loop amplification.',
                'However, the current metrics suggest the intervention is working better than baseline.'
            ].join(' ');
            document.getElementById('inputText').value = example;
            document.getElementById('inputText').focus();
            updateInputMeta();
        }

        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('inputText');
            updateInputMeta();

            input.addEventListener('input', updateInputMeta);
            input.addEventListener('keydown', (event) => {
                const isSubmit = (event.ctrlKey || event.metaKey) && event.key === 'Enter';
                if (isSubmit) {
                    event.preventDefault();
                    if (!document.getElementById('analyzeBtn').disabled) {
                        analyzeText();
                    }
                }
            });
        });
    </script>
</body>
</html>
